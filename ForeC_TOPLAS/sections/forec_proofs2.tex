\subsection{Commutativity and Associativity of \sc{Combine}}
The commutativity and associativity of the \verb$par$ kernel statement
depends on how the shared variables are resynchronized. Of interest is the 
commutativity and associativity of the semantic function $\Combine$ 
(Section~\ref{sec:forec_Combine}), which combines the copies of each 
shared variable in a pairwise manner. As described in Algorithm~\ref{algo:Combine}, 
the shared variable's combine policy is always applied (lines~\ref{algo:Combine_default}--\ref{algo:Combine_endif1}) 
before the remaining copies are combined (lines~\ref{algo:Combine_if}--\ref{algo:Combine_endif2}). 
Let $s$ be a shared variable with 
combine policy $p \in \{\mathtt{all}, \mathtt{new}, \mathtt{mod}\}$ 
and combine function $cf$. If $s_1$, $s_2$, and $s_3$ are three copies 
of $s$, then let the following concise notation represent the computation
of the combined value:
\begin{equation*}
	cf \Bigl(p(s_1),~p \bigl(cf(p(s_2),~p(s_3))\bigr)\Bigr)
\end{equation*}
where, for example, $cf(p(s_2),~p(s_3))$ removes the copies 
$s_2$ and $s_3$ that do not satisfy the combine policy $p$
before combining the remaining copies. Different bracket sizes 
are used to clarify the nesting of the operations.

\begin{definition}
	\label{def:commutative_combine}
	The semantic function $\Combine$ is \emph{\textbf{commutative}} if the combined 
	result is independent of how the copies are 
	ordered during the combining process:
	\begin{equation*}
		\forall s_1, s_2:
		\quad
		cf(p(s_1),~p(s_2))
		\Longleftrightarrow
		cf(p(s_2),~p(s_1))
	\end{equation*}
\end{definition}

\begin{definition}
	\label{def:associative_combine}
	The semantic function $\Combine$ is \emph{\textbf{associative}} if the combined 
	result is independent of how the copies are 
	paired during the combining process:
	\begin{equation*}
		\forall s_1, s_2, s_3:
		\quad
		cf(p(s_1),~p(cf(p(s_2),~p(s_3))))
		\Longleftrightarrow
		cf(p(cf(p(s_1),~p(s_2))),~p(s_3))
	\end{equation*}
\end{definition}

\begin{theorem}
	\label{thm:commutative_combine}
	The semantic function $\Combine$ is commutative if all the 
	required combine functions are also commutative.
\end{theorem}
\begin{proof}
	We start by showing that, for a shared variable $s$ with 
	combine function $cf$, the commutativity of the semantic function 
	$\Combine$ only depends on the commutativity of $cf$. For the 
	combine policy $p = \mathtt{all}$, the table below shows the 
	result of combining the copies in different orders. The 
	left side of the table enumerates the possible combinations of 
	copies that satisfy the combine policy $p$. The remaining right 
	side of the table shows the result of combining the copies in
	different orders.
	\begin{center}
		\begin{tabular}{| c c || c | c |}
			\hline
			\boldmath$p(s_1)$	& \boldmath$p(s_2)$	& \boldmath$cf(p(s_1),~p(s_2))$	& \boldmath$cf(p(s_2),~p(s_1))$	\\ 
			\hline
			$s_1$				& $s_2$				& $cf(s_1,~s_2)$				& $cf(s_2,~s_1)$				\\
			\hline
		\end{tabular}
	\end{center}
	Similarly, for the combine policies $p \in \{\mathtt{new}, \mathtt{mod}\}$, the 
	table below shows the result of combining the copies in 
	different orders. A $\bot$ is used to indicate that a value 
	does not exist.
	\begin{center}
		\begin{tabular}{| c c || c | c |}
			\hline
			\boldmath$p(s_1)$	& \boldmath$p(s_2)$	& \boldmath$cf(p(s_1),~p(s_2))$	& \boldmath$cf(p(s_2),~p(s_1))$	\\ 
			\hline
			$s_1$				& $s_2$				& $cf(s_1,~s_2)$				& $cf(s_2,~s_1)$				\\ \hline
			$s_1$				& $\bot$			& \multicolumn{2}{c|}{$s_1$}									\\ \hline			
			$\bot$				& $s_2$				& \multicolumn{2}{c|}{$s_2$}									\\ \hline			
			$\bot$				& $\bot$			& \multicolumn{2}{c|}{$\bot$}									\\			
			\hline
		\end{tabular}
	\end{center}
	From the tables above, we can see that the commutativity
	of the semantic function $\Combine$ depends only on the 
	commutativity of the combine function.
	Thus, $\Combine$ is only commutative
	if all the required combined functions are also commutative.
\end{proof}

\begin{theorem}
	\label{thm:associative_combine}
	The semantic function $\Combine$ is associative if all the 
	required combine functions are also associative.
\end{theorem}
\begin{proof}
	We start by showing that, for a shared variable $s$ with 
	combine function $cf$, the associativity of the semantic function 
	$\Combine$ only depends on the associativity of $cf$. For the 
	combine policy $p = \mathtt{all}$, the table below shows the 
	result of combining the copies in different pairs. The 
	left side of the table enumerates the possible combinations of 
	copies that satisfy the combine policy $p$. The remaining right 
	side of the table shows the result of combining the copies in
	different pairs.
	\begin{center}
		\begin{tabular}{| c c c || c | c |}
			\hline
			\boldmath$p(s_1)$	& \boldmath$p(s_2)$	&\boldmath$p(s_3)$	& \boldmath$cf(p(s_1),~p(cf(p(s_2),~p(s_3))))$	& \boldmath$cf(p(cf(p(s_1),~p(s_2))),~p(s_3))$	\\ 
			\hline
			$s_1$				& $s_2$				& $s_3$				& $cf(s_1,~cf(s_2,~s_3))$						& $cf(cf(s_1,~s_2),~s_3)$						\\
			\hline
		\end{tabular}
	\end{center}
	Similarly, for the combine policies $p \in \{\mathtt{new}, \mathtt{mod}\}$, the 
	table below shows the result of combining the copies in 
	different pairs. Recall that the combine policy does not apply to 
	partially combined results (lines~\ref{algo:Combine_new} and 
	\ref{algo:Combine_mod} in Algorithm~\ref{algo:Combine}). 
	A $\bot$ is used to indicate that a value does not exist.
	\begin{center}
		\begin{tabular}{| c c c || c | c |}
			\hline
			\boldmath$p(s_1)$	& \boldmath$p(s_2)$	&\boldmath$p(s_3)$	& \boldmath$cf(p(s_1),~p(cf(p(s_2),~p(s_3))))$	& \boldmath$cf(p(cf(p(s_1),~p(s_2))),~p(s_3))$	\\ 
			\hline
			$s_1$				& $s_2$				& $s_3$				& $cf(s_1,~cf(s_2,~s_3))$						& $cf(cf(s_1,~s_2),~s_3)$						\\ \hline
			$s_1$				& $s_2$				& $\bot$			& \multicolumn{2}{c|}{$cf(s_1,~s_2)$}															\\ \hline
			$s_1$				& $\bot$			& $s_3$				& \multicolumn{2}{c|}{$cf(s_1,~s_3)$}															\\ \hline
			$\bot$				& $s_2$				& $s_3$				& \multicolumn{2}{c|}{$cf(s_2,~s_3)$}															\\ \hline
			$s_1$				& $\bot$			& $\bot$			& \multicolumn{2}{c|}{$s_1$}																	\\ \hline
			$\bot$				& $s_2$				& $\bot$			& \multicolumn{2}{c|}{$s_2$}																	\\ \hline
			$\bot$				& $\bot$			& $s_3$				& \multicolumn{2}{c|}{$s_3$}																	\\ \hline
			$\bot$				& $\bot$			& $\bot$			& \multicolumn{2}{c|}{$\bot$}																	\\
			\hline
		\end{tabular}
	\end{center}
	From the tables above, we can see that the associativity
	of the semantic function $\Combine$ depends only on the 
	associativity of the combine function.
	Thus, $\Combine$ is only associative
	if all the required combined functions are also associative.
\end{proof}


\subsection{Commutativity and Associativity of the \texttt{par} Kernel Statement}
Forking more than two threads at the same time can be achieved by 
nesting a number of \verb$par$ kernel statements together, e.g., 
$\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2}),~\thread{3}:\body{3})$.
It is important to know if the ordering or pairing of the
nested threads affects the program's execution behavior. That is,
under what circumstances is the \verb$par$ kernel statement 
commutative and associative.

\begin{definition}
	\label{def:commutative_par}
	The \verb$par$ statement is \emph{\textbf{commutative}} if its effects
	on the program's state at the end of each reaction is independent of how its
	threads are ordered:
	\begin{equation*}
		\forall \thread{1}, \thread{2}:
		\quad
		\thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
		\Longleftrightarrow
		\thread{}:\mathtt{par}(\thread{2}:\body{2},~\thread{1}:\body{1})
	\end{equation*}
\end{definition}

\begin{definition}
	\label{def:associative_par}
	The \verb$par$ kernel statement is \emph{\textbf{associative}} if its effects 
	on the program's state at the end of each reaction is independent of how its 
	threads are paired together:
	\begin{multline*}
		\forall \thread{1}, \thread{2}, \thread{3}:
		\quad
		\thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2}),~\thread{3}:\body{3})	\\
		\Longleftrightarrow
		\thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{a}:\mathtt{par}(\thread{2}:\body{2},~\thread{3}:\body{3}))
	\end{multline*}
\end{definition}

\begin{theorem}
	\label{thm:commute_associate_par}
	The \verb$par$ kernel statement is commutative and associative if the 
	semantic function $\Combine$ is commutative and associative.
\end{theorem}
\begin{proof}
	We start with the following observations about how the program state can be modified:
	\begin{itemize}
		\item A thread can modify a subset of the program's environment 
			  \Environment{}. By virtue of private variables, the (\ref{forec:assign-shared}) 
			  rule for shared variables, and the semantic 
			  function $\Eval$ (Section~\ref{sec:forec_Eval}), the subset remains 
			  the same throughout the reaction and is mutually exclusive from the
			  subsets of all other threads.
		
		\item A thread can modify a subset of the program's preemption statuses \Abort{}. 
			  By virtue of translating the \verb$abort$ statement into the \verb$status$ 
			  and \verb$abort$ kernel statements, the subset remains the same throughout
			  the reaction and is mutually exclusive from the subsets of all other threads.
			  
		\item The \verb$par$ rules use a commutative and associative set operation to
			  merge the modified program states of each thread.

		\item When both threads of a \verb$par$ kernel statement complete their respective
			  reactions, their merged state is 
			  combined using the semantic function $\Combine$ 
			  (Section~\ref{sec:forec_Combine}). From Theorems~\ref{thm:commutative_combine}
			  and \ref{thm:associative_combine}, the commutativity and associativity 
			  of $\Combine$ depends on the required combine functions.
	\end{itemize}
	Based on these observations and Theorems~\ref{thm:reactive} and 
	\ref{thm:deterministic}, the proof can be shown by structural 
	induction on $\thread{}:\body{}$. Only the \verb$par$ kernel statement
	is of interest. In the following, assume the induction hypothesis that
	there always exists $\body{1}'$, $\body{2}'$, and $\body{3}'$ such that:
	\begin{align}
		\label{eq:proofs_hypothesis3}
		\langle \StateP_1 \rangle ~ \thread{1}:\body{1}
		&	\xRightarrow[~~\Input~~]{k_1 \in \{0, 1\}} 
		\langle \StateP_1' \rangle ~ \thread{1}:\body{1}'			\\
		\label{eq:proofs_hypothesis4}
		\langle \StateP_2 \rangle ~ \thread{2}:\body{2}
		&	\xRightarrow[~~\Input~~]{k_2 \in \{0, 1\}} 
		\langle \StateP_2' \rangle ~ \thread{2}:\body{2}'			\\
		\label{eq:proofs_hypothesis5}
		\langle \StateP_3 \rangle ~ \thread{3}:\body{3}
		&	\xRightarrow[~~\Input~~]{k_3 \in \{0, 1\}} 
		\langle \StateP_3' \rangle ~ \thread{2}:\body{3}'
	\end{align}
	\begin{enumerate}
		\item Consider, the commutativity of the \verb$par$ kernel
			  statement. The table below shows the result of commuting the
			  threads due to the hypotheses of equations~\ref{eq:proofs_hypothesis3} 
			  and \ref{eq:proofs_hypothesis4}. The left side of the 
			  table enumerates the possible combinations of completion
			  codes ($k_1$ and $k_2$). The remaining right side
			  of the table shows the resulting reactions of the 
			  \verb$par$ kernel statements.
			  \begin{center}
				\begin{tabular}{| c c || l | l |}
					\hline
					\boldmath$k_1$	& \boldmath$k_2$	& ~~~\boldmath$\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})$							& ~~~\boldmath$\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{2}:\body{2},~\thread{1}:\body{1})$							\\ 
					\hline																																								
					$1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}')$		& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{2}:\body{2}',~\thread{1}:\body{1}')$		\\ \hline
					$0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{2}:\body{2}')$	& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{2}:\body{2}',~\thread{1}:\mathtt{nop})$	\\ \hline
					$1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{2}:\body{2}',~\thread{1}:\mathtt{nop})$	& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{2}:\body{2}')$	\\ \hline
					$0$				& $0$				& $\xRightarrow[~~\Input~~]{0} \langle \StateP' \rangle ~ \thread{}:\mathtt{nop}$													& $\xRightarrow[~~\Input~~]{0} \langle \StateP'' \rangle ~ \thread{}:\mathtt{nop}$													\\
					\hline
				\end{tabular}
			  \end{center}
			  For each row, $\StateP' = \StateP''$ if the semantic 
			  function $\Combine$ is commutative (Theorem~\ref{thm:commutative_combine}).
			  Thus, the \verb$par$ kernel statement is commutative
			  if $\Combine$ is commutative.

		\item Consider, the associativity of the \verb$par$ kernel
			  statement. The tables below show the result of associating the
			  threads due to the hypotheses of equations~\ref{eq:proofs_hypothesis3}, 
			  \ref{eq:proofs_hypothesis4}, and \ref{eq:proofs_hypothesis5}. 
			  The left side of the table enumerates the possible 
			  combinations of completion codes ($k_1$, $k_2$, and $k_3$). 
			  The remaining right side of the table shows the resulting 
			  reactions of the \verb$par$ kernel statements.
			  \begin{center}
				\begin{tabular}{| c c c || l |}
					\hline
					\boldmath$k_1$	& \boldmath$k_2$	& \boldmath$k_3$	& ~~~\boldmath$\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2}),~\thread{3}:\body{3})$							\\ 
					\hline 																																								
					$1$				& $1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}'),~\thread{3}:\body{3}')$		\\ \hline
					$0$				& $1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{2}:\body{2}'),~\thread{3}:\body{3}')$		\\ \hline
					$1$				& $0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\mathtt{nop}),~\thread{3}:\body{3}')$		\\ \hline
					$0$				& $0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{nop},~\thread{3}:\body{3}')$													\\ \hline
					$1$				& $1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}'),~\thread{3}:\mathtt{nop})$		\\ \hline
					$0$				& $1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{2}:\body{2}'),~\thread{3}:\mathtt{nop})$	\\ \hline
					$1$				& $0$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\mathtt{nop}),~\thread{3}:\mathtt{nop})$	\\ \hline
					$0$				& $0$				& $0$				& $\xRightarrow[~~\Input~~]{0} \langle \StateP' \rangle ~ \thread{}:\mathtt{nop}$																									\\
					\hline
				\end{tabular}
			  \end{center}
			  \begin{center}
				\begin{tabular}{| c c c || l |}
					\hline
					\boldmath$k_1$	& \boldmath$k_2$	& \boldmath$k_3$	& ~~~\boldmath$\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{a}:\mathtt{par}(\thread{2}:\body{2},~\thread{3}:\body{3}))$							\\ 
					\hline																																								
					$1$				& $1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{a}:\mathtt{par}(\thread{2}:\body{2}',~\thread{3}:\body{3}'))$		\\ \hline
					$0$				& $1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{a}:\mathtt{par}(\thread{2}:\body{2}',~\thread{3}:\body{3}'))$	\\ \hline
					$1$				& $0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{a}:\mathtt{par}(\thread{2}:\mathtt{nop},~\thread{3}:\body{3}'))$	\\ \hline
					$0$				& $0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{a}:\mathtt{par}(\thread{2}:\mathtt{nop},~\thread{3}:\body{3}'))$	\\ \hline
					$1$				& $1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{a}:\mathtt{par}(\thread{2}:\body{2}',~\thread{3}:\mathtt{nop}))$	\\ \hline
					$0$				& $1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{a}:\mathtt{par}(\thread{2}:\body{2}',~\thread{3}:\mathtt{nop}))$	\\ \hline
					$1$				& $0$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{a}:\mathtt{nop})$													\\ \hline
					$0$				& $0$				& $0$				& $\xRightarrow[~~\Input~~]{0} \langle \StateP'' \rangle ~ \thread{}:\mathtt{nop}$																									\\
					\hline
				\end{tabular}
			  \end{center}
			  For each corresponding row in the tables above, $\StateP' = \StateP''$ if the semantic 
			  function $\Combine$ is associative (Theorem~\ref{thm:associative_combine}).
			  Thus, the \verb$par$ kernel statement is associative
			  if $\Combine$ is associative.
	\end{enumerate}
\end{proof}


\subsection{Thread Equivalence and Composition}
During implementation, a ForeC program may need to be 
optimized to satisfy memory or execution time requirements. 
It is useful to verify that the optimized ForeC program 
behaves equivalently to the original program. 

\begin{definition}
	\label{def:equivalence}
	Two threads, \thread{1} and \thread{2}, are \emph{\textbf{equivalent}}, 
	i.e., $\thread{1}:\body{1}' \equiv \thread{2}:\body{2}'$,
	if the reactions of both threads produce the same completion code and program 
	state. Moreover, future reactions of both threads are also equivalent:
	\begin{align*}
		\thread{1}:\body{1} \equiv \thread{2}:\body{2}
		\text{ \emph{if} }
		\forall \StateP: 
		\quad
		\langle \StateP \rangle ~ \thread{1}:\body{1} 
		&	\xRightarrow[~~\Input~~]{k_1 \in \{0, 1\}} 
		\langle \StateP' \rangle ~ \thread{1}:\body{1}'		\\
		\langle \StateP \rangle ~ \thread{2}:\body{2} 
		&	\xRightarrow[~~\Input~~]{k_2 \in \{0, 1\}} 
		\langle \StateP'' \rangle ~ \thread{2}:\body{2}'	\\
		\text{\emph{where,} }
		k_1 = k_2,~
		\StateP' &= \StateP'',~
		\thread{1}:\body{1}' \equiv \thread{2}:\body{2}'
	\end{align*}
\end{definition}

\begin{theorem}
	\label{thm:composition}
	Two equivalent threads can each be composed in parallel with 
	a third thread to produce two equivalent parallel programs:
	\begin{equation*}
		\text{\emph{If} }
		\thread{1}:\body{1} \equiv \thread{2}:\body{2} 
		\text{\emph{, then} }
		\forall \thread{3}:\body{3}:
		\quad
		\thread{}:\mathtt{par}(\thread{1}: \body{1},~\thread{3}:\body{3}) \equiv \thread{}:\mathtt{par}(\thread{2}: \body{2},~\thread{3}:\body{3})
	\end{equation*}
\end{theorem}
\begin{proof}
	From Theorems~\ref{thm:reactive} and \ref{thm:deterministic}, it can be 
	easily verified that both parallel programs must perform the same sequence
	of reactions and, therefore, are equivalent programs.
\end{proof}
