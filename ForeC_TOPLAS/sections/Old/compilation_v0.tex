\section{Compilation}
\label{sec:compilation}

Syntax-directed translation of ForeC to C. Structural and pattern based.

\subsection{Intermediate Format}

\subsection{Static Type-Checking of Shared Variables}
In this section, we describe the type checking process for identifying 
all variables that may be accessed by multiple threads and checking that 
they have been declared as shared variables. A non-shared variable is 
a private variable and it can only be accessed by one thread throughout 
its lifetime. The type checking performed by C-compilers can be easily 
extended to handle the checking of shared variables. The type checking 
is performed by traversing the program's control-flow and tracking the 
threads that \emph{declare}, \emph{define}, and \emph{use} the variables. 
A variable is \emph{defined} whenever it is assigned a value, and \emph{used} 
whenever it is evaluated for its value. In compiler theory \cite{compiler_def_use}, 
the functions $Def(st)$ and $Use(st)$ are used in data-flow analysis to 
return the set of defined and used variables in the statement \emph{st}. 
Briefly,

\begin{equation*}
	Def(st) = \{ all~variables~in~st~that~are~L-values \}
\end{equation*}
\begin{equation*}
	Use(st) = \{ all~variables~in~st~that~are~R-values \}
\end{equation*}

A declaration error occurs when (1) a variable being accessed has no 
corresponding declaration, (2) a private variable is found to be accessed 
by multiple threads, or (3) a variable is declared again in the same scope 
as its previous declaration. 
Variable declarations are tracked by the environment \emph{E}, which is 
a function that maps variables (\emph{Var}) to type qualifier information 
(\emph{Type}) and references to other variables (\emph{Ref}): 

\begin{equation*}
	E: Var \to \langle Type,~Ref \rangle
\end{equation*}
\emph{Type} is \emph{pvt} or \emph{shd} if the variable is declared private 
or shared, respectively. Variables can be declared as pointers to other 
variables, $Var_{Scope}$, where the subscript indicates the scope of declaration. 
For variables not declared as pointers, \emph{Ref} is $\bot$ to mean undefined. 
We use the infix `.' operator to access the elements in a tuple. For example, 
$E[var_{scope}].type$ and $E[var_{scope}].ref$ rerturns the \emph{Type} and 
\emph{Ref} of variable $var_{scope}$.

Variable definitions and usages are tracked by the environments \emph{D} and 
\emph{U}, respectively, which are functions that map variables (\emph{Var}) 
to sets of thread identifiers (\emph{Thr}). For the environment \emph{D} 
(\emph{U}, respectively), each \emph{Thr} contains the identifiers of threads 
that define (use) the same variable: 

\begin{equation*}
	D: Var \to \{Thr\}
\end{equation*}
\begin{equation*}
	U: Var \to \{Thr\}
\end{equation*}

\subsubsection{Variable Scoping}
To handle variable scoping, a new local environment is appended to 
\emph{E}, \emph{D}, and \emph{U} when the traversal of the program 
reaches a new scope. A variable declaration in the new scope will 
update the new local environments with a mapping for the variable. 
If the variable is already mapped in the new local environments, 
then a declaration error occurs (Error: Declaring the same variable again). 
Each scope is uniquely identified and all threads are implicitly 
scoped. To find a variable declaration in \emph{E}, \emph{D}, or 
\emph{U}, the scoping rules require that the thread's local environments 
are searched before the global scope's local environment is searched. 
A variable declaration, including its initialisation, is not treated 
as a definition or use of the variable. For example, the declaration 
``int x=1'' in scope the global scope ($\mathcal{G}$) would create the 
following mappings:

\begin{equation*}
	E[x_\mathcal{G} \gets \langle pvt,~\bot \rangle]
\end{equation*}
\begin{equation*}
	D[x_\mathcal{G} \gets \{~\}]
\end{equation*}
\begin{equation*}
	U[x_\mathcal{G} \gets \{~\}]
\end{equation*}

\subsubsection{Leaving a Scope}
When a scope ends, its local environment is removed from \emph{E}, 
\emph{D}, and \emph{U}, because the declared variables within the 
scope will no longer exist. Child threads from the same \verb$par$ 
statement can be traversed in any order. This is because we are 
only interested in finding the threads that define or use the same 
variables and the order in which the defines and uses are made is 
not important. Also, variables declared in a thread are only accessible 
to its child threads, not by its siblings or parent thread. 

\subsubsection{Statements}
The statements in the program are traversed according to the ForeC 
execution semantics. The \emph{Def} and \emph{Use} functions are 
applied to each statement to find the variables that are defined and 
used. Because each statement belongs to a thread, we can record the 
variables that each thread defines and uses. The environments \emph{D} 
and \emph{U} are used to record this information.
For ordinary variable definitions (definitions not made through pointers):

\begin{enumerate}
	\item We search for the variable's nearest declaration ($var_{scope}$) 
		  in \emph{D} and add the identifier of the thread (\emph{thr}) that
		  is making the definition into the variable's set of threads. A 
		  declaration error occurs if a corresponding variable declaration 
		  cannot be found (Error: Variable declaration not found): 
		  
		  \begin{equation*}
		  	D[var_{scope} \gets D[var_{scope}] \cup \{thr\}]
		  \end{equation*}
		  
	\item We check if the variable has been defined or used by multiple 
		  threads by checking the number of threads in $D[var_{scope}] \cup U[var_{scope}]$. 
		  If the number of threads is greater than one, then the variable's type, 
		  $E[var_{scope}].type$, should be \emph{shd}. If the type is not \emph{shd}, 
		  then a declaration error occurs (Error: Private variable defined by multiple threads.)
\end{enumerate}
For variable definitions made through pointers:

\begin{enumerate}
	\item We search for the variable's nearest declaration ($var_{scope}$) 
		  in \emph{E} and retrieve the referenced variable ($rvar_{rscope}$):
		  
		  \begin{equation*}
			rvar_{rscope} = E[var_{scope}].ref
		  \end{equation*}
		  
	\item We add the defining thread (\emph{thr}) into the referenced variable's 
		  set of threads.
		  
		  \begin{equation*}
		  	D[rvar_{rscope} \gets D[rvar_{rscope}] \cup \{thr\}]
		  \end{equation*}
		  
	\item We check if the variable has been defined or used by more than one thread 
		  (see step 2 for ordinary variables).
\end{enumerate}

The same analysis is performed for variable usages, but threads are added into 
environment \emph{U}, instead of \emph{D}. If the entire program is traversed 
without raising a declaration error, then all shared variables have been declared 
properly.

\subsubsection{Optimisations}
We can simplify and optimise the implementation of shared variables by only 
implementing the necessary behaviours:
\begin{itemize}
	\item Shared variables that are not defined by parallel threads will not 
		  use the combine operator. Such variables can be found by checking 
		  the number of parallel threads in $D[var_{scope}]$. If no parallel 
		  threads are found, then the combine operator is not needed.
	\item From the execution semantics of the \verb$par$ statement, the execution 
		  of a parent and its child threads are disjoint. Child threads from 
		  sequential \verb$par$ statements also have disjoint lifetimes. Thus, 
		  threads with disjoint lifetimes will also access shared variables at 
		  disjoint times. Shared variables may be defined and used solely by 
		  threads with disjoint lifetimes. This is the case if $D[var_{scope}] \cup U[var_{scope}]$ 
		  only contains threads with disjoint lifetimes. Such variables behave 
		  like local variables. This is because the thread's copy of the shared 
		  variable is written directly to the shared memory when the global 
		  tick ends, and it is copied back in the next global tick. These kinds 
		  of shared variables can be implemented as local variables for better 
		  performance.
\end{itemize}




%------------

This means a variable is marked as being shared even if it is
accessed by multiple threads in mutually exclusive global ticks. 
That is, the accesses are never performed in the same global tick.
For example, in
\begin{lstlisting}[style=snippet]
int v=0;
void main(void) {
  par( {v=v+1; pause;} , {pause; v=v+2;} );
}
\end{lstlisting}
the accesses to \verb$v$ by both threads are guaranteed to occur in 
different global ticks.

By definition, a variable is also marked as being shared if it is 
accessed by a parent thread and its child thread, even though they
can never execute in parallel. In the following example, \verb$v$ 
is marked as a shared variable:
\begin{lstlisting}[style=snippet]
int v=0;
void main(void) {
  v=v+1;
  par( {v=v+2;} );
}
\end{lstlisting}

\subsection{Distribution}
Distribution and allocation of threads.

\subsection{Static Scheduling}
Scheduling parallel threads and preserving the ForeC execution semantics (global tick, shared variables).


\subsection{Code Generation}
