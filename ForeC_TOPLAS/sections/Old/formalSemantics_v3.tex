\section{The Formal Semantics of ForeC}
\label{sec:formalSemantics}

This section presents the formal semantics of ForeC as rewrite rules,
in the style of Structural Operation Semantics~\cite{semantics_sos}. 
The semantics is inspired by that of other synchronous programming
languages (Esterel~\cite{EsterelV7} and \pretc{}~\cite{pret_pretc} in particular).
We define the semantics on a set of primitive (kernel) ForeC instructions
(see Table~\ref{table:forec_kernel}), from which the full set of ForeC 
instructions is derived. The kernel instructions are not used for compiling, 
but for describing the formal semantics of ForeC. The kernel only 
considers a subset of the C language in order to focus on the semantics 
of parallel execution, preemption, and shared variables. This section
continues by describing assumptions on ForeC kernel programs to 
simplify the presentation of the formal semantics. The translation of 
the ForeC constructs (Table~\ref{table:forec_semantics}) to the kernel 
instructions (Table~\ref{table:forec_kernel}) is given, followed by 
the notation of the rewrite rules. Predicates are defined for returning 
statically known properties about ForeC programs and the rewrite 
rules are presented.

\begin{table}[!h]
	\centering
	\renewcommand{\arraystretch}{1.25}
	
	\begin{tabular}{l l}
		\bf{Kernel Instruction}									& \bf{Short Description}		\\ \hline
		\verb$nop$												& Empty instruction				\\
		\verb$pause$											& Barrier synchronisation		\\
		\var{}~\verb$=$~\expression{}							& Assignment					\\
		\body{}\verb$;$~\body{}									& Sequence						\\
		\verb$if$~(\expression{})~\body{}~\verb$else$~\body{}	& Conditional					\\
		\verb$while$~(\expression{})~\body{}					& Loop							\\
		\verb$par$(\thread{}:\body{},~\thread{}:\body{})		& Fork/join parallelism			\\
		\verb$resync$($p$)										& Resynchronise shared variables\\
		\verb$addAbort$($a$, \imm{}, \expression{})				& Initialise a preemption		\\
		\verb$weak$?~\verb$abort$($a$, \body{})					& Abort							\\
	\end{tabular}
	
	\caption{The ForeC kernel instructions. Here, \var{} is a variable, 
			 \expression{} and \imm{} are expressions, \body{} is an arbitrary composition of kernel 
			 instructions, $t$ is a thread identifier, $p$ is a \texttt{par} identifier, and $a$ is an 
			 abort identifier. A question mark denotes that the preceding symbol is optional.}
	\label{table:forec_kernel}
\end{table}

\subsection{Program Assumptions}
\label{sec:formalSemantics_assumptions}
We make the following assumptions about ForeC programs. 
(1) All programs follow safety-critical coding practices,
as discussed in Section~\ref{sec:forecLanguage_programming}.
For example, all expressions are side-effect free, 
dynamic memory allocation is not used, and all loops are 
bounded or always execute a \verb$pause$ in each iteration.
(2) All programs are correctly typed. For example, all 
variables accessed by multiple threads are declared 
as shared variables. 
(3) No recursive function calls or forking of threads.
Assumption 1 is to limit ourselves to a deterministic 
subset of the C language. Assumption 2 can be checked
and enforced statically. Assumption 3 prevents the unbounded 
execution of functions and threads, which can cause unbounded
memory use and execution time.

To simplify the presentation, we 
assume that the following transformations have been performed on 
ForeC kernel programs: (1) Inlining functions at their call sites, 
(2) Renaming variables uniquely and hoisting their declarations 
up to the program's global scope, and (3) Replacing pointers 
with the variables they reference. 
Thus, the semantics can ignore: (1) Function calls, (2) Variable 
declarations, scoping and shadowing, and (3) Pointers.
For example, the kernel program of 
Figure~\ref{fig:transform_forec_kernel} can be
transformed into the equivalent program of 
Figure~\ref{fig:transform_forec_refactored}.

\begin{figure}
	\centering 
	\subfloat[Original program.] {
		\begin{minipage}[b]{0.43\textwidth}
			\lstinputlisting[style=full]{./code/transform_forec_original.forec}
			\label{fig:transform_forec_original}
		\end{minipage}
	}
	\hfill
	\subfloat[Translated kernel program.] {
		\begin{minipage}[b]{0.5\textwidth}
			\lstinputlisting[style=full]{./code/transform_forec_kernel.forec}
			\label{fig:transform_forec_kernel}
		\end{minipage}
	}
	
	\subfloat[Transformed kernel program.] {
		\begin{minipage}[b]{0.6\textwidth}
			\lstinputlisting[style=full]{./code/transform_forec_refactored.forec}
			\label{fig:transform_forec_refactored}
		\end{minipage}
	}
	
	\caption{Example of translating and transforming a ForeC program into the kernel instructions.}
	\label{fig:transform_forec}
\end{figure}


%-----------------------------------------------------------------------------

\subsection{Structural Translations to Kernel Instructions}
\label{sec:formalSemantics_translations}

\begin{table}
	\centering
	\renewcommand{\arraystretch}{1.25}
	
	\begin{tabular}{| l | l |}
		\hline
		\bf{ForeC Construct}														& \bf{Translation to ForeC Kernel Instruction(s)}												\\ \hline
		\verb$input$, \verb$output$, and \verb$shared$								& Mapped to global variables.																	\\ \hline
		\verb$pause$																& \verb$pause$																					\\ \hline
		\verb$par$(\body{} (, \body{})*)											& Mapped to a nesting of \verb$par$(\thread{}:\body{}, \thread{}:\body{}) instructions			\\
																					& in sequence with a \verb$resync$($p$) instruction.											\\ \hline
		\verb$weak$?~\verb$abort$~\body{}~\verb$when immediate$?~(\expression{})	& \verb$addAbort$($a$, \imm{}, \expression{})\verb$;$ \verb$weak$?~\verb$abort$($a$, \body{})	\\ \hline
	\end{tabular}
	
	\caption{The structural translations of the ForeC constructs  
			 (Table~\ref{table:forec_semantics}) to the kernel instructions 
			 (Table~\ref{table:forec_kernel}).}
	\label{table:forec_structural_translations}
\end{table}

Table~\ref{table:forec_structural_translations} shows how 
the ForeC constructs of Table~\ref{table:forec_semantics}, 
are translated to the kernel instructions of Table~\ref{table:forec_kernel}.
For example, the ForeC program of Figure~\ref{fig:transform_forec_original} 
can be translated into the kernel program of Figure~\ref{fig:transform_forec_kernel}.
The translations for \verb$input$, \verb$output$, \verb$shared$, and 
\verb$pause$ are straightforward. Before we translate a \verb$par$,
it is assigned a unique identifier $p$ that will be used to recall 
its child threads. The \verb$par$ instruction accepts an arbitrary 
number of arguments but the \verb$par$ kernel instruction requires 
exactly two arguments. Thus, a \verb$par$ with \emph{n}-number of 
threads, \verb$par$(\body{1},~\body{2},~$\dots$,~\body{n}), is 
translated into \verb$par$(\body{1},~\verb$par$(\body{2},~$\dots$,~\body{n})). 
The translation is repeated until every \verb$par$ instruction has 
exactly two threads. Then, each thread \body{} is prefixed with a 
unique identifier \thread{} that serves as an abstract reference 
(handle) to the thread's body. Finally, a \verb$resync$ instruction 
is placed in sequence to the translated \verb$par$ instruction to 
resynchronise the shared variables modified by the terminated child 
threads. The first argument of \verb$resync$ is the identifier $p$ 
of the original \verb$par$. For example, the complete kernel translation 
of \verb$par$(\body{1},~\body{2},~\body{3}) with $p = 0$ is 
\verb$par$(\thread{1}:\body{1},~\thread{a}:\verb$par$(\thread{2}:\body{2},~\thread{3}:\body{3}))\verb$;$~\verb$resync$($0$).
%As a special case, \verb$par$(\body{1}) with $p = 1$, which has one thread, 
%is translated into \verb$resync$($1$,~\verb$par$(\thread{1}:\body{1},~\thread{2}:\{\verb$nop$;\})). 
The translation of a \verb$par$ is the only occasion when the 
\verb$resync$ kernel instruction is used.

Traditionally, the semantics of \verb$abort$ is captured using 
\emph{traps}~\cite{EsterelV7} and allows the \verb$abort$ body 
to be preempted at any time during execution. In contrast, the 
\verb$abort$ semantics in ForeC is simpler because preemptions 
can only occur at tick boundaries. Before we translate an 
\verb$abort$, it is assigned a unique identifier $a$. The 
\verb$addAbort$ kernel instruction is used to initialise the 
\verb$abort$ condition and the triggering of preemptions. Its 
arguments are: the unique identifier $a$, the value \imm{} that
indicates if the \verb$abort$ is immediate, and the \verb$abort$
condition \expression{}. The value of \imm{} is $0$ for a delayed 
\verb$abort$ and $1$ for an immediate \verb$abort$. The rest of
the \verb$abort$ instruction is translated into the \verb$abort$
kernel instruction that takes the unique identifier $a$ and 
the \verb$abort$ body~\body{}. The translation of \verb$abort$ 
is the only occasion when the \verb$addAbort$ and \verb$preempt$ 
kernel instructions are used.


%-----------------------------------------------------------------------------

\subsection{Notation}
The rewrite rules have the following form in the style of 
Structural Operational Semantics~\cite{semantics_sos}:
\begin{equation*}
	\langle State \rangle ~ \thread{}:\body{} 
		\xrightarrow[\Input]{~~k~~} 
	\langle State' \rangle ~ \thread{}:\body{}'
\end{equation*}
This notation describes a program fragment \body{} belonging to thread \thread{},
in the program state $\langle State \rangle$ and with inputs \Input{}, which
reacts and modifies the program state to $\langle State' \rangle$, emits the 
completion code $k$, and becomes the new program fragment $\body{}'$. 
All the input variables are stored in \Input{}. Recall 
from Section~\ref{sec:forecLanguage_io} that all \verb$input$ variables 
must be globally declared.

Let $\thread{} \in \Thread$ be the set of all threads in the program 
and that each thread \thread{} is associated with a unique program 
fragment \body{} (thread body), denoted as $\thread{}:\body{}$.
Thread \thread{} can be treated as an abstract reference (handler) to its 
body \body{}. Let $\langle State \rangle$ be defined as 
$\langle \Environment, \Abort \rangle$, where:
\begin{itemize}
	\item \Environment{} is an environment that maps threads $\thread{} \in \Thread$ and an identifier 
		  \Global{} (for the global scope) to a store (\Store{}) of variables (\Var{}) and their 
		  valuations (\Val{}). Let $\Id = \Thread \cup \{\Global\}$, then $\Environment: \Id \to \Store$ and 
		  $\Store: \Var \to Val$. Both \Environment{} and \Store{} are partial functions. 
		  Since all variables are globally declared (Section~\ref{sec:formalSemantics_assumptions}), 
		  all the output, shared, and ordinary C variables are stored in $\Environment[\Global]$. The copies of 
		  shared variables are stored in $\Environment[\thread{}]$ for each thread 
		  $\thread{} \in \Thread$. Section~\ref{sec:forec_shared_variables_copying} defines a 
		  copy as $\var = (\val, \mathit{mod})$, but only the modified copies need to be
		  stored. That is, if thread \thread{}'s copy of \var{} is modified 
		  ($\mathit{mod} = true$), then $\var \in \Environment[\thread{}]$. Otherwise, if it
		  is unmodified ($\mathit{mod} = false$), then $\var \notin \Environment[\thread{}]$. 
		  Note that a thread's unmodified copy would have the same value as the 
		  copy of its closest ancestor. This is discussed further in Section~\ref{sec:forec_GetVal}.
		  
	\item \Abort{} is a mapping of \verb$abort$ identifiers ($a \in \mathcal{A}$) to values 
		  (\Val{}) representing their preemption status, denoted 
		  $\Abort: \mathcal{A} \to Val$. An \verb$abort$ with a non-zero value means that its
		  preemption has been triggered.
\end{itemize}
The completion code of a transition is encoded by $k$, where:
\begin{equation*}
	k = \begin{cases}
		0		& \text{If the transition terminates.}										\\
		1		& \text{If the transition pauses, but resumes in the next global tick.}		\\
		\bot	& \text{If the transition continues.}
	\end{cases}
\end{equation*}


%-----------------------------------------------------------------------------

\subsection{Predicates}
To keep the ForeC semantics concise, we define predicates for returning 
statically known information about the program. 
\begin{itemize}
	\item $\Parent(\thread{})$:
		Returns the parent of thread \thread{}.
		If $\thread{} =$ \verb$main$, then $\top$ is returned.
	\item $\Children(p)$:
		Returns the child threads of \verb$par$ $p$.
	\item $\Shared(\store)$:
		Returns the set of all shared variables in \store{}.
	\item $\GetCombine(\var)$:
		Returns the combine function of shared variable \var{}.
	\item $\GetExp(a)$:
		Returns the condition \expression{} of \verb$abort$ $a$.
\end{itemize}
As an example, Figure~\ref{fig:forec_predicates} shows the use of predicates on
the program in Figure~\ref{fig:transform_forec_refactored}:
\begin{figure}[ht]
	\centering
	\begin{tabular}{|l l l|}
		\hline
														&															&											\\
		$\Parent($\verb$main$$) = \top$					& $\Parent($\verb$t1$$) =~$\verb$main$						& $\Parent($\verb$t2$$) =~$\verb$main$		\\
		$\Children(0) = \{$\verb$t1$$,$\verb$t2$$\}$	& $\Shared(\Environment[\Global]) = \{$\verb$s_main$$\}$	&											\\
		$\GetCombine($\verb$s_main$$) =~$\verb$plus$	& $\GetExp($\verb$0$$) =~$\verb$s_main>10$					&											\\
														&															&											\\
		\hline
	\end{tabular}
	
	\caption{Example of applying predicates to the program of Figure~\ref{fig:transform_forec_refactored}.}
	\label{fig:forec_predicates}
\end{figure}


%-----------------------------------------------------------------------------

\subsection{The Structural Operational Semantics}

\subsubsection{The nop Instruction}
The \verb$nop$ instruction does nothing, emits
the completion code of $0$, and terminates 
immediately:
\begin{equation*}	
	\tag{nop}
	\label{forec:nop}
	\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
		\xrightarrow[~~\Input~~]{0} 
	\langle \Environment, \Abort \rangle ~ \thread{}: 
\end{equation*}

\subsubsection{The pause Instruction}
The \verb$pause$ instruction does nothing and emits the 
completion code of $1$:
\begin{equation*}
	\tag{pause}
	\label{forec:pause}
	\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{pause}
		\xrightarrow[~~\Input~~]{1} 
	\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
\end{equation*}

\subsubsection{The addAbort Instruction}
The \verb$addAbort$ instruction creates a new mapping in \Abort{} 
for the \verb$abort$ identifier $a$ and its preemption status. 
For an immediate \verb$abort$ (i.e., $\imm = 1$), the immediate 
semantics is captured by initialising its preemption status to the 
value of expression \expression{} (using the semantic
function $\Eval$, described in Section~\ref{sec:forec_Eval}):
\begin{equation*}
	\tag{imm-abort}
	\label{forec:imm-abort}
	\frac{
			\imm = 1
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{addAbort}(a, \imm, \expression)
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \cup \{a \to \Eval(\Environment, \Input, \thread{}, \expression)\} \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}
Otherwise, the delayed semantics is captured by initialising the 
preemption status to $0$:
\begin{equation*}
	\tag{del-abort}
	\label{forec:del-abort}
	\frac{
			\imm \neq 1
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{addAbort}(a, \imm, \expression)
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \cup \{a \to 0\} \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}

\subsubsection{The abort Instruction}
The \verb$abort$ instruction terminates if its body \body{} terminates:
\begin{equation*}
	\tag{abort-1}
	\label{forec:abort-1}
	\frac{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{}
				\xrightarrow[~~\Input~~]{0} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{}'
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{weak}?~\mathtt{abort}(a, \body{})
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}
The \verb$abort$'s body is allowed to execute if its preemption 
has not been triggered (i.e., $\Abort[a] = 0$):
\begin{equation*}
	\tag{abort-2}
	\label{forec:abort-2}
	\frac{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{}
				\xrightarrow[~~\Input~~]{k \in \lbrace 1, \bot \rbrace} 
			\langle \Environment', \Abort' \rangle ~ \thread{}:\body{}'
			\quad
			\Abort[a] = 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{weak}?~\mathtt{abort}(a, \body{})
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment', \Abort' \rangle ~ \thread{}:\mathtt{weak}?~\mathtt{abort}(a, \body{}')
		}
\end{equation*}
A strong \verb$abort$ terminates if its preemption has been triggered (i.e., $\Abort[a] \neq 0$):
\begin{equation*}
	\tag{abort-3}
	\label{forec:abort-3}
	\frac{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{}
				\xrightarrow[~~\Input~~]{k \in \lbrace 1, \bot \rbrace} 
			\langle \Environment', \Abort' \rangle ~ \thread{}:\body{}'
			\quad
			\Abort[a] \neq 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{abort}(a, \body{})
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}
A weak \verb$abort$ terminates if its preemption has been triggered and its body pauses:
\begin{equation*}
	\tag{abort-4}
	\label{forec:abort-4}
	\frac{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment', \Abort' \rangle ~ \thread{}:\body{}'
			\quad
			\Abort[a] \neq 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{weak}~\mathtt{abort}(a, \body{})
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment', \Abort' \rangle ~ \thread{}:\mathtt{weak}~\mathtt{abort}(a, \body{}')
		}
\end{equation*}

\begin{equation*}
	\tag{abort-5}
	\label{forec:abort-5}
	\frac{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{}
				\xrightarrow[~~\Input~~]{1} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{}'
			\quad
			\Abort[a] \neq 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{weak}~\mathtt{abort}(a, \body{})
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}

\subsubsection{The Assignment Instruction}
The assignment instruction evaluates the expression
\expression{} into a value.
If \var{} is a shared variable (\ref{forec:assign-shared}), then the value is 
assigned to the thread's store, $\Environment[\thread{}]$. 
Otherwise, if the variable \var{} is a private variable (\ref{forec:assign-private}), then the value 
is assigned to the actual variable in $\Environment[\Global]$:
\begin{equation*}
	\tag{assign-shared}
	\label{forec:assign-shared}
	\frac{
			\var \in \Shared(\Environment[\Global])
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\var \mathtt{=} \expression
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment[\thread{}] \cup \{\var \to \Eval(\Environment, \Input, \thread{}, \expression)\}, \Abort \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}

\begin{equation*}
	\tag{assign-private}
	\label{forec:assign-private}
	\frac{
			\var \notin \Shared(\Environment[\Global])
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\var \mathtt{=} \expression
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment[\Global][\var \gets \Eval(\Environment, \Input, \thread, \expression)], \Abort \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}

\subsubsection{The if-else Instruction}
A conditional instruction is rewritten into one of its branches, depending on 
the value of its condition \expression{}:
\begin{equation*}
	\tag{if-then}
	\label{forec:if-then}
	\frac{
			\Eval(\Environment, \Input, \thread{}, \expression) \neq 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{if}~(\expression)~\body{1}~\mathtt{else}~\body{2}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}
		}
\end{equation*}

\begin{equation*}
	\tag{if-else}
	\label{forec:if-else}
	\frac{
			\Eval(\Environment, \Input, \thread{}, \expression) = 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{if}~(\expression)~\body{1}~\mathtt{else}~\body{2}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{2}
		}
\end{equation*}

\subsubsection{The while Instruction}
The body of a loop instruction is unrolled once, depending 
on the value of its condition \expression{}:
\begin{equation*}
	\tag{loop-then}
	\label{forec:loop-then}
	\frac{
			\Eval(\Environment, \Input, \thread{}, \expression) \neq 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{while}~(\expression)~\body{}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{};~\mathtt{while}~(\expression)~\body{}
		}
\end{equation*}

\begin{equation*}
	\tag{loop-else}
	\label{forec:loop-else}
	\frac{
			\Eval(\Environment, \Input, \thread{}, \expression) = 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{while}~(\expression)~\body{}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}

\subsubsection{The Sequence Instruction}
For a sequence of program fragments, the first fragment \body{1}
must terminate before the second fragment \body{2} can be rewritten. 
The (\ref{forec:seq-left}) rule emits the completion code of 
the first fragment:
\begin{equation*}
	\tag{seq-left}
	\label{forec:seq-left}
	\frac{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}
				\xrightarrow[~~\Input~~]{k \neq 0} 
			\langle \Environment', \Abort' \rangle ~ \thread{}:\body{1}'
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}\mathtt{;}~\body{2}
				\xrightarrow[~~\Input~~]{k} 
			\langle \Environment', \Abort' \rangle ~ \thread{}:\body{1}'\mathtt{;}~\body{2}
		}
\end{equation*}
The (\ref{forec:seq-right}) rule is applied if the 
first fragment terminates:
\begin{equation*}
	\tag{seq-right}
	\label{forec:seq-right}
	\frac{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}
				\xrightarrow[~~\Input~~]{0} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}'
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}\mathtt{;}~\body{2}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{2}
		}
\end{equation*}

\subsubsection{The par Instruction}
The \verb$par$ instruction allows both its child threads, $\thread{1}$
and $\thread{2}$, to execute in parallel. The parent thread is $\thread{0}$:
\begin{equation*}
	\tag{par-1}
	\label{forec:par-1}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment', \Abort' \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment'', \Abort'' \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Merge(\Environment, \Environment', \Environment''), \Abort' \cup \Abort'' \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}')
	}
\end{equation*}
The modified variables in $\Environment'$ and 
$\Environment''$ are merged into the same environment using the semantic 
function $\Merge$ (Section~\ref{sec:forec_Merge}). 
If a thread completes its local tick, by pausing or 
terminating, then it will wait for its sibling to 
complete its local tick:
\begin{equation*}
	\tag{par-2}
	\label{forec:par-2}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{k \in \lbrace 0, 1 \rbrace} 
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment', \Abort' \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment', \Abort' \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2}')
	}
\end{equation*}

\begin{equation*}
	\tag{par-3}
	\label{forec:par-3}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment', \Abort' \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{k \in \lbrace 0, 1 \rbrace} 
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment', \Abort' \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2})
	}
\end{equation*}
The \verb$par$ pauses or terminates if both its threads pause or
terminate, respectively: 
\begin{equation*}
	\tag{par-4}
	\label{forec:par-4}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}')
	}
\end{equation*}

\begin{equation*}
	\tag{par-5}
	\label{forec:par-5}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{0} 
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{0} 
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{0} 
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{nop}
	}
\end{equation*}
If only one thread terminates, then the \verb$par$ 
is rewritten into its remaining thread:
\begin{equation*}
	\tag{par-6}
	\label{forec:par-6}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{0} 
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment', \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}'
	}
\end{equation*}

\begin{equation*}
	\tag{par-7}
	\label{forec:par-7}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{0} 
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}'
	}
\end{equation*}

\subsubsection{The resync Instruction}
The \verb$resync$ instruction resynchronises the shared variables modified by 
\verb$par$ $p$'s child threads using the semantic function $\Resync$ 
(Section~\ref{sec:forec_Resync}). The resynchronised values are assigned to 
the parent thread \thread{}:
\begin{equation*}
	\tag{resync}
	\label{forec:resync}
	\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{resync}(p)
		\xrightarrow[~~\Input~~]{\bot} 
	\langle \Resync(\Environment, \Children(p), \thread{}), \Abort \rangle ~ \thread{}:\mathtt{nop}
\end{equation*}

\subsubsection{Global Tick}
A global tick occurs if the entire \verb$main$ thread pauses or
terminates. All the modified shared variables are resynchronised 
and assigned to the actual shared variables. The preemption statuses 
are updated using the semantic function $\Preemptions$ 
(Section~\ref{sec:forec_Preemptions}):
\begin{equation*}
	\tag{global-tick}
	\label{forec:global-tick}
	\frac{
			\langle \Environment, \Abort \rangle ~ main:\body{}
				\xrightarrow[~~\Input~~]{k \in \lbrace 0, 1 \rbrace} 
			\langle \Environment', \Abort \rangle ~ main:\body{}'
		}{
			\langle \Environment, \Abort \rangle ~ main:\body{}
				\xrightarrow[~~\Input~~]{k} 
			\langle \Environment'' = \Resync(\Environment', \Thread, \Global), \Preemptions(\Environment'', \Input, \Abort) \rangle ~ main:\body{}'
		}
\end{equation*}
When the transition completes, the outputs are emitted and 
the inputs are sampled.


%-----------------------------------------------------------------------------

\subsection{Semantic Functions}
This section describes the various semantic functions 
used by the rewrite rules.

\subsubsection{\textsc{Eval}}
\label{sec:forec_Eval}
The semantic function $\Eval(\Environment, \Input, \thread{}, \expression)$ 
follows the evaluation rules of the C-language to 
evaluate the expression \expression{} and returns 
the result. During the evaluation, the value of a 
variable is retrieved by the semantic function $\GetVal$ 
(described in Section~\ref{sec:forec_GetVal}).

\subsubsection{\textsc{GetVal}}
\label{sec:forec_GetVal}
When evaluating an expression, the semantic function
$\GetVal(\Environment, \Input, \thread{}, \var)$ is used 
to retrieve the value of a variable. 
This function is described by Algorithm~\ref{algo:GetVal}. 
The inputs to the algorithm are: the program's environment 
\Environment{}, the inputs \Input{}, the thread \thread{} that the expression 
belongs to, and the variable \var{} that we want the value 
of. The output is a value \val{}. If \var{} is an input, 
then its value is returned. Otherwise, if \var{} is in thread 
\thread{}'s store, then its value is returned 
(line~\ref{algo:GetVal_local}). Otherwise, we find the closest ancestor of
thread \thread{} that has a copy of \var{} by using the
semantic function $\GetAncestorWithCopy$ 
(described in Section~\ref{sec:forec_GetAncestorWithCopy}). 
If such an ancestor exists ($\thread{a} \neq \top$), then
the value from the ancestor's store is returned (line~\ref{algo:GetVal_parent}). 
Otherwise, the value of the actual \var{} is returned
(line~\ref{algo:GetVal_global}).

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\GetVal$}{\Environment{}, \Input{}, \thread{}, \var{}}
			\If {$\var \in \Input$}
				\State \Return $\Input[\var]$											\Comment{Return the input's value for \var{}.}\label{algo:GetVal_input}
			\Else
				\If {$\var \in \Environment[\thread{}]$}	
					\State \Return $\Environment[\thread{}][\var]$							\Comment{Return the thread's value for \var{}.}\label{algo:GetVal_local}
				\Else
					\State $\thread{a} = \GetAncestorWithCopy(\Environment, \thread{}, \var)$\Comment{Get the ancestor with a copy of \var{}.}
					\If {$\thread{a} \neq \top$}
						\State \Return $\Environment[\thread{a}][\var]$						\Comment{Return the ancestor's value for \var{}.}\label{algo:GetVal_parent}
					\Else
						\State \Return $\Environment[\Global][\var]$						\Comment{Return the value of the actual \var{}.}\label{algo:GetVal_global}
					\EndIf
				\EndIf
			\EndIf
		\EndFunction
	\end{algorithmic}
	
	\caption{Gets the value of a given variable.}
	\label{algo:GetVal}
\end{algorithm}

\subsubsection{\textsc{GetAncestor}}
\label{sec:forec_GetAncestorWithCopy}
The semantic function $\GetAncestorWithCopy(\Environment, \thread{}, \var)$ 
finds thread \thread{}'s closest ancestor that has a copy 
of variable \var{} in its store. This function is described 
by Algorithm~\ref{algo:GetAncestorWithCopy}. The inputs
to the algorithm are: the program's environment 
\Environment{}, the thread \thread{} to start searching 
from, and the variable \var{} to find. The output is a
thread. The first ancestor we search through is thread 
\thread{}'s parent. The parent is returned if it has a 
copy of \var{} (lines~\ref{algo:GetAncestorWithCopy_found_start}-\ref{algo:GetAncestorWithCopy_found_end}). 
Otherwise, the search continues 
up the thread's ancestry until a copy is found. On
line~\ref{algo:GetAncestorWithCopy_top1}, recall that 
$\Parent(\thread{a})$ returns $\top$ when $\thread{a}$ is 
the program's \verb$main$ thread. If no ancestor is found, 
then $\top$ is returned (line~\ref{algo:GetAncestorWithCopy_top2}).

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\GetAncestorWithCopy$}{\Environment{}, \thread{}, \var{}}
			\State $\thread{a} = \Parent(\thread{})$		\Comment{Get the parent.}
			\While {$\thread{a} \neq \top$}					\Comment{While an ancestor exists.}
				\If {$\var \in \Environment[\thread{a}]$}	\label{algo:GetAncestorWithCopy_found_start}
					\State \Return $\thread{a}$				\Comment{A copy of \var{} is in this ancestor's store.}
				\EndIf										\label{algo:GetAncestorWithCopy_found_end}
				\State $\thread{a} = \Parent(\thread{a})$	\Comment{Continue searching up the ancestry.}\label{algo:GetAncestorWithCopy_top1}
			\EndWhile
			\State \Return $\top$							\Comment{No ancestor found.}\label{algo:GetAncestorWithCopy_top2}
		\EndFunction
	\end{algorithmic}
	
	\caption{Gets the ancestor that has a copy of a given variable.}
	\label{algo:GetAncestorWithCopy}
\end{algorithm}

\subsubsection{\textsc{Merge}}
\label{sec:forec_Merge}
The semantic function $\Merge(\Environment, \Environment', \Environment'')$
merges the modified private variables and copies of shared variables in 
$\Environment'$ and $\Environment''$ into the same program environment. 
The (\ref{forec:resync}) rule removes threads from 
the environment after their stores are resynchronised by the semantic 
function $\Resync$ (Section~\ref{sec:forec_Resync}). Thus, the merged 
environment should not contain the removed threads. The $\Merge$ function is 
described by Algorithm~\ref{algo:Merge} and its inputs 
are: the original program environment \Environment{}, and the 
program environments $\Environment'$ and $\Environment''$ modified 
by two parallel threads. The output is an updated environment 
$\Environment'''$. The algorithm begins by finding the set of threads 
$\Thread_r$ that have been removed from either $\Environment'$ or 
$\Environment''$ (line~\ref{algo:Merge_remove1}). These threads are 
subsequently removed from both $\Environment'$ and $\Environment''$ 
(line~\ref{algo:Merge_remove2}). Line~\ref{algo:Merge_merge} performs 
the merge. We observe that any two parallel threads will always
modify the same environment $\Environment$ in a mutually exclusive
manner. This is because the (\ref{forec:assign-shared}) rule only 
allows a thread to modify its own copies of shared variables and the 
(\ref{forec:assign-private}) rule only allows a thread to modify its 
own private variables. Thus, we only need to save the (modified) 
values in $\Environment'$ and $\Environment''$ that differ from 
the original values in \Environment{}. The first term,
$\Environment' \setminus (\Environment' \cap \Environment)$, removes 
variables from $\Environment'$ that have not been modified. Note that
$(\Environment' \cap \Environment)$ returns an environment 
containing only the variables that have the same value in $\Environment'$ 
and $\Environment$. Similarly, the second term, 
$\Environment'' \setminus (\Environment'' \cap \Environment)$, removes 
variables from $\Environment''$ that have not been modified. The third
term, $\Environment \cap \Environment' \cap \Environment''$, returns 
the variables that have not been modified. The union of the three 
terms becomes the merged environment $\Environment'''$.

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\Merge$}{\Environment{}, $\Environment'$, $\Environment''$}
			\State $\Thread_r = \lbrace \thread{} \mid \forall \thread{} \in \Environment, \thread{} \notin \Environment' \vee \thread{} \notin \Environment'' \rbrace$	\Comment{Find the removed threads.}\label{algo:Merge_remove1}
			\State $\Environment' = \Environment' \setminus \Thread_r$, $\Environment'' = \Environment'' \setminus \Thread_r$						\Comment{Remove the threads.}\label{algo:Merge_remove2}
			\State \Return $\Environment''' = \left ( \Environment' \setminus (\Environment' \cap \Environment) \right ) \cup \left ( \Environment'' \setminus (\Environment'' \cap \Environment) \right ) \cup \left ( \Environment \cap \Environment' \cap \Environment'' \right )$	\Comment{Merge}\label{algo:Merge_merge}
		\EndFunction
	\end{algorithmic}
	
	\caption{Merges the modified values of two environments into one environment.}
	\label{algo:Merge}
\end{algorithm}

\subsubsection{\textsc{Resync}}
\label{sec:forec_Resync}
The semantic function $\Resync(\Environment, \Thread, \id)$ resynchronises 
the copies of shared variables belonging to a set of threads \Thread{}. This 
function is described by Algorithm~\ref{algo:Resync}. The inputs to the 
algorithm are: the program's environment \Environment{}, the set of threads 
\Thread{} to combine, and the identifier \id{} of the store to assign the 
resynchronised values into. The output is an updated environment $\Environment{}$.
The algorithm resynchronises the shared variables one at a time (line~\ref{algo:Resync_for}).
Line~\ref{algo:Resync_c} retrieves the shared variable's 
combine function. Line~\ref{algo:Resync_find} creates a list containing all the modified copies 
of the shared variable. If there is at least one modified copy, 
then the combined value is assigned to the given \id{}'s store in \Environment{} 
(line~\ref{algo:Resync_assign}). 
Finally, \Environment{} is returned without the threads' copies of shared variables 
(line~\ref{algo:Resync_return}).

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\Resync$}{\Environment{}, \Thread{}, \id{}}
			\ForAll {$\var \in \Shared(\Environment[\Global])$}										\Comment{For all shared variables.}\label{algo:Resync_for}
				\State $cf = \GetCombine(\var)$														\Comment{Combine function for \var{}.}\label{algo:Resync_c}
				\State $Copies = ( \Environment[\thread{}][\var] \mid \forall \thread{} \in \Thread, \var \in \Environment[\thread{}] )$	\Comment{List of modified copies.}\label{algo:Resync_find}
				\If {$\lvert Copies \rvert > 0$}
					\State $\Environment[\id][\var \gets cf(\Environment[\Global][\var], Copies)]$	\Comment{Assign the combined result to \id{}'s store.}\label{algo:Resync_assign}
				\EndIf
			\EndFor
			\State \Return $\Environment \setminus \Thread$											\Comment{Return \Environment{} without the threads' copies.}\label{algo:Resync_return}
		\EndFunction
	\end{algorithmic}
	
	\caption{Resynchronises the modified copies of shared variables in a given set of threads.}
	\label{algo:Resync}
\end{algorithm}

\subsubsection{\textsc{Preemptions}}
\label{sec:forec_Preemptions}
The semantic function $\Preemptions(\Environment, \Input, \Abort)$
updates the preemption statuses of all the \verb$abort$s. This function
is described by Algorithm~\ref{algo:Preemptions}. The inputs 
to the algorithm are: the program's environment \Environment{}, 
the inputs \Input{}, and the set of \verb$abort$ identifiers \Abort{}. The output is 
\Abort{} with updated preemption statuses. For each \verb$abort$, 
line~\ref{algo:Preemptions_update} evaluates its expression 
using the actual variables. The result 
is assigned to the \verb$abort$ identifier as its new preemption 
status.

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\Preemptions$}{\Environment{}, \Input{}, \Abort{}}
			\ForAll {$\abort \in \Abort$}
				\State $\Abort[\abort \gets \Eval(\Environment, \Input, \Global, \GetExp(a))]$	\label{algo:Preemptions_update}
			\EndFor
			\State \Return \Abort
		\EndFunction
	\end{algorithmic}
	
	\caption{Updates the preemption status of all abort identifiers.}
	\label{algo:Preemptions}
\end{algorithm}


%-----------------------------------------------------------------------------

%\subsection{Comparison with Concurrent Revisions}
%SPC-MoC subsumes the idea of Concurrent Revisions while offering extra flexibility.
%Similarities with Concurrent Revisions:
%\begin{itemize}
%	\item Assignment to variables: Classic data instructions.
%	\item Classic control instructions: Conditional instructions.
%	\item Forking and joining of threads: Concurrent Revisions is more expressive
%		  (Synchronous versus Asynchronous, Static versus Dynamic).
%\end{itemize}
%Dissimilarities with Concurrent Revisions:
%\begin{itemize}
%	\item Blocking semantics of fork and join.
%	\item Combining of revisions is only based on value.
%	\item Preemptions.
%	\item Synchronisation during thread executions (the butterfly communication pattern not 
%		  supported by Concurrent Revisions).
%\end{itemize}
%
%Creating equivalent Concurrent Revision programs in ForeC (ForeC is a superset of 
%Concurrent Revisions?):
%\begin{itemize}
%	\item Only use data, control, and fork/join instructions.
%	\item How to extend the proofs of determinacy to preemptions and global ticks?
%	\begin{itemize}
%		\item Preemptions: Preemption of executions are defined precisely by the control-flow.
%			  It is never the case that you can choose between taking a preemption and performing
%			  another action (deterministic execution semantics).
%		\item Global ticks: All threads have paused and cannot continue executing. Therefore, 
%			  all copies of a shared variable can be safely combined.
%	\end{itemize}
%\end{itemize}