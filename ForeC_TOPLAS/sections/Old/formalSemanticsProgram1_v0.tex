\subsection{Examples of Execution}
This section provides examples of how ForeC programs
execute with the rewrite rules. A possible execution 
for each example program is given as a sequence of 
rewrites. 
%Each rewrite is accompanied by a skeleton of the proof tree. 

\subsubsection{Program 1}
\begin{lstlisting}[style=snippet]
int plus(int a, int b) {return a + b;}
int x=0; shared:plus int y=0;
void main(void) {
  x=1; y=2;
  par( t0:{y=y+1; pause;} , 
       t1:{y=y+2; pause;} );
}
\end{lstlisting}
The initial program state, $\langle State \rangle$,
and its derivatives are defined in Table~\ref{table:forec_program_1}.
\newline

\begin{table}[t]
	\centering
	\renewcommand{\arraystretch}{1.25}
	
	\begin{tabular}{| l | c | c | c | c | c |}
		\hline
		\textbf{State}						& \textbf{\textit{A}}			& \textbf{\textit{I}} 		& \textbf{\textit{P}} 	& \textbf{\textit{C}} 	& \textbf{\textit{E}}													\\ \hline
		$\langle State \rangle$				& $\lbrace main \rbrace$		& $\lbrace ~ \rbrace$		& $\lbrace ~ \rbrace$	& $\lbrace ~ \rbrace$	& $\lbrace \Global \to \lbrace x \to 0, y \to 0 \rbrace \rbrace$		\\ \cline{1-1} \cline{6-6}
		$\langle State^1 \rangle$			&								&							&						&						& $\lbrace \Global \to \lbrace x \to 1, y \to 0 \rbrace \rbrace$		\\ \cline{1-1} \cline{6-6}
		$\langle State^2 \rangle$			&								&							&						&						& $\begin{Bmatrix} \begin{array}{r l} 
																																								\Global &\to \lbrace x \to 1, y \to 0 \rbrace,	\\ 
																																								main &\to \lbrace y \to 2 \rbrace 
																																							\end{array} \end{Bmatrix}$											\\ \cline{1-3} \cline{6-6}
		$\langle State^3 \rangle$			& $\lbrace t0, t1 \rbrace$		& $\lbrace main \rbrace$	&						&						& $\begin{Bmatrix} \begin{array}{r l} 
																																								\Global &\to \lbrace x \to 1, y \to 0 \rbrace,	\\ 
																																								main &\to \lbrace y \to 2 \rbrace 
																																							\end{array} \end{Bmatrix}$											\\ \cline{1-1} \cline{6-6}
		$\langle State^4 \rangle$			& 								& 							&						&						& $\begin{Bmatrix} \begin{array}{r l} 
																																								\Global &\to \lbrace x \to 1, y \to 0 \rbrace,	\\ 
																																								main &\to \lbrace y \to 2 \rbrace 				\\
																																								t0 &\to \lbrace y \to 3 \rbrace
																																							\end{array} \end{Bmatrix}$											\\ \cline{1-2} \cline{4-4}
		$\langle State^5 \rangle$			& $\lbrace t1 \rbrace$			& 							& $\lbrace t0 \rbrace$	&						& 																		\\ \cline{1-1} \cline{6-6}
		$\langle State^6 \rangle$			& 								& 							&						&						& $\begin{Bmatrix} \begin{array}{r l} 
																																								\Global &\to \lbrace x \to 1, y \to 0 \rbrace,	\\ 
																																								main &\to \lbrace y \to 2 \rbrace 				\\
																																								t0 &\to \lbrace y \to 3 \rbrace					\\
																																								t1 &\to \lbrace y \to 4 \rbrace
																																							\end{array} \end{Bmatrix}$											\\ \cline{1-2} \cline{4-4} \cline{6-6}
		$\langle State^7 \rangle$			& $\lbrace t0,t1 \rbrace$		& 							& $\lbrace ~ \rbrace$	&						& $\lbrace \Global \to \lbrace x \to 1, y \to 7 \rbrace \rbrace$		\\ \cline{1-2}
		$\langle State^8 \rangle$			& $\lbrace t1 \rbrace$			& 							&						&						& 																		\\ \cline{1-3} 
		$\langle State^9 \rangle$			& $\lbrace main \rbrace$		& $\lbrace ~ \rbrace$		&						&						& 																		\\ \cline{1-2}
		$\langle State^{10} \rangle$		& $\lbrace ~ \rbrace$			&							&						&						& 																		\\ \hline
	\end{tabular}
	
	\caption{Definition of the initial program state and its derivatives for Program 1.}
	\label{table:forec_program_1}
\end{table}

\noindent
Step 1: Apply the (\ref{forec:seq-right}) and (\ref{forec:assign-private}) rules on
thread \verb$main$.
\begin{equation*}
	\frac{
			\langle State \rangle ~ \text{main: x=1}
				\xrightarrow[~~\Input~~]{0} 
			\langle State^1 \rangle ~ \text{main: nop}
		}{
			\begin{array}{l}
				\langle State \rangle ~ \text{main: x=1; y=2;}	\\
				\text{par( t0:\{y=y+1; pause;\} ,}	 			\\
				\text{~~~~~~t1:\{y=y+2; pause;\} );}
			\end{array}
				\xrightarrow[~~\Input~~]{\bot} 
			\begin{array}{l}
				\langle State^1 \rangle ~ \text{main: y=2;}		\\
				\text{par( t0:\{y=y+1; pause;\} ,}		 		\\
				\text{~~~~~~t1:\{y=y+2; pause;\} );}	
			\end{array}
		}
\end{equation*}

\noindent
Step 2: Apply the (\ref{forec:seq-right}) and (\ref{forec:assign-shared}) rules 
on thread \verb$main$.
\begin{equation*}
	\frac{
			\langle State^1 \rangle ~ \text{main: y=2}
				\xrightarrow[~~\Input~~]{0} 
			\langle State^2 \rangle ~ \text{main: nop}
		}{
			\begin{array}{l}
				\langle State^1 \rangle ~ \text{main: y=2;}	\\
				\text{par( t0:\{y=y+1; pause;\} ,}	 		\\
				\text{~~~~~~t1:\{y=y+2; pause;\} );}	
			\end{array}
				\xrightarrow[~~\Input~~]{\bot} 
			\begin{array}{l}
				\langle State^2 \rangle ~ \text{main:}		\\
				\text{par( t0:\{y=y+1; pause;\} ,}	 		\\
				\text{~~~~~~t1:\{y=y+2; pause;\} );}	
			\end{array}
		}
\end{equation*}

\noindent
Step 3: Apply the (\ref{forec:par}) rule on thread \verb$main$.
Threads \verb$t0$ and \verb$t1$ are forked.
\begin{equation*}
	\begin{array}{l}
		\langle State^2 \rangle ~ \text{main: par( t0:\{y=y+1; pause;\} ,}	 \\
		\text{~~~~~~~~~~~~~~~~~~~~~~~~~~~t1:\{y=y+2; pause;\} );}
	\end{array}
		\xrightarrow[~~\Input~~]{\bot} 
	\langle State^3 \rangle ~ \text{main: nop}
\end{equation*}

\noindent
Step 4: Apply the (\ref{forec:seq-right}) and (\ref{forec:assign-shared}) rules
on thread \verb$t0$.
\begin{equation*}
	\frac{
			\langle State^3 \rangle ~ \text{t0: y=y+1}
				\xrightarrow[~~\Input~~]{0} 
			\langle State^4 \rangle ~ \text{t0: nop}
		}{
			\langle State^3 \rangle ~ \text{t0: y=y+1; pause;}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle State^4 \rangle ~ \text{t0: pause;}
		}
\end{equation*}

\noindent
Step 5: Apply the (\ref{forec:pause}) rule on thread \verb$t0$.
\begin{equation*}
	\langle State^4 \rangle ~ \text{t0: pause;}
		\xrightarrow[~~\Input~~]{~~1~~} 
	\langle State^4 \rangle ~ \text{t0: nop;}
\end{equation*}

\noindent
Step 6: Apply the (\ref{forec:local-tick}) rule on thread
\verb$t0$. This completes \verb$t0$'s local tick. 
\begin{equation*}
	\frac{
			\text{t0} \xrightarrow{~~1~~} \text{t0}
		}{
			\langle State^4 \rangle \xrightarrow{~~~~~} \langle State^5 \rangle
		}
\end{equation*}

\noindent
Step 7: Apply the (\ref{forec:seq-right}) and (\ref{forec:assign-shared}) rules
on thread \verb$t1$.
\begin{equation*}
	\frac{
			\langle State^5 \rangle ~ \text{t1: y=y+2}
				\xrightarrow[~~\Input~~]{0} 
			\langle State^6 \rangle ~ \text{t1: nop}
		}{
			\langle State^5 \rangle ~ \text{t1: y=y+2; pause;}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle State^6 \rangle ~ \text{t1: pause;}
		}
\end{equation*}

\noindent
Step 8: Apply the (\ref{forec:pause}) rule on thread \verb$t1$.
\begin{equation*}
	\langle State^6 \rangle ~ \text{t1: pause;}
		\xrightarrow[~~\Input~~]{~~1~~} 
	\langle State^6 \rangle ~ \text{t1: nop;}
\end{equation*}

\noindent
Step 9: Apply the (\ref{forec:global-tick}) rule on thread
\verb$t1$. This completes \verb$t1$'s local tick and a 
global tick occurs. Note that the rewrites of threads \verb$t0$ and 
\verb$t1$ could have been interleaved.
\begin{equation*}
	\frac{
			\text{t1} \xrightarrow{~~1~~} \text{t1}
		}{
			\langle State^6 \rangle \xrightarrow{~~~~~} \langle State^7 \rangle
		}
\end{equation*}

\noindent
Step 10: Apply the (\ref{forec:nop}) rule on thread \verb$t0$.
\begin{equation*}
	\langle State^7 \rangle ~ \text{t0: nop;}
		\xrightarrow[~~\Input~~]{~~0~~} 
	\langle State^7 \rangle ~ \text{t0:}
\end{equation*}

\noindent
Step 11: Apply the (\ref{forec:term1}) rule on thread \verb$t0$. 
This terminates \verb$t0$.
\begin{equation*}
	\frac{
			\text{t0} \xrightarrow{~~0~~} \text{t0}
		}{
			\langle State^7 \rangle \xrightarrow{~~~~~} \langle State^8 \rangle
		}
\end{equation*}

\noindent
Step 12: Apply the (\ref{forec:nop}) rule on thread \verb$t1$.
\begin{equation*}
	\langle State^8 \rangle ~ \text{t1: nop;}
		\xrightarrow[~~\Input~~]{~~0~~} 
	\langle State^8 \rangle ~ \text{t1:}
\end{equation*}

\noindent
Step 13: Apply the (\ref{forec:term2}) rule on thread \verb$t1$.
This terminates \verb$t1$ and a join occurs.
\begin{equation*}
	\frac{
			\text{t1} \xrightarrow{~~0~~} \text{t1}
		}{
			\langle State^8 \rangle \xrightarrow{~~~~~} \langle State^9 \rangle
		}
\end{equation*}

\noindent
Step 14: Apply the (\ref{forec:nop}) rule on thread \verb$main$.
\begin{equation*}
	\langle State^9 \rangle ~ \text{main: nop;}
		\xrightarrow[~~\Input~~]{~~0~~} 
	\langle State^9 \rangle ~ \text{main: }
\end{equation*}

\noindent
Step 15: Apply the (\ref{forec:term3}) rule on thread \verb$main$.
The program terminates.
\begin{equation*}
	\frac{
			\text{main} \xrightarrow{~~0~~} \text{main}
		}{
			\langle State^9 \rangle \xrightarrow{~~~~~} \langle State^{10} \rangle
		}
\end{equation*}
