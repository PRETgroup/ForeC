\section{The Formal Semantics of ForeC}
\label{sec:formalSemantics}

This section presents the formal semantics of ForeC as rewrite rules,
in the style of Structural Operation Semantics~\cite{semantics_sos}. 
The semantics is inspired by that of other synchronous programming
languages (Esterel~\cite{EsterelV7} and \pretc{}~\cite{pret_pretc} in particular).
We define the semantics on a set of primitive (kernel) ForeC instructions
(see Table~\ref{table:forec_kernel}), from which the full set of ForeC 
instructions is derived. The kernel instructions are not used for compiling, 
but for describing the formal semantics of ForeC. The kernel only 
considers a subset of the C language in order to focus on the semantics 
of parallel execution, preemption, and shared variables. This section
continues by describing assumptions on ForeC kernel programs to 
simplify the presentation of the formal semantics. The translation of 
the ForeC instructions (Table~\ref{table:forec_semantics}) to the kernel 
instructions (Table~\ref{table:forec_kernel}) is given, followed by 
the notation of the rewrite rules. Predicates are defined for returning 
statically known properties about ForeC programs and the rewrite 
rules are presented.

\begin{table}[!h]
	\centering
	\renewcommand{\arraystretch}{1.25}
	
	\begin{tabular}{l l}
		\bf{Kernel Instruction}									& \bf{Short Description}	\\ \hline
		\verb$nop$												& Empty instruction			\\
		\verb$pause$											& Barrier synchronisation	\\
		\var{}~\verb$=$~\expression{}							& Assignment				\\
		\body{1}\verb$;$~\body{2}								& Sequence					\\
		\verb$if$~(\expression{})~\body{1}~\verb$else$~\body{2}	& Conditional				\\
		\verb$while$~(\expression{})~\body{}					& Loop						\\
		\verb$par$(\thread{1}:\body{1},~\thread{2}:\body{2})	& Fork/join parallelism		\\
		\verb$resync$($p$, \body{})								& Resynchronise variables	\\
		\verb$addAbort$($a$, \imm{}, \expression{})				& Initialise a preemption	\\
		\verb$preempt$($a$?)									& Take a preemption			\\
	\end{tabular}
	
	\caption{The ForeC kernel instructions. Here, \var{} is a variable, 
			 \expression{} and \imm{} are expressions, \body{} is an arbitrary composition of kernel 
			 instructions, $t$ is a thread identifier, $p$ is a \texttt{par} identifier, and $a$ is an 
			 abort identifier. A question mark denotes that the preceding symbol is optional.}
	\label{table:forec_kernel}
\end{table}

\subsection{Program Assumptions}
We make the following assumptions about ForeC programs. 
(A1) All programs follow safety-critical coding practices,
as discussed in Section~\ref{sec:foreLanguage_programming}.
For example, all expressions are side-effect free, 
all memory allocations are static, and all loops are 
bounded or always execute a \verb$pause$ in each iteration.
(A2) All programs are correctly typed. For example, all 
variables accessed by multiple threads are declared 
as shared variables. 
(A3) No recursive function calls or forking of threads.
Assumption A1 is to limit ourselves to a deterministic 
subset of the C language. Assumption A2 can be checked
and enforced statically. Assumption A3 prevents the unbounded 
execution of functions and threads, which can cause unbounded
memory use and execution time.

To simplify the presentation, we 
assume that the following transformations have been performed on 
ForeC kernel programs: (1) Inlining of functions at their call sites, 
(2) Renaming variables uniquely and hoisting their declarations 
up to the program's global scope, and (3) Replacing pointers 
with the actual variables they reference. 
Thus, the semantics can ignore: (1) Function calls, (2) Variable 
declarations, scoping and shadowing, and (3) Pointers.
For example, the kernel program of 
Figure~\ref{fig:transform_forec_kernel} can be
transformed into the equivalent program of 
Figure~\ref{fig:transform_forec_refactored}.

\begin{figure}
	\subfloat[Original program.] {
		\begin{minipage}[b]{0.42\textwidth}
			\lstinputlisting[style=full]{./code/transform_forec_original.forec}
			\label{fig:transform_forec_original}
		\end{minipage}
	}
	\hfill
	\subfloat[Translated kernel program.] {
		\begin{minipage}[b]{0.49\textwidth}
			\lstinputlisting[style=full]{./code/transform_forec_kernel.forec}
			\label{fig:transform_forec_kernel}
		\end{minipage}
	}
	
	\subfloat[Transformed kernel program.] {
		\begin{minipage}[b]{\textwidth}
			\lstinputlisting[style=full]{./code/transform_forec_refactored.forec}
			\label{fig:transform_forec_refactored}
		\end{minipage}
	}
	
	\caption{Example of translating and transforming a ForeC program into the kernel instructions.}
	\label{fig:transform_forec}
\end{figure}


%-----------------------------------------------------------------------------

\subsection{Structural Translations to Kernel Instructions}
\label{sec:formalSemantics_translations}

\begin{table}
	\centering
	\renewcommand{\arraystretch}{1.25}
	
	\begin{tabular}{| l | l |}
		\hline
		\bf{ForeC Construct}														& \bf{Translation to Kernel Instruction(s)}																						\\ \hline
		\verb$input$, \verb$output$, and \verb$shared$								& Mapped to global variables.																									\\ \hline
		\verb$pause$																& \verb$pause$																													\\ \hline
		\verb$par$(\body{} (, \body{})*)											& Mapped to a \verb$resync$ instruction containing a nesting																	\\
																					& of \verb$par$(\thread{}:\body{}, \thread{}:\body{}) instructions.																\\ \hline
		\verb$abort$~\body{}~\verb$when immediate$?~(\expression{})					& \verb$addAbort$($a$, \imm{}, \expression{})\verb$;$																			\\
																					& \verb$par$( \thread{1}:\{\verb$preempt$($a$);\} , \thread{2}:\{\body{}\verb$; preempt$()\verb$;$\} )							\\ \hline
		\verb$weak$~\verb$abort$~\body{}~\verb$when immediate$?~(\expression{})		& \verb$addAbort$($a$, \imm{}, \expression{})\verb$;$ 																			\\
																					& \verb$par$( \thread{2}:\{\body{}\verb$; preempt$()\verb$;$\} , \thread{1}:\{\verb$preempt$($a$);\} )							\\ \hline
	\end{tabular}
	
	\caption{The structural translations of the ForeC instructions  
			 (Table~\ref{table:forec_semantics}) to the kernel instructions 
			 (Table~\ref{table:forec_kernel}).}
	\label{table:forec_structural_translations}
\end{table}

Table~\ref{table:forec_structural_translations} shows how 
the ForeC instructions of Table~\ref{table:forec_semantics}, 
are translated to the kernel instructions of Table~\ref{table:forec_kernel}.
For example, the ForeC program of 
Figure~\ref{fig:transform_forec_original} can be
translated into the kernel program of 
Figure~\ref{fig:transform_forec_kernel}.
The translations for \verb$input$, \verb$output$, \verb$shared$, and 
\verb$pause$ are straightforward. Before we translate a \verb$par$,
it is assigned a unique identifier $p$ that will be used to recall 
its child threads. The \verb$par$ instruction accepts 
an arbitrary number arguments but the \verb$par$ kernel 
instruction requires exactly two arguments. Thus, a \verb$par$
with \emph{n}-number of threads, \verb$par$(\body{1},~\body{2},~$\dots$,~\body{n}), 
is translated into \verb$par$(\body{1},~\verb$par$(\body{2},~$\dots$,~\body{n})). 
The translation is repeated until every \verb$par$ 
instruction has exactly two threads. Then, each thread \body{} is 
prefixed with a unique identifier \thread{} that serves as 
an abstract reference (handle) to the thread's body. 
Finally, the translated \verb$par$ kernel instruction is enclosed in 
a \verb$resync$ instruction that handles the resynchronisation 
behaviour of shared variables. The first argument of \verb$resync$ is
the identifier $p$ of the original \verb$par$. The
second argument is the translated \verb$par$ kernel instructions. 
For example, the complete kernel translation of \verb$par$(\body{1},~\body{2},~\body{3}) 
with $p = 0$ is 
\verb$resync$($0$,~\verb$par$(\thread{1}:\body{1},~\thread{a}:\verb$par$(\thread{2}:\body{2},~\thread{3}:\body{3}))).
%As a special case, \verb$par$(\body{1}) with $p = 1$, which has one thread, 
%is translated into \verb$resync$($1$,~\verb$par$(\thread{1}:\body{1},~\thread{2}:\{\verb$nop$;\})). 
The translation of a \verb$par$ is the only occasion when the 
\verb$resync$ kernel instruction is used.

Traditionally, the semantics of \verb$abort$ is captured using 
\emph{traps}~\cite{EsterelV7} and allows the \verb$abort$ body 
to be preempted at any time during execution. In contrast, the 
\verb$abort$ semantics in ForeC is simplified by only restricting 
preemptions to the tick boundaries. This allows ForeC \verb$abort$s 
to be translated into a \verb$par$ kernel instruction containing 
a thread \thread{1} that takes a triggered preemption, 
\{\verb$preempt$($a$);\}, and another thread \thread{2} that executes 
the original abort body, \{\body{}\verb$; end;$\}. The \thread{1} 
is a unique identifier while \thread{2} is the identifier of the 
thread that enclosed the original abort body.
The ordering of \thread{1} and \thread{2} is used to achieve 
weak and strong \verb$abort$ behaviours. Each \verb$abort$
is also associated with a unique identifier $a$. The \verb$addAbort$
kernel instruction is used to initialise the \verb$abort$ condition
and triggering of preemptions. The value of \imm{} 
is $0$ for a delayed \verb$abort$ and $1$ for an immediate \verb$abort$.
The \verb$preempt$ kernel instruction is used to 
take a triggered preemption by forcing the termination of 
both threads. The translation of \verb$abort$ is the only
occasion when the \verb$addAbort$ and \verb$preempt$ kernel
instructions are used.


%-----------------------------------------------------------------------------

\subsection{Notation}
The rewrite rules have the following form in the style of 
Structural Operational Semantics~\cite{semantics_sos}:
\begin{equation*}
	\langle State \rangle ~ \thread{}:\body{} 
		\xrightarrow[\Input]{~~k~~} 
	\langle State' \rangle ~ \thread{}:\body{}'
\end{equation*}
This notation describes a program fragment \body{} belonging to thread \thread{},
in the program state $\langle State \rangle$ and with inputs \Input{}, that
reacts and modifies the program state to $\langle State' \rangle$, emits the 
completion code $k$, and becomes the new program fragment $\body{}'$. 

Let $\thread{} \in \Thread$ be the set of all threads in the program 
and that each thread \thread{} is associated with a unique program 
fragment (thread body) \body{}, denoted as $\thread{}:\body{}$.
Thread \thread{} can be treated as an abstract reference (handler) to its 
body \body{}. Let $\langle State \rangle$ be defined as 
$\langle \Environment, \Abort \rangle$, where:
\begin{itemize}
	\item \Environment{} is an environment that maps thread identifiers \Thread{} and an identifier 
		  \Global{}, for the global scope, to a store (\Store{}) of variables (\Var{}) and their 
		  valuations (\Val{}). Let $\Id = \Thread \cup \{\Global\}$, then $\Environment: \Id \to \Store$ and 
		  $\Store: \Var \to Val$. Both \Environment{} and \Store{} are partial functions. 
		  All the global variables are contained in $\Environment[\Global]$ 
		  and the modified copies of shared variables are contained in $\Environment[\thread{}]$
		  for each thread $\thread{} \in \Thread$.
		  
	\item \Abort{} is a mapping of \verb$abort$ identifiers to values (\Val{}) representing their preemption
		  status. Let $a \in \mathcal{A}$ denote the set of \verb$abort$ identifiers, then
		  $\Abort: \mathcal{A} \to Val$. An \verb$abort$ with a non-zero value means that its
		  preemption has been triggered.
\end{itemize}
The completion code of a transition is encoded by $k$, where:
\begin{equation*}
	k = \begin{cases}
		0		& \text{If the transition terminates.}										\\
		1		& \text{If the transition pauses, but resumes in the next global tick.}		\\
		2		& \text{If the transition preempts the executing thread and its sibling.}	\\
		\bot	& \text{If the transition continues.}
	\end{cases}
\end{equation*}


%-----------------------------------------------------------------------------

\subsection{Predicates}
To keep the ForeC semantics concise, we define predicates for returning 
statically known information about the program. 
\begin{itemize}
	\item $\Parent(\thread{})$:
		Returns the parent of thread \thread{}.
		If $\thread{} =$ \verb$main$, then $\top$ is returned.
	\item $\Children(p)$:
		Returns the child threads of \verb$par$ $p$.
	\item $\Shared(\store)$:
		Returns the set of all shared variables in \store{}.
	\item $\GetFilter(\var)$:
		Returns the filter function of shared variable \var{}.
	\item $\GetCombine(\var)$:
		Returns the combine function of shared variable \var{}.
	\item $\GetExp(a)$:
		Returns the condition \expression{} of \verb$abort$ $a$.
\end{itemize}
As an example, Figure~\ref{fig:forec_predicates} shows the use of predicates on
the program in Figure~\ref{fig:transform_forec_refactored}:
\begin{figure}[ht]
	\centering
	\begin{tabular}{|l l l|}
		\hline
																			&												&														\\
		$\Parent($\verb$main$$) = \top$										& $\Parent($\verb$t1$$) =~$\verb$main$			& $\Parent($\verb$t2$$) =~$\verb$main$					\\
		$\Parent($\verb$t3$$) =~$\verb$main$								& $\Children(0) = \{$\verb$t1$$,$\verb$t2$$\}$	& $\Shared(\Environment[\Global]) = \{$\verb$s_main$$\}$\\
		$\GetFilter($\verb$s_main$$) =~$\verb$diff$							& $\GetCombine($\verb$s_main$$) =~$\verb$plus$	& $\GetExp($\verb$0$$) =~$\verb$s_main>10$				\\
																			&												&														\\
		\hline
	\end{tabular}
	
	\caption{Example of applying predicates to the program of Figure~\ref{fig:transform_forec_refactored}.}
	\label{fig:forec_predicates}
\end{figure}

%-----------------------------------------------------------------------------

\subsection{The Structural Operational Semantics}

\subsubsection{The nop Instruction}
The \verb$nop$ instruction does nothing, emits
the completion code of $0$, and terminates 
immediately:
\begin{equation*}	
	\tag{nop}
	\label{forec:nop}
	\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
		\xrightarrow[~~\Input~~]{0} 
	\langle \Environment, \Abort \rangle ~ \thread{}: 
\end{equation*}

\subsubsection{The pause Instruction}
The \verb$pause$ instruction does nothing and emits the 
completion code of $1$:
\begin{equation*}
	\tag{pause}
	\label{forec:pause}
	\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{pause}
		\xrightarrow[~~\Input~~]{1} 
	\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
\end{equation*}

\subsubsection{The addAbort Instruction}
The \verb$addAbort$ instruction creates a new mapping between the 
\verb$abort$ identifier $a$ and its preemption status in \Abort{}. 
For an immediate \verb$abort$ (i.e., $\imm = 1$), the immediate 
semantics is captured by initialising its preemption status to the 
evaluated value of expression \expression{} (using the semantic
function $\Eval$, described in Section~\ref{sec:forec_Eval}):
\begin{equation*}
	\tag{imm-abort}
	\label{forec:imm-abort}
	\frac{
			\imm = 1
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{addAbort}(a, \imm, \expression)
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort[a \gets \Eval(\Environment, \thread{}, \expression))] \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}
Otherwise, the delayed semantics is captured by initialising the 
preemption status to $0$:
\begin{equation*}
	\tag{del-abort}
	\label{forec:del-abort}
	\frac{
			\imm \neq 1
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{addAbort}(a, \imm, \expression)
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort[a \gets 0] \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}

\subsubsection{The preempt Instruction}
The \verb$preempt$ instruction does nothing and emits the completion code
of $2$ if the preemption for \verb$abort$ $a$ has been triggered. 
Otherwise, the \verb$preempt$ instruction rewrites to itself and emits the 
completion code of $1$:
\begin{equation*}
	\tag{preempt}
	\label{forec:preempt}
	\frac{
			\Abort[a] \neq 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{preempt}(a)
				\xrightarrow[~~\Input~~]{2} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}

\begin{equation*}
	\tag{not-preempt}
	\label{forec:not-preempt}
	\frac{
			\Abort[a] = 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{preempt}(a)
				\xrightarrow[~~\Input~~]{1} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{preempt}(a)
		}
\end{equation*}
A \verb$preempt$ instruction with no argument does nothing 
and emits the completion code of $2$:
\begin{equation*}
	\tag{end-preempt}
	\label{forec:end-preempt}
	\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{preempt}()
		\xrightarrow[~~\Input~~]{2} 
	\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{nop}
\end{equation*}

\subsubsection{The Assignment Instruction}
The assignment instruction evaluates the expression
\expression{} into a value.
If \var{} is a shared variable (\ref{forec:assign-shared}), then the value is 
assigned to the thread's store, $\Environment[\thread{}]$. 
This allows the thread to keep its modified copy of \var{} 
separate from the other threads.
Otherwise, if the variable \var{} is a private variable (\ref{forec:assign-private}), then the value 
is assigned to the actual variable in $\Environment[\Global]$:
\begin{equation*}
	\tag{assign-shared}
	\label{forec:assign-shared}
	\frac{
			\var \in \Shared(\Environment[\Global])
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\var \mathtt{=} \expression
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment[\thread{}][\var \gets \Eval(\Environment, \thread{}, \expression)], \Abort \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}

\begin{equation*}
	\tag{assign-private}
	\label{forec:assign-private}
	\frac{
			\var \notin \Shared(\Environment[\Global])
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\var \mathtt{=} \expression
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment[\Global][\var \gets \Eval(\Environment, \thread, \expression)], \Abort \rangle ~ \thread{}:\mathtt{nop}
		}
\end{equation*}

%\subsubsection{The combine Instruction}
%The \verb$combine$ statement combines the copies of shared variables 
%belonging to threads $\thread{1}$ to $\thread{n}$ using the semantic 
%function $\Combine$ (described in Section~\ref{sec:forec_Combine}). 
%The resulting values are assigned to thread $\thread{0}$:
%\begin{equation*}
%	\tag{combine}
%	\label{forec:combine}
%	\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{combine}(\thread{1}, \dots, \thread{n})
%		\xrightarrow[~~\Input~~]{\bot} 
%	\langle \Combine(\Environment, \lbrace \thread{1}, \dots, \thread{n} \rbrace, \thread{0}), \Abort \rangle ~ \thread{0}:\mathtt{nop}
%\end{equation*}

\subsubsection{The if-else Instruction}
A conditional instruction is rewritten into one of its branches, depending on 
the value of its condition \expression{}:
\begin{equation*}
	\tag{then}
	\label{forec:then}
	\frac{
			\Eval(\Environment, \thread{}, \expression) \neq 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{if}~(\expression)~\body{1}~\mathtt{else}~\body{2}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}
		}
\end{equation*}

\begin{equation*}
	\tag{else}
	\label{forec:else}
	\frac{
			\Eval(\Environment, \thread{}, \expression) = 0
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{if}~(\expression)~\body{1}~\mathtt{else}~\body{2}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{2}
		}
\end{equation*}

\subsubsection{The while Instruction}
For a loop instruction, its body \body{} and condition \expression{} 
are unrolled once:
\begin{equation*}
	\tag{loop}
	\label{forec:loop}
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{while}~(\expression)~\body{}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\mathtt{if}~(\expression)~\lbrace \body{};~\mathtt{while}~(\expression)~\body{} \rbrace~\mathtt{else}~\mathtt{nop}
\end{equation*}

\subsubsection{The Sequence Instruction}
For a sequence of program fragments, the first fragment \body{1}
must terminate before the second fragment \body{2} can be rewritten. 
The (\ref{forec:seq-left}) rule emits the completion code of 
the first fragment:
\begin{equation*}
	\tag{seq-left}
	\label{forec:seq-left}
	\frac{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}
				\xrightarrow[~~\Input~~]{k \neq 0} 
			\langle \Environment', \Abort' \rangle ~ \thread{}:\body{1}'
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}\mathtt{;}~\body{2}
				\xrightarrow[~~\Input~~]{k} 
			\langle \Environment', \Abort' \rangle ~ \thread{}:\body{1}'\mathtt{;}~\body{2}
		}
\end{equation*}
The (\ref{forec:seq-right}) rule is applied if the 
first fragment terminates:
\begin{equation*}
	\tag{seq-right}
	\label{forec:seq-right}
	\frac{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}
				\xrightarrow[~~\Input~~]{0} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}'
		}{
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{1}\mathtt{;}~\body{2}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort \rangle ~ \thread{}:\body{2}
		}
\end{equation*}

\subsubsection{The par Instruction}
The \verb$par$ instruction allows both its child threads, $\thread{1}$
and $\thread{2}$, to execute in parallel. The parent thread is $\thread{0}$:
\begin{equation*}
	\tag{par-1}
	\label{forec:par-1}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment', \Abort' \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment'', \Abort'' \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Merge(\Environment, \Environment', \Environment''), \Abort' \cup \Abort'' \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}')
	}
\end{equation*}
The modified variables in $\Environment'$ and 
$\Environment''$ are merged into the same environment using the semantic 
function $\Merge$ (Section~\ref{sec:forec_Merge}). 

If a thread completes its local tick, by pausing or 
terminating, then it will wait for its sibling to 
complete its local tick:
\begin{equation*}
	\tag{par-2}
	\label{forec:par-2}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{k \in \lbrace 0, 1 \rbrace} 
		\langle \Environment', \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment'', \Abort' \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment'', \Abort' \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2}')
	}
\end{equation*}

\begin{equation*}
	\tag{par-3}
	\label{forec:par-3}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment', \Abort' \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{k \in \lbrace 0, 1, 2 \rbrace} 
		\langle \Environment'', \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Environment', \Abort' \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2})
	}
\end{equation*}
If both threads complete their local tick, by pausing 
or terminating, then the modified copies of shared variables 
are combined using the semantic function $\Combine$
(Section~\ref{sec:forec_Combine}): 
\begin{equation*}
	\tag{par-4}
	\label{forec:par-4}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment', \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment'', \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment''', \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}')
	}
\end{equation*}
where $\Environment''' = \Combine(\Merge(\Environment, \Environment', \Environment''), \lbrace \thread{1}, \thread{2} \rbrace, \thread{0})$.
\begin{equation*}
	\tag{par-5}
	\label{forec:par-5}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{0} 
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{0} 
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Combine(\Environment, \lbrace \thread{1}, \thread{2} \rbrace, \thread{0}), \Abort \rangle ~ \thread{0}:\mathtt{nop}
	}
\end{equation*}
Additionally, if only one thread terminates, then the \verb$par$ 
is rewritten into its remaining thread:
\begin{equation*}
	\tag{par-6}
	\label{forec:par-6}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{0} 
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment', \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{1} 
		\langle \Combine(\Environment', \lbrace \thread{1}, \thread{2} \rbrace, \thread{0}), \Abort \rangle ~ \thread{2}:\body{2}'
	}
\end{equation*}

\begin{equation*}
	\tag{par-7}
	\label{forec:par-7}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{1} 
		\langle \Environment', \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{0} 
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{1} 
		\langle \Combine(\Environment', \lbrace \thread{1}, \thread{2} \rbrace, \thread{0}), \Abort \rangle ~ \thread{1}:\body{1}'
	}
\end{equation*}
If the first thread can produce a completion code of 
$2$, then both threads are terminated:
\begin{equation*}
	\tag{par-8}
	\label{forec:par-8}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{2} 
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Combine(\Environment, \lbrace \thread{1}, \thread{2} \rbrace, \thread{0}), \Abort \rangle ~ \thread{0}:\mathtt{nop}
	}
\end{equation*}
Otherwise, if the second thread can produce a completion
code of $2$, then both threads are terminated when
the first thread completes its local tick:
\begin{equation*}
	\tag{par-9}
	\label{forec:par-9}
	\frac{
		\langle \Environment, \Abort \rangle ~ \thread{1}:\body{1}
			\xrightarrow[~~\Input~~]{k \in \lbrace 0, 1 \rbrace} 
		\langle \Environment', \Abort \rangle ~ \thread{1}:\body{1}'
		\quad
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}
			\xrightarrow[~~\Input~~]{2} 
		\langle \Environment, \Abort \rangle ~ \thread{2}:\body{2}'
	}{
		\langle \Environment, \Abort \rangle ~ \thread{0}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \Combine(\Environment', \lbrace \thread{1}, \thread{2} \rbrace, \thread{0}), \Abort \rangle ~ \thread{0}:\mathtt{nop}
	}
\end{equation*}
The (\ref{forec:par-3}), (\ref{forec:par-8}), and (\ref{forec:par-9}) 
rules are used to capture the strong and weak \verb$abort$ semantics.

\subsubsection{Global Tick}
A global tick occurs if the \verb$main$ thread pauses or
terminates. All the modified copies of shared variables 
are combined and assigned to the actual shared variables. 
The preemption statuses 
are also updated using the semantic function $\Preemptions$ 
(Section~\ref{sec:forec_Preemptions}):
\begin{equation*}
	\tag{global-tick}
	\label{forec:global-tick}
	\frac{
			\langle \Environment, \Abort \rangle ~ main:\body{}
				\xrightarrow[~~\Input~~]{k \in \lbrace 0, 1 \rbrace} 
			\langle \Environment', \Abort \rangle ~ main:\body{}'
		}{
			\langle \Environment, \Abort \rangle ~ main:\body{}
				\xrightarrow[~~\Input~~]{k} 
			\langle \Environment'', \Preemptions(\Environment'', \Abort) \rangle ~ main:\body{}'
		}
\end{equation*}
where $\Environment'' = \Combine(\Environment', \lbrace main \rbrace, \Global)$. 
When the transition completes, the outputs are emitted and 
the inputs are sampled.


%-----------------------------------------------------------------------------

\subsection{Semantic Functions}
This section describes the various semantic functions 
used by the rewrite rules.

\subsubsection{\textsc{Eval}}
\label{sec:forec_Eval}
The semantic function $\Eval(\Environment, \thread{}, \expression)$ 
follows the evaluation rules of the C-language to 
evaluate the expression \expression{} and returns 
the result. During the evaluation, the value of a 
variable is retrieved by the semantic function $\GetVal$ 
(described in Section~\ref{sec:forec_GetVal}).

\subsubsection{\textsc{GetVal}}
\label{sec:forec_GetVal}
When evaluating an expression, the semantic function
$\GetVal(\Environment, \thread{}, \var)$ is used 
to retrieve the value of each variable. 
This function is described by Algorithm~\ref{algo:GetVal}. 
The inputs to the algorithm are: the program's environment 
\Environment{}, the thread \thread{} that the expression 
belongs to, and the variable \var{} that we want the value 
of. The output is a value \val{}. If \var{} is in thread 
\thread{}'s store, then its value is returned 
(line~\ref{algo:GetVal_local}). Otherwise, we find the ancestor of
thread \thread{} that has a copy of \var{} by using the
semantic function $\GetAncestorWithCopy$ 
(described in Section~\ref{sec:forec_GetAncestorWithCopy}). 
If such an ancestor exists ($\thread{a} \neq \top$), then
the value in the ancestor's store is returned (line~\ref{algo:GetVal_parent}). 
Otherwise, the value of the actual \var{} is returned
(line~\ref{algo:GetVal_global}).

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\GetVal$}{\Environment{}, \thread{}, \var{}}
			\If {$\var \in \Environment[\thread{}]$}	
				\State \Return $\Environment[\thread{}][\var]$							\Comment{Return the thread's value for \var{}.}\label{algo:GetVal_local}
			\Else
				\State $\thread{a} = \GetAncestorWithCopy(\Environment, \thread{}, \var)$\Comment{Get the ancestor with a copy of \var{}.}
				\If {$\thread{a} \neq \top$}
					\State \Return $\Environment[\thread{a}][\var]$						\Comment{Return the ancestor's value for \var{}.}\label{algo:GetVal_parent}
				\Else
					\State \Return $\Environment[\Global][\var]$						\Comment{Return the value of the actual \var{}.}\label{algo:GetVal_global}
				\EndIf
			\EndIf
		\EndFunction
	\end{algorithmic}
	
	\caption{Gets the value of a given variable.}
	\label{algo:GetVal}
\end{algorithm}

\subsubsection{\textsc{GetAncestor}}
\label{sec:forec_GetAncestorWithCopy}
The semantic function $\GetAncestorWithCopy(\Environment, \thread{}, \var)$ 
finds thread \thread{}'s ancestor that has a copy 
of a given variable \var{} in its store. This function is described 
by Algorithm~\ref{algo:GetAncestorWithCopy}. The inputs
to the algorithm are: the program's environment 
\Environment{}, the thread \thread{} to start searching 
from, and the variable \var{} to find. The output is a
thread. The first ancestor we search through is thread 
\thread{}'s parent. The parent is returned if it has a 
copy of \var{} (lines~\ref{algo:GetAncestorWithCopy_found_start}-\ref{algo:GetAncestorWithCopy_found_end}). 
Otherwise, the search continues 
through the thread's ancestry until a copy is found. On
line~\ref{algo:GetAncestorWithCopy_top1}, recall that 
$\Parent(\thread{a})$ returns $\top$ when $\thread{a}$ is 
the program's \verb$main$ thread. If no ancestor is found, 
then $\top$ is returned (line~\ref{algo:GetAncestorWithCopy_top2}).

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\GetAncestorWithCopy$}{\Environment{}, \thread{}, \var{}}
			\State $\thread{a} = \Parent(\thread{})$		\Comment{Get the parent.}
			\While {$\thread{a} \neq \top$}					\Comment{While an ancestor exists.}
				\If {$\var \in \Environment[\thread{a}]$}	\label{algo:GetAncestorWithCopy_found_start}
					\State \Return $\thread{a}$				\Comment{A copy of \var{} is in this ancestor's store.}
				\EndIf										\label{algo:GetAncestorWithCopy_found_end}
				\State $\thread{a} = \Parent(\thread{a})$	\Comment{Continue searching through the ancestry.}\label{algo:GetAncestorWithCopy_top1}
			\EndWhile
			\State \Return $\top$							\Comment{No ancestor found.}\label{algo:GetAncestorWithCopy_top2}
		\EndFunction
	\end{algorithmic}
	
	\caption{Gets the ancestor that has a copy of a given variable.}
	\label{algo:GetAncestorWithCopy}
\end{algorithm}

\subsubsection{\textsc{Merge}}
\label{sec:forec_Merge}
The semantic function $\Merge(\Environment, \Environment', \Environment'')$
merges the modified private variables and the copies of shared variables in 
$\Environment'$ and $\Environment''$ into the same program environment. 
The (\ref{forec:par-4}) to (\ref{forec:par-9}) rules remove threads from 
the environment after their stores have been combined by the semantic 
function $\Combine$ (Section~\ref{sec:forec_Combine}). Thus, the merged 
environment should not contain the removed threads. This function is 
described by Algorithm~\ref{algo:Merge} and its inputs 
are: the original program environment \Environment{}, and the 
program environments $\Environment'$ and $\Environment''$ modified 
by two parallel threads. The output is an updated environment 
$\Environment'''$. The algorithm begins by finding the set of threads 
$\Thread_r$ that have been removed from either $\Environment'$ or 
$\Environment''$ (line~\ref{algo:Merge_remove1}). These threads are 
subsequently removed from both $\Environment'$ and $\Environment''$ 
(line~\ref{algo:Merge_remove2}). Line~\ref{algo:Merge_merge} performs 
the merge. We observe that any two parallel threads will always
modify the same environment $\Environment$ in a mutually exclusive
manner. This is because the (\ref{forec:assign-shared}) rule only 
allows a thread to modify its own copies of shared variables and the 
(\ref{forec:assign-private}) rule only allows a thread to modify its 
own private variables. Thus, we only need to save the (modified) 
values in $\Environment'$ and $\Environment''$ that differ from 
the original values in \Environment{}. The first term,
$\Environment' \setminus (\Environment' \cap \Environment)$, removes 
variables from $\Environment'$ that have not been modified. Note that
$(\Environment' \cap \Environment)$ returns a program environment 
containing only the variables that have the same value in $\Environment'$ 
and $\Environment$. Similarly, the second term, 
$\Environment'' \setminus (\Environment'' \cap \Environment)$, removes 
variables from $\Environment''$ that have not been modified. The third
term, $\Environment \cap \Environment' \cap \Environment''$, returns 
the variables that have the same value in $\Environment'$ and 
$\Environment''$. The union of the three terms forms the merged 
environment $\Environment'''$.

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\Merge$}{\Environment{}, $\Environment'$, $\Environment''$}
			\State $\Thread_r = \lbrace \thread{} \mid \thread{} \in \Environment, \thread{} \notin \Environment' \vee \thread{} \notin \Environment'' \rbrace$	\Comment{Find the removed threads.}\label{algo:Merge_remove1}
			\State $\Environment' = \Environment' \setminus \Thread_r$, $\Environment'' = \Environment'' \setminus \Thread_r$						\Comment{Remove the threads.}\label{algo:Merge_remove2}
			\State \Return $\Environment''' = \left ( \Environment' \setminus (\Environment' \cap \Environment) \right ) \cup \left ( \Environment'' \setminus (\Environment'' \cap \Environment) \right ) \cup \left ( \Environment \cap \Environment' \cap \Environment'' \right )$	\Comment{Merge}\label{algo:Merge_merge}
		\EndFunction
	\end{algorithmic}
	
	\caption{Merges the modified values of two environments into one environment.}
	\label{algo:Merge}
\end{algorithm}

\subsubsection{\textsc{Combine}}
\label{sec:forec_Combine}
The semantic function $\Combine(\Environment, \Thread, \id)$ 
combines the copies of shared variables belonging to a set of threads \Thread{}. 
This function is described by Algorithm~\ref{algo:Combine}. The inputs
to the algorithm are: the program's environment \Environment{},
the set of threads \Thread{} to combine, and the 
identifier \id{} of the store to assign the combined
values into. The output is an updated environment $\Environment{}$.
For each shared variable \var{}, we find the threads that 
have a copy of \var{} (line~\ref{algo:Combine_find}). 
The threads are filtered using a user-defined $\Filter$ 
function to control what copies can be combined 
(line~\ref{algo:Combine_filter}). 
For example, $\Filter$ could filter out a parent thread's 
copy if a copy belonging to its child thread also exists.
This filter could be extended to also filter out 
copies that have the same value as the actual
shared variable (i.e., $\Environment[\thread{}][\var] = \Environment[\Global][var]$).
If at least one copy remains, then we initialise 
a temporary value \val{} with a copy (line~\ref{algo:Combine_init}). 
The value is combined with the remaining copies (line~\ref{algo:Combine_combine}) 
by using the shared variable's combine function $cf$ 
(line~\ref{algo:Combine_c}). The combined value is assigned 
to the given \id{}'s store in \Environment{}
(line~\ref{algo:Combine_assign}). Finally, we return \Environment{} 
without the threads' copies of shared variables (line~\ref{algo:Combine_return}).

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\Combine$}{\Environment{}, \Thread{}, \id{}}
			\ForAll {$\var \in \Shared(\Environment[\Global])$}										\Comment{For all shared variables.}
				\State $\Thread_c = \lbrace \thread{} \mid \forall \thread{} \in \Thread, \var \in \Environment[\thread{}] \rbrace$	\Comment{Get the threads that have a copy of \var{}.}\label{algo:Combine_find}
%				\State $\Thread_p = \lbrace \Parent(\thread_c) \mid \forall \thread_c \in \Thread_c, \Parent(\thread_c) \neq \top \rbrace$	\Comment{Get the parent threads.}\label{algo:Combine_find_parents}
%				\State $\Thread_c = \Thread_c \setminus \Thread_p$									\Comment{Remove the parent threads.}\label{algo:Combine_remove}
				\State $\Thread_c = \Filter(\Thread_c)$												\Comment{Filter the copies to combine.}\label{algo:Combine_filter}
				\If {$\lvert \Thread_c \rvert > 0$}
					\State $\val = \Environment[\thread{}][\var],$ where $\thread{} \in \Thread_c$	\Comment{Use a copy to initialise \val{}.}\label{algo:Combine_init}
					\State $cf = \GetCombine(\var)$													\Comment{Combine function for \var{}.}\label{algo:Combine_c}
					\ForAll {$\thread{c} \in \Thread_c \setminus \lbrace \thread{} \rbrace$}
						\State $\val = cf(\Environment[\thread{c}][\var], ~ \val)$					\Comment{Combine \val{} with the remaining copies.}\label{algo:Combine_combine}
					\EndFor
					\State $\Environment[\id][\var \gets \val]$										\Comment{Assign the result to \id{}'s store.}\label{algo:Combine_assign}
				\EndIf
			\EndFor
			\State \Return $\Environment \setminus \Thread$											\Comment{Return \Environment{} without the threads' copies.}\label{algo:Combine_return}
		\EndFunction
	\end{algorithmic}
	
	\caption{Combines copies of shared variables for a given set of threads.}
	\label{algo:Combine}
\end{algorithm}

\subsubsection{\textsc{Preemptions}}
\label{sec:forec_Preemptions}
The semantic function $\Preemptions(\Environment, \Abort)$
updates the preemption statuses of all the \verb$abort$s. This function
is described by Algorithm~\ref{algo:Preemptions}. The inputs 
to the algorithm are: the program's environment \Environment{}, 
and the set of \verb$abort$ identifiers \Abort{}. The output is 
\Abort{} with updated preemption statuses. For each \verb$abort$, 
line~\ref{algo:Preemptions_update} evaluates its expression 
using the actual variables. The result 
is assigned to the \verb$abort$ identifier as its new preemption 
status.

\begin{algorithm}[t]
	\begin{algorithmic}[1]
		\Function{$\Preemptions$}{\Environment{}, \Abort{}}
			\ForAll {$\abort \in \Abort$}
				\State $\Abort[\abort \gets \Eval(\Environment, \Global, \GetExp(a))]$	\label{algo:Preemptions_update}
			\EndFor
			\State \Return \Abort
		\EndFunction
	\end{algorithmic}
	
	\caption{Updates the preemption status of all abort identifiers.}
	\label{algo:Preemptions}
\end{algorithm}


%-----------------------------------------------------------------------------

\subsection{Encoding Priority in the Structural Translation of a \texttt{par} Instruction}
Recall that \verb$par$ instructions containing more than two threads are translated into
a nesting of \verb$par$ kernel instructions. The innermost \verb$par$ statement must pause
or terminate before the surrounding \verb$par$ instruction can also pause and terminate.
Hence, the combining of values occurs in a pairwise manner from the rightmost threads 
(innermost \verb$par$ kernel instruction) to the leftmost threads of the \verb$par$ instruction.
This is exemplified by Figure~\ref{fig:par_priority_right_left}. Thus, there is a right-to-left 
order that can be used to emulate a priority-based combining of shared variables.
For a left-to-right ordering, the translation of a \verb$par$ can be altered so that 
\verb$par$(\body{1},~$\dots$,~\body{n-1},~\body{n}) is translated into 
\verb$par$(\verb$par$(\body{1},~$\dots$,~\body{n-1}),~\body{n}). The resulting combine 
behaviour is shown in Figure~\ref{fig:par_priority_left_right}.

\begin{figure}
	\centering
	
	\hfill
	\subfloat[Right-to-left priority.] {
		\includegraphics[width=0.45\columnwidth]{par_priority_right_left}
		\label{fig:par_priority_right_left}
	}
	\hfill
	\subfloat[Left-to-right priority.] {
		\includegraphics[width=0.45\columnwidth]{par_priority_left_right}
		\label{fig:par_priority_left_right}
	}
	\hfill
	
	\caption{Priority in the combining of shared variables.}
	\label{fig:par_priority}
\end{figure}


%-----------------------------------------------------------------------------

\subsection{Comparison with Concurrent Revisions}
SPC-MoC subsumes the idea of Concurrent Revisions while offering extra flexibility.
Similarities with Concurrent Revisions:
\begin{itemize}
	\item Assignment to variables: Classic data instructions.
	\item Classic control instructions: Conditional instructions.
	\item Forking and joining of threads: Concurrent Revisions is more expressive
		  (Synchronous versus Asynchronous, Static versus Dynamic).
\end{itemize}
Dissimilarities with Concurrent Revisions:
\begin{itemize}
	\item Blocking semantics of fork and join.
	\item Combining of revisions is only based on value.
	\item Preemptions.
	\item Synchronisation during thread executions (the butterfly communication pattern not 
		  supported by Concurrent Revisions).
\end{itemize}

Creating equivalent Concurrent Revision programs in ForeC (ForeC is a superset of 
Concurrent Revisions?):
\begin{itemize}
	\item Only use data, control, and fork/join instructions.
	\item How to extend the proofs of determinacy to preemptions and global ticks?
	\begin{itemize}
		\item Preemptions: Preemption of executions are defined precisely by the control-flow.
			  It is never the case that you can choose between taking a preemption and performing
			  another action (deterministic execution semantics).
		\item Global ticks: All threads have paused and cannot continue executing. Therefore, 
			  all copies of a shared variable can be safely combined.
	\end{itemize}
\end{itemize}