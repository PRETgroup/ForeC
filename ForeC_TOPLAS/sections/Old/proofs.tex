\section{Definitions and Proofs}
\label{sec:proofs}

\subsection{Reactivity and Determinism of ForeC Programs}
There are two properties of ForeC programs that are of interest:
reactivity and determinism.

\begin{definition}
	\label{def:reaction}
	A \emph{\textbf{reaction}} of program $\thread{}:\body{}$ in a tick is 
	denoted by:
	\begin{equation*}
		\langle \StateP \rangle ~ \thread{}:\body{} 
			\xRightarrow[~~\Input~~]{k \in \{0, 1\}} 
		\langle \StateP' \rangle ~ \thread{}:\body{}'
	\end{equation*}
	if there exists a sequence of rewrites with $k = \bot$
	that ends in a rewrite with $k \in \{0, 1\}$:
	\begin{equation*}
		\langle \StateP \rangle ~ \thread{}:\body{} 
			\xrightarrow[~~\Input~~]{\bot}
		\langle \StateP^1 \rangle ~ \thread{}:\body{1}
			\xrightarrow[~~\Input~~]{\bot}
			\dotsb
			\xrightarrow[~~\Input~~]{\bot}
		\langle \StateP^n \rangle ~ \thread{}:\body{n}
			\xrightarrow[~~\Input~~]{k \in \{0, 1\}} 
		\langle \StateP' \rangle ~ \thread{}:\body{}'
	\end{equation*}
\end{definition}

\begin{definition}
	\label{def:reactive}
	A program $\thread{}:\body{}$ is \emph{\textbf{reactive}} if, for 
	any program state \StateP{} and inputs \Input{}, 
	there is at least one possible \emph{\textbf{reaction}}
	(i.e., the program never deadlocks):
	\begin{equation*}
		\forall \StateP, \Input:
		\quad
		\exists \StateP', \body{}', k \in \{0, 1\}
		\quad
		\text{\emph{such that}}
		\quad
		\langle \StateP \rangle ~ \thread{}:\body{} 
			\xRightarrow[~~\Input~~]{k} 
		\langle \StateP' \rangle ~ \thread{}:\body{}'
	\end{equation*}
\end{definition}

\begin{definition}
	\label{def:deterministic}
	A program $\thread{}:\body{}$ is \emph{\textbf{deterministic}} if, for 
	any program state \StateP{}	and inputs \Input{}, there is at most one 
	possible \emph{\textbf{transition}}:
	\begin{equation*}
		\forall \StateP, \Input:
		\quad
		\exists ! \StateP', \body{}', k \in \{0, 1\}
		\quad
		\text{\emph{such that}}
		\quad
		\langle \StateP \rangle ~ \thread{}:\body{} 
			\xrightarrow[~~\Input~~]{k} 
		\langle \StateP' \rangle ~ \thread{}:\body{}'
	\end{equation*}
\end{definition}

\begin{theorem}
	\label{thm:reactive}
	All ForeC programs are reactive.
\end{theorem}
\begin{proof}
	The proof can be shown by a structural induction on $\thread{}:\body{}$.
	The (\ref{forec:nop}), (\ref{forec:copy}), (\ref{forec:pause}), (\ref{forec:status}),
	(\ref{forec:assign-shared}), (\ref{forec:assign-private}), and (\ref{forec:loop-else})
	rules imply that the following reactions are valid:
	\begin{align*}
		\langle \StateP \rangle ~ \thread{}:\mathtt{nop}
		&	\xRightarrow[~~\Input~~]{0} 
		\langle \StateP \rangle ~ \thread{}:									\\
		\langle \StateP \rangle ~ \thread{}:\mathtt{copy}
		&	\xRightarrow[~~\Input~~]{0} 
		\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}						\\
		\langle \StateP \rangle ~ \thread{}:\mathtt{pause}
		&	\xRightarrow[~~\Input~~]{1} 
		\langle \StateP \rangle ~ \thread{}:\mathtt{copy}						\\
		\langle \StateP \rangle ~ \thread{}:\mathtt{status}(a, \expression)
		&	\xRightarrow[~~\Input~~]{0} 
		\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}						\\
		\langle \StateP \rangle ~ \thread{}:\var \mathtt{=} \expression
		&	\xRightarrow[~~\Input~~]{0} 
		\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}						\\
		\langle \StateP \rangle ~ \thread{}:\mathtt{while}~(\expression)~\body{}
		&	\xRightarrow[~~\Input~~]{0} 
		\langle \StateP \rangle ~ \thread{}:\mathtt{nop}
	\end{align*}
	For the completion of a tick, defined by the (\ref{forec:tick})
	rule, the program must eventually terminate 
	($k = 0$) or \verb$pause$ ($k = 1$) for the tick to complete with 
	$k = 0$ or $k = 1$, respectively.
	Subsequently, only the \verb$abort$ and \verb$par$ kernel
	statements and sequence operator (\verb$;$) are of interest, 
	since all other kernel constructs complete with $k = \bot$.
	In the following, assume the induction hypothesis that there 
	always exists $\body{1}'$ and $\body{2}'$ such that:
	\begin{align}
		\label{eq:proofs_hypothesis1}
		\langle \StateP_1 \rangle ~ \thread{1}:\body{1}
		&	\xRightarrow[~~\Input~~]{k_1 \in \{0, 1\}} 
		\langle \StateP_1' \rangle ~ \thread{1}:\body{1}'						\\
		\label{eq:proofs_hypothesis2}
		\langle \StateP_2 \rangle ~ \thread{2}:\body{2}
		&	\xRightarrow[~~\Input~~]{k_2 \in \{0, 1\}} 
		\langle \StateP_2' \rangle ~ \thread{2}:\body{2}'
	\end{align}
	\begin{enumerate}
		\item Consider, $\thread{}:\mathtt{weak}?~\mathtt{abort}(a, \body{})$. 
			  Due to the hypothesis of Equation~\ref{eq:proofs_hypothesis1}:
			  \begin{itemize}
				\item if $k = 0$, we have from the (\ref{forec:abort-2}), 
					  (\ref{forec:abort-3}), and (\ref{forec:abort-6}) rules, 
					  \begin{equation*}
						\langle \StateP \rangle ~ \thread{}:\mathtt{weak}?~\mathtt{abort}(a, \body{}) 
							\xRightarrow[~~\Input~~]{0} 
						\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}
					  \end{equation*}
		
				\item if $k = 1$, we have from the (\ref{forec:abort-1}) rule, 
					  \begin{equation*}
						\langle \StateP \rangle ~ \thread{}:\mathtt{weak}?~\mathtt{abort}(a, \body{}) 
							\xRightarrow[~~\Input~~]{1} 
						\langle \StateP' \rangle ~ \thread{}:\mathtt{weak}?~\mathtt{abort}(a, \body{}')
					  \end{equation*}
					  and from the (\ref{forec:abort-4}) and (\ref{forec:abort-6}) rules, 
					  \begin{equation*}
						\langle \StateP \rangle ~ \thread{}:\mathtt{weak}~\mathtt{abort}(a, \body{}) 
							\xRightarrow[~~\Input~~]{0} 
						\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}
					  \end{equation*}
			  \end{itemize}
			  Thus, any preemptive composition of reactive programs will always be reactive.

		\item Consider, $\thread{}:\body{1}\mathtt{;}~\body{2}$. 
			  Due to the hypothesis of Equations~\ref{eq:proofs_hypothesis1} and \ref{eq:proofs_hypothesis2}:
			  \begin{itemize}
				\item if $k_1 = 1$, we have from the (\ref{forec:seq-left}) rule,
					  \begin{equation*}
			  		  	\langle \StateP \rangle ~ \thread{}:\body{1}\mathtt{;}~\body{2}
			  		  		\xRightarrow[~~\Input~~]{1} 
						\langle \StateP' \rangle ~ \thread{}:\body{1}'\mathtt{;}~\body{2}
			  		  \end{equation*}

				\item if $k_1 = 0$, we have from the (\ref{forec:seq-right}) rule,
					  \begin{equation*}
			  		  	\langle \StateP \rangle ~ \thread{}:\body{1}\mathtt{;}~\body{2}
			  		  		\xRightarrow[~~\Input~~]{k_2} 
						\langle \StateP' \rangle ~ \thread{}:\body{2}'
			  		  \end{equation*}
			  \end{itemize}
			  Thus, any sequential composition of reactive programs is always reactive.

		\item Consider, $\thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})$.
			  Due to the hypothesis of Equations~\ref{eq:proofs_hypothesis1} and \ref{eq:proofs_hypothesis2}:
			  \begin{itemize}
			  	\item if $k_1 = 1$ and $k_2 = 1$, we have from the (\ref{forec:par-4}) rule, 
			  		  \begin{equation*}
			  		  	\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			  		  		\xRightarrow[~~\Input~~]{1} 
						\langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}')
			  		  \end{equation*}
			  	
			  	\item if $k_1 = 0$ and $k_2 = 0$, we have from the (\ref{forec:par-5}) rule, 
			  		  \begin{equation*}
			  		  	\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			  		  		\xRightarrow[~~\Input~~]{0} 
						\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}
			  		  \end{equation*}

			  	\item if $k_1 = 0$ and $k_2 = 1$, we have from the (\ref{forec:par-6}) rule, 
			  		  \begin{equation*}
			  		  	\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			  		  		\xRightarrow[~~\Input~~]{1} 
						\langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{2}:\body{2}')
			  		  \end{equation*}

			  	\item if $k_1 = 1$ and $k_2 = 0$, we have from the (\ref{forec:par-7}) rule, 
			  		  \begin{equation*}
			  		  	\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
			  		  		\xRightarrow[~~\Input~~]{1} 
						\langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\mathtt{nop})
			  		  \end{equation*}
			  \end{itemize}
			  Thus, any parallel composition of reactive programs is always reactive.
	\end{enumerate}
\end{proof}

\begin{theorem}
	\label{thm:deterministic}
	All ForeC programs are deterministic. 
\end{theorem}
\begin{proof}
	The proof can be shown by a structural induction on $\thread{}:\body{}$.
	The (\ref{forec:nop}), (\ref{forec:copy}), (\ref{forec:pause}), and (\ref{forec:status})
	rules imply that the following transitions are deterministic:
	\begin{align*}
		\langle \StateP \rangle ~ \thread{}:\mathtt{nop}
		&	\xrightarrow[~~\Input~~]{0} 
		\langle \StateP \rangle ~ \thread{}:									\\
		\langle \StateP \rangle ~ \thread{}:\mathtt{copy}
		&	\xrightarrow[~~\Input~~]{0} 
		\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}						\\
		\langle \StateP \rangle ~ \thread{}:\mathtt{pause}
		&	\xrightarrow[~~\Input~~]{1} 
		\langle \StateP \rangle ~ \thread{}:\mathtt{copy}						\\
		\langle \StateP \rangle ~ \thread{}:\mathtt{status}(a, \expression)
		&	\xrightarrow[~~\Input~~]{0} 
		\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}
	\end{align*}
	For the completion of a tick, only the (\ref{forec:tick})
	rule can be applied when the program terminates 
	($k = 0$) or pauses ($k = 1$). Subsequently, only the \verb$abort$ and 
	\verb$par$ kernel statements and sequence operator (\verb$;$) are 
	of interest, since all other kernel constructs have 
	conditional transitions that are mutually exclusive.
	\begin{enumerate}
		\item Consider, $\thread{}:\mathtt{weak}?~\mathtt{abort}(a, \body{})$. 
			  Assume that $\body{} \xrightarrow[~~\Input~~]{k} \body{}'$.
			  For each possible combination of $k$ and preemption status
			  $\Abort[a]$, the table below shows that only one \verb$abort$
			  rule can be applied:
			  
			  \begin{center}
			  	  \renewcommand{\arraystretch}{1.25}
				  \begin{tabular}{| c | c | c | c | c | c | c | c |}
					\cline{3-8}
					\multicolumn{2}{c|}{}										& \multicolumn{3}{c |}{\textbf{Strong \texttt{abort}, \emph{k}}}		& \multicolumn{3}{c |}{\textbf{Weak \texttt{abort}, \emph{k}}}										\\ 
					\cline{3-8} 
					\multicolumn{2}{c|}{}										& ~~~~~\textbf{0}~~~~~	& ~~~~~\textbf{1}~~~~~							& ~~~~~\boldmath$\bot$~~~~~	& ~~~~~\textbf{0}~~~~~	& ~~~~~\textbf{1}~~~~~	& \boldmath$\bot$		\\ \hline 
					\multirow{2}{*}{\boldmath$\Abort[a]$}	& \boldmath$= 0$	& (\ref{forec:abort-2})	& \multicolumn{2}{c|}{(\ref{forec:abort-1})}								& (\ref{forec:abort-2})	& \multicolumn{2}{c|}{(\ref{forec:abort-1})}	\\ \cline{2-8}
															& \boldmath$\neq 0$	& \multicolumn{3}{c|}{(\ref{forec:abort-6})}														& (\ref{forec:abort-3})	& (\ref{forec:abort-4})	& (\ref{forec:abort-5})	\\
					\hline
				  \end{tabular}
			  \end{center}
			  
			  Thus, any preemptive composition of reactive programs is always deterministic.
			 
		\item Consider, $\thread{}:\body{1}\mathtt{;}~\body{2}$. 
			  Assume that $\body{1} \xrightarrow[~~\Input~~]{k_1} \body{1}'$.
			  If $k_1 = 0$, then only the (\ref{forec:seq-right}) rule can be applied.
			  If $k_1 \in \{1, \bot\}$, then only the (\ref{forec:seq-left}) rule can be applied.
			  Thus, any sequential composition of reactive programs is always deterministic.
 
		\item Consider, $\thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})$.
			  Assume that $\body{1} \xrightarrow[~~\Input~~]{k_1} \body{1}'$ and 
			  $\body{2} \xrightarrow[~~\Input~~]{k_2} \body{2}'$. For each possible
			  combination of $k_1$ and $k_2$, the table below shows that only one 
			  \verb$par$ rule can be applied:
			  
			  \begin{center}
				  \renewcommand{\arraystretch}{1.25}
				  \begin{tabular}{| c | c | c | c | c |}
					\cline{3-5}
					\multicolumn{2}{c|}{}				& \multicolumn{3}{c |}{\boldmath$k_2$}													\\ 
					\cline{3-5} 
					\multicolumn{2}{c|}{}				& \textbf{0}			& \textbf{1}			& \boldmath$\bot$						\\ \hline 
									& \textbf{0}		& (\ref{forec:par-5})	& (\ref{forec:par-6})	& \multirow{2}{*}{(\ref{forec:par-2})}	\\ \cline{2-4}
					\boldmath$k_1$	& \textbf{1}		& (\ref{forec:par-7})	& (\ref{forec:par-4})	&										\\ \cline{2-5}
									& \boldmath$\bot$	& \multicolumn{2}{c|}{(\ref{forec:par-3})}		& (\ref{forec:par-1})					\\
					\hline
				  \end{tabular}
			  \end{center}
			  
			  Moreover, the program states are merged with a deterministic set operation. 
			  The combining of shared variables using the semantic function $\Combine$ 
			  (Section~\ref{sec:forec_Combine}) is deterministic by design.
			  Thus, any parallel composition of reactive programs is always deterministic.
	\end{enumerate}
\end{proof}


\subsection{Commutativity and Associativity of Combining Shared Variables}
The commutativity and associativity of the \verb$par$ kernel statement
depends on how the shared variables are resynchronized. Of interest is the 
commutativity and associativity of the semantic function $\Combine$ 
(Section~\ref{sec:forec_Combine}), which combines the copies of each 
shared variable in a pairwise manner. As described in Algorithm~\ref{algo:Combine}, 
the shared variable's combine policy is always applied (lines~\ref{algo:Combine_default}-\ref{algo:Combine_endif1}) 
before the remaining copies are combined (lines~\ref{algo:Combine_if}-\ref{algo:Combine_endif2}). 
Let $s$ be a shared variable with 
combine policy $p \in \{\mathtt{all}, \mathtt{new}, \mathtt{mod}\}$ 
and combine function $cf$. If $s_1$, $s_2$, and $s_3$ are three copies 
of $s$, then let the following concise notation represent the computation
of the combined value:
\begin{equation*}
	cf \Bigl(p(s_1),~p \bigl(cf(p(s_2),~p(s_3))\bigr)\Bigr)
\end{equation*}
where, for example, $cf(p(s_2),~p(s_3))$ removes the copies 
$s_2$ and $s_3$ that do not satisfy the combine policy $p$
before combining the remaining copies. Different bracket sizes 
are used to clarify the nesting of the operations.

\begin{definition}
	\label{def:commutative_combine}
	The semantic function $\Combine$ is \emph{\textbf{commutative}} if the combined 
	result is independent of how the copies are 
	ordered during the combining process:
	\begin{equation*}
		\forall s_1, s_2:
		\quad
		cf(p(s_1),~p(s_2))
		\Longleftrightarrow
		cf(p(s_2),~p(s_1))
	\end{equation*}
\end{definition}

\begin{definition}
	\label{def:associative_combine}
	The semantic function $\Combine$ is \emph{\textbf{associative}} if the combined 
	result is independent of how the copies are 
	paired during the combining process:
	\begin{equation*}
		\forall s_1, s_2, s_3:
		\quad
		cf(p(s_1),~p(cf(p(s_2),~p(s_3))))
		\Longleftrightarrow
		cf(p(cf(p(s_1),~p(s_2))),~p(s_3))
	\end{equation*}
\end{definition}

\begin{theorem}
	\label{thm:commutative_combine}
	The semantic function $\Combine$ is commutative if all the 
	required combine functions are also commutative.
\end{theorem}
\begin{proof}
	We start by showing that, for a shared variable $s$ with 
	combine function $cf$, the commutativity of the semantic function 
	$\Combine$ only depends on the commutativity of $cf$. For the 
	combine policy $p = \mathtt{all}$, the table below shows the 
	result of combining the copies in different orders. The 
	left side of the table enumerates the possible combinations of 
	copies that satisfy the combine policy $p$. The remaining right 
	side of the table shows the result of combining the copies in
	different orders.
	\begin{center}
		\renewcommand{\arraystretch}{1.25}
		\begin{tabular}{| c | c || c | c |}
			\hline
			\boldmath$p(s_1)$	& \boldmath$p(s_2)$	& \boldmath$cf(p(s_1),~p(s_2))$	& \boldmath$cf(p(s_2),~p(s_1))$	\\ 
			\hline \hline
			$s_1$				& $s_2$				& $cf(s_1,~s_2)$				& $cf(s_2,~s_1)$				\\
			\hline
		\end{tabular}
	\end{center}
	Similarly, for the combine policies $p \in \{\mathtt{new}, \mathtt{mod}\}$, the 
	table below shows the result of combining the copies in 
	different orders. A $\bot$ is used to indicate that a value 
	does not exist.
	\begin{center}
		\renewcommand{\arraystretch}{1.25}
		\begin{tabular}{| c | c || c | c |}
			\hline
			\boldmath$p(s_1)$	& \boldmath$p(s_2)$	& \boldmath$cf(p(s_1),~p(s_2))$	& \boldmath$cf(p(s_2),~p(s_1))$	\\ 
			\hline \hline
			$s_1$				& $s_2$				& $cf(s_1,~s_2)$				& $cf(s_2,~s_1)$				\\ \hline
			$s_1$				& $\bot$			& \multicolumn{2}{c|}{$s_1$}									\\ \hline			
			$\bot$				& $s_2$				& \multicolumn{2}{c|}{$s_2$}									\\ \hline			
			$\bot$				& $\bot$			& \multicolumn{2}{c|}{$\bot$}									\\			
			\hline
		\end{tabular}
	\end{center}
	From the tables above, we can see that the commutativity
	of the semantic function $\Combine$ depends only on the 
	commutativity of the combine function.
	Thus, $\Combine$ is only commutative
	if all the required combined functions are also commutative.
\end{proof}

\begin{theorem}
	\label{thm:associative_combine}
	The semantic function $\Combine$ is associative if all the 
	required combine functions are also associative.
\end{theorem}
\begin{proof}
	We start by showing that, for a shared variable $s$ with 
	combine function $cf$, the associativity of the semantic function 
	$\Combine$ only depends on the associativity of $cf$. For the 
	combine policy $p = \mathtt{all}$, the table below shows the 
	result of combining the copies in different pairs. The 
	left side of the table enumerates the possible combinations of 
	copies that satisfy the combine policy $p$. The remaining right 
	side of the table shows the result of combining the copies in
	different pairs.
	\begin{center}
		\renewcommand{\arraystretch}{1.25}
		\begin{tabular}{| c | c |c || c | c |}
			\hline
			\boldmath$p(s_1)$	& \boldmath$p(s_2)$	&\boldmath$p(s_3)$	& \boldmath$cf(p(s_1),~p(cf(p(s_2),~p(s_3))))$	& \boldmath$cf(p(cf(p(s_1),~p(s_2))),~p(s_3))$	\\ 
			\hline \hline
			$s_1$				& $s_2$				& $s_3$				& $cf(s_1,~cf(s_2,~s_3))$						& $cf(cf(s_1,~s_2),~s_3)$						\\
			\hline
		\end{tabular}
	\end{center}
	Similarly, for the combine policies $p \in \{\mathtt{new}, \mathtt{mod}\}$, the 
	table below shows the result of combining the copies in 
	different pairs. Recall that the combine policy does not apply to 
	partially combined results (lines~\ref{algo:Combine_new} and 
	\ref{algo:Combine_mod} in Algorithm~\ref{algo:Combine}). 
	A $\bot$ is used to indicate that a value does not exist.
	\begin{center}
		\renewcommand{\arraystretch}{1.25}
		\begin{tabular}{| c | c |c || c | c |}
			\hline
			\boldmath$p(s_1)$	& \boldmath$p(s_2)$	&\boldmath$p(s_3)$	& \boldmath$cf(p(s_1),~p(cf(p(s_2),~p(s_3))))$	& \boldmath$cf(p(cf(p(s_1),~p(s_2))),~p(s_3))$	\\ 
			\hline \hline
			$s_1$				& $s_2$				& $s_3$				& $cf(s_1,~cf(s_2,~s_3))$						& $cf(cf(s_1,~s_2),~s_3)$						\\ \hline
			$s_1$				& $s_2$				& $\bot$			& \multicolumn{2}{c|}{$cf(s_1,~s_2)$}															\\ \hline
			$s_1$				& $\bot$			& $s_3$				& \multicolumn{2}{c|}{$cf(s_1,~s_3)$}															\\ \hline
			$\bot$				& $s_2$				& $s_3$				& \multicolumn{2}{c|}{$cf(s_2,~s_3)$}															\\ \hline
			$s_1$				& $\bot$			& $\bot$			& \multicolumn{2}{c|}{$s_1$}																	\\ \hline
			$\bot$				& $s_2$				& $\bot$			& \multicolumn{2}{c|}{$s_2$}																	\\ \hline
			$\bot$				& $\bot$			& $s_3$				& \multicolumn{2}{c|}{$s_3$}																	\\ \hline
			$\bot$				& $\bot$			& $\bot$			& \multicolumn{2}{c|}{$\bot$}																	\\
			\hline
		\end{tabular}
	\end{center}
	From the tables above, we can see that the associativity
	of the semantic function $\Combine$ depends only on the 
	associativity of the combine function.
	Thus, $\Combine$ is only associative
	if all the required combined functions are also associative.
\end{proof}


\subsection{Commutativity and Associativity of the \texttt{par} Kernel Statement}
Forking more than two threads at the same time can be achieved by 
nesting a number of \verb$par$ kernel statements together, e.g., 
$\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2}),~\thread{3}:\body{3})$.
It is important to know if the ordering or pairing of the
nested threads affects the program's execution behavior. That is,
under what circumstances is the \verb$par$ kernel statement 
commutative and associative.

\begin{definition}
	\label{def:commutative_par}
	The \verb$par$ statement is \emph{\textbf{commutative}} if its effects
	on the program's state at the end of each reaction is independent of how its
	threads are ordered:
	\begin{equation*}
		\forall \thread{1}, \thread{2}:
		\quad
		\thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
		\Longleftrightarrow
		\thread{}:\mathtt{par}(\thread{2}:\body{2},~\thread{1}:\body{1})
	\end{equation*}
\end{definition}

\begin{definition}
	\label{def:associative_par}
	The \verb$par$ kernel statement is \emph{\textbf{associative}} if its effects 
	on the program's state at the end of each reaction is independent of how its 
	threads are paired together:
	\begin{equation*}
		\forall \thread{1}, \thread{2}, \thread{3}:
		\quad
		\thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2}),~\thread{3}:\body{3})
		\Longleftrightarrow
		\thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{a}:\mathtt{par}(\thread{2}:\body{2},~\thread{3}:\body{3}))
	\end{equation*}
\end{definition}

\begin{theorem}
	\label{thm:commute_associate_par}
	The \verb$par$ kernel statement is commutative and associative if the 
	semantic function $\Combine$ is commutative and associative.
\end{theorem}
\begin{proof}
	We start with the following observations about how the program state can be modified:
	\begin{itemize}
		\item A thread can modify a subset of the program's environment 
			  \Environment{}. By virtue of private variables, the (\ref{forec:assign-shared}) 
			  rule for shared variables, and the semantic 
			  function $\Eval$ (Section~\ref{sec:forec_Eval}), the subset remains 
			  the same throughout the reaction and is mutually exclusive from the
			  subsets of all other threads.
		
		\item A thread can modify a subset of the program's preemption statuses \Abort{}. 
			  By virtue of translating the \verb$abort$ statement into the \verb$status$ 
			  and \verb$abort$ kernel statements, the subset remains the same throughout
			  the reaction and is mutually exclusive from the subsets of all other threads.
			  
		\item The \verb$par$ rules use a commutative and associative set operation to
			  merge the modified program states of each thread.

		\item When both threads of a \verb$par$ kernel statement complete their respective
			  reactions, their merged state is 
			  combined using the semantic function $\Combine$ 
			  (Section~\ref{sec:forec_Combine}). From Theorems~\ref{thm:commutative_combine}
			  and \ref{thm:associative_combine}, the commutativity and associativity 
			  of $\Combine$ depends on the required combine functions.
	\end{itemize}
	Based on these observations and Theorems~\ref{thm:reactive} and 
	\ref{thm:deterministic}, the proof can be shown by structural 
	induction on $\thread{}:\body{}$. Only the \verb$par$ kernel statement
	is of interest. In the following, assume the induction hypothesis that
	there always exists $\body{1}'$, $\body{2}'$, and $\body{3}'$ such that:
	\begin{align}
		\label{eq:proofs_hypothesis3}
		\langle \StateP_1 \rangle ~ \thread{1}:\body{1}
		&	\xRightarrow[~~\Input~~]{k_1 \in \{0, 1\}} 
		\langle \StateP_1' \rangle ~ \thread{1}:\body{1}'			\\
		\label{eq:proofs_hypothesis4}
		\langle \StateP_2 \rangle ~ \thread{2}:\body{2}
		&	\xRightarrow[~~\Input~~]{k_2 \in \{0, 1\}} 
		\langle \StateP_2' \rangle ~ \thread{2}:\body{2}'			\\
		\label{eq:proofs_hypothesis5}
		\langle \StateP_3 \rangle ~ \thread{3}:\body{3}
		&	\xRightarrow[~~\Input~~]{k_3 \in \{0, 1\}} 
		\langle \StateP_3' \rangle ~ \thread{2}:\body{3}'
	\end{align}
	\begin{enumerate}
		\item Consider, the commutativity of the \verb$par$ kernel
			  statement. The table below shows the result of commuting the
			  threads due to the hypothesis of Equations~\ref{eq:proofs_hypothesis3} 
			  and \ref{eq:proofs_hypothesis4}. The left side of the 
			  table enumerates the possible combinations of completion
			  codes ($k_1$ and $k_2$). The remaining right side
			  of the table shows the resulting reactions of the 
			  \verb$par$ kernel statements.
			  \begin{center}
				\renewcommand{\arraystretch}{1.25}
				\begin{tabular}{| c | c || c | c |}
					\hline
					\boldmath$k_1$	& \boldmath$k_2$	& \boldmath$\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})$								& \boldmath$\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{2}:\body{2},~\thread{1}:\body{1})$								\\ 
					\hline \hline																																								
					$1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}')$		& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{2}:\body{2}',~\thread{1}:\body{1}')$		\\ \hline
					$0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{2}:\body{2}')$	& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{2}:\body{2}',~\thread{1}:\mathtt{nop})$	\\ \hline
					$1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{2}:\body{2}',~\thread{1}:\mathtt{nop})$	& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{2}:\body{2}')$	\\ \hline
					$0$				& $0$				& $\xRightarrow[~~\Input~~]{0} \langle \StateP' \rangle ~ \thread{}:\mathtt{nop}$													& $\xRightarrow[~~\Input~~]{0} \langle \StateP'' \rangle ~ \thread{}:\mathtt{nop}$													\\
					\hline
				\end{tabular}
			  \end{center}
			  For each row, $\StateP' = \StateP''$ if the semantic 
			  function $\Combine$ is commutative (Theorem~\ref{thm:commutative_combine}).
			  Thus, the \verb$par$ kernel statement is commutative
			  if $\Combine$ is commutative.

		\item Consider, the associativity of the \verb$par$ kernel
			  statement. The tables below show the result of associating the
			  threads due to the hypothesis of Equations~\ref{eq:proofs_hypothesis3}, 
			  \ref{eq:proofs_hypothesis4}, and \ref{eq:proofs_hypothesis5}. 
			  The left side of the table enumerates the possible 
			  combinations of completion codes ($k_1$, $k_2$, and $k_3$). 
			  The remaining right side of the table shows the resulting 
			  reactions of the \verb$par$ kernel statements.
			  \begin{center}
				\renewcommand{\arraystretch}{1.25}
				\begin{tabular}{| c | c | c || c |}
					\hline
					\boldmath$k_1$	& \boldmath$k_2$	& \boldmath$k_3$	& \boldmath$\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2}),~\thread{3}:\body{3})$								\\ 
					\hline \hline																																								
					$1$				& $1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}'),~\thread{3}:\body{3}')$		\\ \hline
					$0$				& $1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{2}:\body{2}'),~\thread{3}:\body{3}')$		\\ \hline
					$1$				& $0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\mathtt{nop}),~\thread{3}:\body{3}')$		\\ \hline
					$0$				& $0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{nop},~\thread{3}:\body{3}')$													\\ \hline
					$1$				& $1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\body{2}'),~\thread{3}:\mathtt{nop})$		\\ \hline
					$0$				& $1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{2}:\body{2}'),~\thread{3}:\mathtt{nop})$	\\ \hline
					$1$				& $0$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP' \rangle ~ \thread{}:\mathtt{par}(\thread{a}:\mathtt{par}(\thread{1}:\body{1}',~\thread{2}:\mathtt{nop}),~\thread{3}:\mathtt{nop})$	\\ \hline
					$0$				& $0$				& $0$				& $\xRightarrow[~~\Input~~]{0} \langle \StateP' \rangle ~ \thread{}:\mathtt{nop}$																									\\
					\hline
				\end{tabular}
			  \end{center}
			  \begin{center}
				\renewcommand{\arraystretch}{1.25}
				\begin{tabular}{| c | c | c || c |}
					\hline
					\boldmath$k_1$	& \boldmath$k_2$	& \boldmath$k_3$	& \boldmath$\langle \StateP \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{a}:\mathtt{par}(\thread{2}:\body{2},~\thread{3}:\body{3}))$								\\ 
					\hline \hline																																								
					$1$				& $1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{a}:\mathtt{par}(\thread{2}:\body{2}',~\thread{3}:\body{3}'))$		\\ \hline
					$0$				& $1$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{a}:\mathtt{par}(\thread{2}:\body{2}',~\thread{3}:\body{3}'))$	\\ \hline
					$1$				& $0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{a}:\mathtt{par}(\thread{2}:\mathtt{nop},~\thread{3}:\body{3}'))$	\\ \hline
					$0$				& $0$				& $1$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{a}:\mathtt{par}(\thread{2}:\mathtt{nop},~\thread{3}:\body{3}'))$	\\ \hline
					$1$				& $1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{a}:\mathtt{par}(\thread{2}:\body{2}',~\thread{3}:\mathtt{nop}))$	\\ \hline
					$0$				& $1$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\mathtt{nop},~\thread{a}:\mathtt{par}(\thread{2}:\body{2}',~\thread{3}:\mathtt{nop}))$	\\ \hline
					$1$				& $0$				& $0$				& $\xRightarrow[~~\Input~~]{1} \langle \StateP'' \rangle ~ \thread{}:\mathtt{par}(\thread{1}:\body{1}',~\thread{a}:\mathtt{nop})$	\\ \hline
					$0$				& $0$				& $0$				& $\xRightarrow[~~\Input~~]{0} \langle \StateP'' \rangle ~ \thread{}:\mathtt{nop}$													\\
					\hline
				\end{tabular}
			  \end{center}
			  For each corresponding row in the tables above, $\StateP' = \StateP''$ if the semantic 
			  function $\Combine$ is associative (Theorem~\ref{thm:associative_combine}).
			  Thus, the \verb$par$ kernel statement is associative
			  if $\Combine$ is associative.
	\end{enumerate}
\end{proof}


\subsection{Thread Equivalence and Composition}
During implementation, a ForeC program may need to be 
optimized to satisfy memory or execution time requirements. 
It is useful to verify that the optimized ForeC program 
behaves equivalently to the original program. 

\begin{definition}
	\label{def:equivalence}
	Two threads, \thread{1} and \thread{2}, are \emph{\textbf{equivalent}}, 
	i.e., $\thread{1}:\body{1}' \equiv \thread{2}:\body{2}'$
	if the reactions of both threads produce the same completion code and program 
	state. Moreover, future reactions of both threads are also equivalent:
	\begin{align*}
		\thread{1}:\body{1} \equiv \thread{2}:\body{2}
		\text{ \emph{if} }
		\forall \StateP: 
		\quad
		\langle \StateP \rangle ~ \thread{1}:\body{1} 
		&	\xRightarrow[~~\Input~~]{k_1 \in \{0, 1\}} 
		\langle \StateP' \rangle ~ \thread{1}:\body{1}'		\\
		\langle \StateP \rangle ~ \thread{2}:\body{2} 
		&	\xRightarrow[~~\Input~~]{k_2 \in \{0, 1\}} 
		\langle \StateP'' \rangle ~ \thread{2}:\body{2}'	\\
		\text{\emph{where,} }
		k_1 = k_2, 
		\StateP' &= \StateP'', 
		\thread{1}:\body{1}' \equiv \thread{2}:\body{2}'
	\end{align*}
\end{definition}

\begin{theorem}
	\label{thm:composition}
	Two equivalent threads can each be composed in parallel with 
	a third thread to produce two equivalent parallel programs:
	\begin{equation*}
		\text{\emph{If} }
		\thread{1}:\body{1} \equiv \thread{2}:\body{2} 
		\text{\emph{, then} }
		\forall \thread{3}:\body{3}:
		\quad
		\thread{}:\mathtt{par}(\thread{1}: \body{1},~\thread{3}:\body{3}) \equiv \thread{}:\mathtt{par}(\thread{2}: \body{2},~\thread{3}:\body{3})
	\end{equation*}
\end{theorem}
\begin{proof}
	From Theorems~\ref{thm:reactive} and \ref{thm:deterministic}, it can be 
	easily verified that both parallel programs must perform the same sequence
	of reactions and, therefore, are equivalent programs.
\end{proof}
