\subsection{Example Executions}
This section provides examples of how ForeC programs
execute with the rewrite rules. A possible execution 
for each example program is given as a sequence of 
rewrites. 

\subsubsection{Program 1}
\begin{lstlisting}[style=snippet]
void main(void) {
  shared int s=1 combine all with plus;
  par({s++;},{s=3;});
}

int plus(int lhs,int rhs,int pre) {
	return (lhs+rhs);
}
\end{lstlisting}
This program is structurally translated to:
\begin{lstlisting}[style=snippet]
int s;
void main(void) {
  copy;
  s=1;
  par(t1:{copy; s++;},t2:{copy; s=3;});
}
\end{lstlisting}
The predicates $\Shared(main)$, $\Shared(t1)$, $\Shared(t2)$ and 
$\Shared(\Global)$ are all $\lbrace s \rbrace$.
Note that \verb$s++$ is shorthand for \verb$s=s+1$.
Initially, the set of preemption statuses \Abort{}
is $\emptyset$. The program's environment \Environment{} and its
derivatives are defined in Figure~\ref{figure:forec_program_1}.
\newline

\begin{figure}
	\centering
	$$\begin{array}{l l l}
		\Environment		&=& \left \lbrace
									\Global \to \lbrace s \rbrace
								\right \rbrace		\\
		\Environment^1		&=& \left \lbrace 
									\Global \to \lbrace s \rbrace,
									main \to \lbrace s \rbrace 
								\right \rbrace		\\
		\Environment^2		&=& \left \lbrace 
									\Global \to \lbrace s \rbrace,
									main \to \lbrace s \to (1, \mathtt{mod}) \rbrace
								\right \rbrace		\\
		\Environment^3		&=& \left \lbrace 
									\Global \to \lbrace s \rbrace,
									main \to \lbrace s \to (1, \mathtt{mod}) \rbrace,
									t1 \to \lbrace s \to (1, \mathtt{pre}) \rbrace
								\right \rbrace		\\
		\Environment^4		&=& \left \lbrace 
									\Global \to \lbrace s \rbrace,
									main \to \lbrace s \to (1, \mathtt{mod}) \rbrace,
									t2 \to \lbrace s \to (1, \mathtt{pre}) \rbrace
								\right \rbrace		\\
		\Environment^5		&=& \left \lbrace 
									\Global \to \lbrace s \rbrace,
									main \to \lbrace s \to (1, \mathtt{mod}) \rbrace,
									t1 \to \lbrace s \to (1, \mathtt{pre}) \rbrace,
									t2 \to \lbrace s \to (1, \mathtt{pre}) \rbrace
								\right \rbrace		\\
		\Environment^6		&=& \left \lbrace 
									\Global \to \lbrace s \rbrace,
									main \to \lbrace s \to (1, \mathtt{mod}) \rbrace,
									t1 \to \lbrace s \to (2, \mathtt{mod}) \rbrace,
									t2 \to \lbrace s \to (1, \mathtt{pre}) \rbrace
								\right \rbrace		\\
		\Environment^7		&=& \left \lbrace 
									\Global \to \lbrace s \rbrace,
									main \to \lbrace s \to (1, \mathtt{mod}) \rbrace,
									t1 \to \lbrace s \to (1, \mathtt{pre}) \rbrace,
									t2 \to \lbrace s \to (3, \mathtt{mod}) \rbrace
								\right \rbrace		\\
		\Environment^{8M}	&=& \left \lbrace 
									\Global \to \lbrace s \rbrace,
									main \to \lbrace s \to (1, \mathtt{mod}) \rbrace,
									t1 \to \lbrace s \to (2, \mathtt{mod}) \rbrace,
									t2 \to \lbrace s \to (3, \mathtt{mod}) \rbrace
								\right \rbrace		\\
		\Environment^8		&=& \left \lbrace 
									\Global \to \lbrace s \rbrace,
									main \to \lbrace s \to (5, \mathtt{cmb}) \rbrace
								\right \rbrace		\\
		\Environment^9		&=& \left \lbrace
									\Global \to \lbrace s \to (5, \mathtt{pre}) \rbrace
								\right \rbrace		\\
	\end{array}$$
	
	\caption{Definition of the initial program environment and its derivatives for Program 1.}
	\label{figure:forec_program_1}
\end{figure}

\noindent
Step 1: Apply the (\ref{forec:seq-right}) and (\ref{forec:copy}) rules. 
\begin{equation*}
	\frac{
			\langle \Environment, \Abort \rangle ~ \mathtt{main: copy}
				\xrightarrow[~~\Input~~]{0} 
			\langle \Environment^1, \Abort \rangle ~ \mathtt{main: nop}
		}{
			\begin{array}{l}
				\langle \Environment, \Abort \rangle ~ \mathtt{main: copy; s=1; par(t1:}		\\
				\mathtt{\{copy; s++;\},t2:\{copy; s=3;\})}										\\
			\end{array}
				\xrightarrow[~~\Input~~]{\bot} 
			\begin{array}{l}
				\langle \Environment^1, \Abort \rangle ~ \mathtt{main: s=1; par(t1:}			\\
				\mathtt{\{copy; s++;\},t2:\{copy; s=3;\})}										\\
			\end{array}
		}
\end{equation*}

\noindent
Step 2: Apply the (\ref{forec:seq-right}) and (\ref{forec:assign-shared}) rules. 
\begin{equation*}
	\frac{
		\dfrac{
				s \in \lbrace s \rbrace
			}{
				\langle \Environment^1, \Abort \rangle ~ \mathtt{main: s=1}
					\xrightarrow[~~\Input~~]{0} 
				\langle \Environment^2, \Abort \rangle ~ \mathtt{main: nop}
			}
		}{
			\begin{array}{l}
				\langle \Environment^1, \Abort \rangle ~ \mathtt{main: s=1; par(t1:\{copy; s++;\},}	\\
				\mathtt{t2:\{copy; s=3;\})}															\\
			\end{array}
				\xrightarrow[~~\Input~~]{\bot} 
			\begin{array}{l}
				\langle \Environment^2, \Abort \rangle ~ \mathtt{main: par(t1:\{copy; s++;\},}		\\
				\mathtt{t2:\{copy; s=3;\})}															\\
			\end{array}
		}
\end{equation*}

\noindent
Step 3: Apply the (\ref{forec:par-1}) rule. Additionally, apply the 
(\ref{forec:seq-right}) and (\ref{forec:copy}) rules to both threads.
\begin{equation*}
	\frac{
		\dfrac{
				\langle \Environment^2, \Abort \rangle ~ \mathtt{t1: copy}
					\xrightarrow[~~\Input~~]{0} 
				\langle \Environment^3, \Abort \rangle ~ \mathtt{t1: nop}
			}{
				\langle \Environment^2, \Abort \rangle ~ \mathtt{t1: copy; s++}
					\xrightarrow[~~\Input~~]{\bot} 
				\langle \Environment^3, \Abort \rangle ~ \mathtt{t1: s++}
			}
			\qquad
		\dfrac{
				\langle \Environment^2, \Abort \rangle ~ \mathtt{t2: copy}
					\xrightarrow[~~\Input~~]{0} 
				\langle \Environment^4, \Abort \rangle ~ \mathtt{t2: nop}
			}{
				\langle \Environment^2, \Abort \rangle ~ \mathtt{t2: copy; s=3}
					\xrightarrow[~~\Input~~]{\bot} 
				\langle \Environment^4, \Abort \rangle ~ \mathtt{t2: s=3}
			}
		}{
			\begin{array}{l}
				\langle \Environment^2, \Abort \rangle ~ \mathtt{main: par(t1:\{copy; s++;\},}	\\
				\mathtt{t2:\{copy; s=3;\})}														\\
			\end{array}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment^5, \Abort \rangle ~ \mathtt{main: par(t1:\{s++;\},t2:\{s=3;\})}
		}
\end{equation*}

\noindent
Step 4: Apply the (\ref{forec:par-5}) rule. Additionally, apply the 
(\ref{forec:assign-shared}) rule to both threads.
\begin{equation*}
	\frac{
		\dfrac{
				s \in \lbrace s \rbrace
			}{
				\langle \Environment^5, \Abort \rangle ~ \mathtt{t1: s++}
					\xrightarrow[~~\Input~~]{0} 
				\langle \Environment^6, \Abort \rangle ~ \mathtt{t1: nop}
			}
			\qquad
		\dfrac{
				s \in \lbrace s \rbrace
			}{
				\langle \Environment^5, \Abort \rangle ~ \mathtt{t2: s=3}
					\xrightarrow[~~\Input~~]{0} 
				\langle \Environment^7, \Abort \rangle ~ \mathtt{t2: nop}
			}
		}{
			\langle \Environment^5, \Abort \rangle ~ \mathtt{main: par(t1:\{s++;\},t2:\{s=3;\})}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment^8, \Abort \rangle ~ \mathtt{main: copy}
		}
\end{equation*}

\noindent
Step 5: Apply the (\ref{forec:tick}) and (\ref{forec:copy}) rules.
The \verb$copy$ statement has no effect because it is not the start of
the thread \verb$main$'s local tick. The program terminates.
\begin{equation*}
	\frac{
			\langle \Environment^8, \Abort \rangle ~ \mathtt{main: copy}
				\xrightarrow[~~\Input~~]{0} 
			\langle \Environment^8, \Abort \rangle ~ \mathtt{main: nop}
		}{
			\langle \Environment^8, \Abort \rangle ~ \mathtt{main: copy}
				\xrightarrow[~~\Input~~]{0} 
			\langle \Environment^9, \Abort \rangle ~ \mathtt{main: nop}
		}
\end{equation*}
