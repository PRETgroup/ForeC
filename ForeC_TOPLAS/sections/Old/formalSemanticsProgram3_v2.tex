\subsubsection{Program 3}
\begin{lstlisting}[style=snippet]
int x=1;
void main(void) {
  weak abort {
    x++; pause;
  } when immediate (x==1);
}
\end{lstlisting}
This program is structurally translated to:
\begin{lstlisting}[style=snippet]
int x=1;
void main(void) {
  status(a1, x==1); weak abort(a1, {x++; pause;});
}
\end{lstlisting}
The predicates $\Shared(main)$ and $\Shared(\Global)$ are both $\emptyset$.
The program's environment \Environment{}, preemption statuses \Abort{}
and their derivatives are defined in Figure~\ref{figure:forec_program_3}.
\newline

\begin{figure}
	\centering
	$$\begin{array}{l l l l l l}
		\Environment		&=& \left \lbrace
									\Global \to \lbrace x \to (1, \mathtt{pre}) \rbrace
								\right \rbrace	& \qquad 
		\Abort				&=& \lbrace a1 \rbrace			\\
		\Environment^1		&=& \left \lbrace
									\Global \to \lbrace x \to (2, \mathtt{pre}) \rbrace
								\right \rbrace	& \qquad 
		\Abort^1			&=& \lbrace a1 \to 1 \rbrace	\\
		& & & \qquad 
		\Abort^2			&=& \lbrace a1 \to 0 \rbrace	\\
	\end{array}$$
	
	\caption{Definition of the initial program state and its derivatives for Program 3.}
	\label{figure:forec_program_3}
\end{figure}

\noindent
Step 1: Apply the (\ref{forec:seq-right}) and (\ref{forec:status}) rules. 
\begin{equation*}
	\frac{
			\langle \Environment, \Abort \rangle ~ \mathtt{main: status(a1, x==1)}
				\xrightarrow[~~\Input~~]{0} 
			\langle \Environment, \Abort^1 \rangle ~ \mathtt{main: nop}
		}{
			\begin{array}{l}
				\langle \Environment, \Abort \rangle ~ \mathtt{main: status(a1, x==1);}		\\
				\mathtt{weak~abort(a1, \{x++; pause;\})}
			\end{array}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment, \Abort^1 \rangle ~ \mathtt{main: weak~abort(a1, \{x++; pause;\})}
		}
\end{equation*}

\noindent
Step 2: Apply the (\ref{forec:abort-5}), (\ref{forec:seq-right}), and (\ref{forec:assign-private}) rules.
\begin{equation*}
	\frac{
		\dfrac{
			\dfrac{
					x \notin \emptyset
				}{
					\langle \Environment, \Abort^1 \rangle ~ \mathtt{main: x++}
						\xrightarrow[~~\Input~~]{0} 
					\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main: nop}
				}
			}{
				\langle \Environment, \Abort^1 \rangle ~ \mathtt{main:x++; pause}
					\xrightarrow[~~\Input~~]{\bot} 
				\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main:pause}
			}
			\qquad
			\twolines{
					\twolines{~}{~}
				}{
					\Abort^1[a1] \neq 0
				}
		}{
			\langle \Environment, \Abort^1 \rangle ~ \mathtt{main: weak~abort(a1, \{x++; pause;\})}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main: weak~abort(a1, \{pause;\})}
		}
\end{equation*}

\noindent
Step 3: Apply the (\ref{forec:abort-4}) and (\ref{forec:pause}) 
rules.
\begin{equation*}
	\frac{
			\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main: pause}
				\xrightarrow[~~\Input~~]{1} 
			\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main: copy}
			\qquad
			\Abort^1[a1] \neq 0
		}{
			\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main: weak~abort(a1, \{pause;\})}
				\xrightarrow[~~\Input~~]{\bot} 
			\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main: copy}
		}
\end{equation*}

\noindent
Step 4: Apply the (\ref{forec:tick}) and (\ref{forec:copy}) 
rules. The program terminates.
\begin{equation*}
	\frac{
			\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main: copy}
				\xrightarrow[~~\Input~~]{0} 
			\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main: nop}
		}{
			\langle \Environment^1, \Abort^1 \rangle ~ \mathtt{main: copy}
				\xrightarrow[~~\Input~~]{0} 
			\langle \Environment^1, \Abort^2 \rangle ~ \mathtt{main: nop}
		}
\end{equation*}
