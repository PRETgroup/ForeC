\subsection{Definitions and Proofs}
\label{sec:forec_proofs}

%\subsection{Reactivity and Determinism of ForeC Programs}
The semantics of the ForeC kernel constructs (Section~\ref{sec:forec_semantics:sos}) 
can be used to
formally prove two desirable properties of safety-critical
programs, called \emph{reactivity} and
\emph{determinism}~\cite{Maraninchi92,Tardieu07}. A program
is reactive if it always responds to changes in the
environment, i.e., does not deadlock and produces outputs. 
A program is deterministic if, for a given set of inputs from the 
environment, there is at most one set of outputs produced by the 
programs. In terms of semantic derivation rules, a program is 
deterministic if there is at most one derivation tree in
response to the environment. The
definitions for reactivity and determinism are normally
based on a program's tick, which is a sequence of
transitions. Because the state of a ForeC program depends on
the initial valuations of its variables, we define a stronger notion
of reactivity and determinism based on program transitions. 

%\begin{definition}
%	\label{def:reaction}
%	A completed \emph{\textbf{reaction}} of program $\thread{}:\body{}$ 
%	in a tick is denoted by:
%	\begin{equation*}
%		\langle \StateP \rangle ~ \thread{}:\body{} 
%			\xRightarrow[~~\Input~~]{k \in \{0, 1\}} 
%		\langle \StateP' \rangle ~ \thread{}:\body{}'
%	\end{equation*}
%	if there exists a sequence of rewrites with $k = \bot$
%	that ends in a rewrite with $k \in \{0, 1\}$:
%	\begin{equation*}
%		\langle \StateP \rangle ~ \thread{}:\body{} 
%			\xrightarrow[~~\Input~~]{\bot}
%		\langle \StateP^1 \rangle ~ \thread{}:\body{1}
%			\xrightarrow[~~\Input~~]{\bot}
%			\dotsb
%			\xrightarrow[~~\Input~~]{\bot}
%		\langle \StateP^n \rangle ~ \thread{}:\body{n}
%			\xrightarrow[~~\Input~~]{k \in \{0, 1\}} 
%		\langle \StateP' \rangle ~ \thread{}:\body{}'
%	\end{equation*}
%\end{definition}

\begin{definition}
	\label{def:reactive}
	A program $\thread{}:\body{}$ is \emph{\textbf{reactive}} if,  
	in any state \StateP{}, for any input configuration \Input{}, 
	there exists at least one transition
	(i.e., the program never deadlocks):
	\begin{equation*}
		\forall \StateP, \Input: \quad
		\exists \StateP', \body{}', k
		\quad \text{such that} \quad
		\langle \StateP \rangle ~ \thread{}:\body{} 
			\xrightarrow[~~\Input~~]{k} 
		\langle \StateP' \rangle ~ \thread{}:\body{}'
	\end{equation*}
\end{definition}

\begin{theorem}
	\label{thm:reactive}
	All ForeC programs are \emph{\textbf{reactive}}.
\end{theorem}
\begin{proof}
	The proof can be shown by structural induction on $\thread{}:\body{}$.
	
	\textbf{Base cases:}
	The (\ref{forec:nop}), (\ref{forec:copy}), (\ref{forec:pause}), (\ref{forec:status}),
	(\ref{forec:assign-shared}), (\ref{forec:assign-private}), (\ref{forec:if-then}), 
	(\ref{forec:if-else}), (\ref{forec:loop-then}), and (\ref{forec:loop-else})
	rules imply that the following kernel constructs have at least one transition:
	\begin{align*}
		\langle \StateP \rangle ~ \thread{}:\mathtt{nop}
			\xrightarrow[~~\Input~~]{0}& 
		\langle \StateP \rangle ~ \thread{}:									\\
		%
		\langle \StateP \rangle ~ \thread{}:\mathtt{copy}
			\xrightarrow[~~\Input~~]{0}& 
		\langle \StateP' \rangle ~ \thread{}:									\\
		%
		\langle \StateP \rangle ~ \thread{}:\mathtt{pause}
			\xrightarrow[~~\Input~~]{1}& 
		\langle \StateP \rangle ~ \thread{}:\mathtt{copy}						\\
		%
		\langle \StateP \rangle ~ \thread{}:\mathtt{status}(a, \expression)
			\xrightarrow[~~\Input~~]{0}& 
		\langle \StateP' \rangle ~ \thread{}:									\\
		%
		\langle \StateP \rangle ~ \thread{}:\var \mathtt{=} \expression
			\xrightarrow[~~\Input~~]{0}& 
		\langle \StateP' \rangle ~ \thread{}:									\\
		%
		\langle \StateP \rangle ~ \thread{}:\mathtt{if}~(\expression)~\body{1}~\mathtt{else}~\body{2}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \StateP \rangle ~ \thread{}:\body{1}
		\quad \text{or} \quad &
		\langle \StateP \rangle ~ \thread{}:\mathtt{if}~(\expression)~\body{1}~\mathtt{else}~\body{2}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \StateP \rangle ~ \thread{}:\body{2}							\\
		%
		\langle \StateP \rangle ~ \thread{}:\mathtt{while}~(\expression)~\body{}
			\xrightarrow[~~\Input~~]{\bot}
		\langle \StateP \rangle ~ \thread{}:\body{};~\mathtt{while}~(\expression)~\body{}
		\quad \text{or} \quad &
		\langle \StateP \rangle ~ \thread{}:\mathtt{while}~(\expression)~\body{}
			\xrightarrow[~~\Input~~]{0}
		\langle \StateP \rangle ~ \thread{}:
	\end{align*}
	%Note that the assignment, \verb$if$--\verb$else$, and \verb$while$ kernel constructs 
%	are each described by a pair of rewrite rules with complementary premises that 
%	do not depend on other transitions. 
%	The premises are complementary in the sense that, if the premise of one rule is \emph{true}, 
%	then the premise of the other rule must be \emph{false}, and vice versa.
	
	\textbf{Induction step:}
	The sequence operator (\verb$;$), \verb$abort$, and \verb$par$ 
	kernel statements allow the composition of kernel constructs.
	For some $\thread{1}:\body{1}$ and $\thread{2}:\body{2}$ that 
	are arbitrary compositions of kernel constructs, assume the induction hypotheses 
	that they each have at least one transition:
	\begin{align*}
		\exists \StateP_1', \StateP_2', \body{1}', \body{2}', k_1, k_2
		\quad \text{such that} \quad
		\tag{H1}
		\label{forec_proofs:H1}
		\langle \StateP_1 \rangle ~ \thread{1}:\body{1}
		&	\xrightarrow[~~\Input~~]{k_1} 
		\langle \StateP_1' \rangle ~ \thread{1}:\body{1}'						\\
		%
		\tag{H2}
		\label{forec_proofs:H2}
		\langle \StateP_2 \rangle ~ \thread{2}:\body{2}
		&	\xrightarrow[~~\Input~~]{k_2} 
		\langle \StateP_2' \rangle ~ \thread{2}:\body{2}'
	\end{align*}
	Next, we show that the remaining sequence operator (\verb$;$), 
	\verb$abort$, and \verb$par$ kernel statements have at least one transition.
	\begin{enumerate}
		\item Consider $\thread{1}: \body{1}\mathtt{;}~\body{2}$. 
			  Due to the induction hypotheses, the table below shows that at least one
			  sequence rule can be applied to all possible completion codes $k_1$
			  of the first program fragment \body{1}. Note that the sequence rules
			  do not consider the completion code $k_2$ of the second program fragment 
			  \body{2}:
			  \begin{center}
			  	\def\arraystretch{1.3}
				\begin{tabular}{| c | c | c |}
					\hline
					\multicolumn{3}{| c |}{\boldmath$k_1$}										\\ 
					~~~~~\textbf{0}~~~~~	& ~~~~~\textbf{1}~~~~~	& ~~~~~\boldmath$\bot$~~~~~	\\ \hline 
					(\ref{forec:seq-right})	& \multicolumn{2}{c|}{(\ref{forec:seq-left})}		\\
					\hline
				\end{tabular}
			  \end{center}
			  If $k_1 = 0$ and the premise is true by the induction 
			  hypothesis~(\ref{forec_proofs:H1}), then from the (\ref{forec:seq-right}) 
			  rule we have:
			  \begin{prooftree}
			  			\AxiomC{$\langle \StateP_1 \rangle ~ \thread{1}:\body{1}
									\xrightarrow[~~\Input~~]{k_1 = 0}
								\langle \StateP_1' \rangle ~ \thread{1}:$}
					\LeftLabel{(\ref{forec:seq-right})}
					\UnaryInfC{$\langle \StateP_1 \rangle ~ \thread{1}: \body{1}\mathtt{;}~\body{2}
									\xrightarrow[~~\Input~~]{\bot} 
								\langle \StateP_1' \rangle ~ \thread{1}: \body{2}$}
			  \end{prooftree}
			  If $k_1 \in \lbrace 1, \bot \rbrace$ and the premise is true by the 
			  induction hypothesis~(\ref{forec_proofs:H1}), then from the (\ref{forec:seq-left}) 
			  rule we have:
			  \begin{prooftree}
			  			\AxiomC{$\langle \StateP_1 \rangle ~ \thread{1}:\body{1}
									\xrightarrow[~~\Input~~]{k_1 \in \lbrace 1, \bot \rbrace}
								\langle \StateP_1' \rangle ~ \thread{1}:\body{1}'$}
					\LeftLabel{(\ref{forec:seq-left})}
					\UnaryInfC{$\langle \StateP_1 \rangle ~ \thread{1}: \body{1}\mathtt{;}~\body{2}
									\xrightarrow[~~\Input~~]{k_1} 
								\langle \StateP_1' \rangle ~ \thread{1}: \body{1}'\mathtt{;}~\body{2}$}
			  \end{prooftree}
			  Thus, any sequential composition of reactive programs has at least one 
			  transition and is, therefore, reactive.
			  
		\item Consider $\thread{1}: \mathtt{weak}?~\mathtt{abort}(a_1, \body{1})$. 
			  Due to the induction hypotheses, the table below shows that at least one 
			  \verb$abort$ rule can be applied to every combination of $k_1$ and 
			  preemption status $\Abort[a_1]$:
			  \begin{center}
			  	\def\arraystretch{1.3}
				\begin{tabular}{| c c | c | c | c | c | c | c |}
					\cline{3-8}
					\multicolumn{2}{c|}{}										& \multicolumn{3}{c |}{\textbf{Strong \texttt{abort},} \boldmath$k_1$} 								& \multicolumn{3}{c |}{\textbf{Weak \texttt{abort},} \boldmath$k_1$}	\\ 
					\multicolumn{2}{c|}{}										& ~~~~~\textbf{0}~~~~~	& ~~~~~\textbf{1}~~~~~							& ~~~~~\boldmath$\bot$~~~~~	& ~~~~~\textbf{0}~~~~~	& ~~~~~\textbf{1}~~~~~	& \boldmath$\bot$		\\ \hline 
					\multirow{2}{*}{\boldmath$\Abort[a_1]$}	& \boldmath$= 0$	& (\ref{forec:abort-2})	& \multicolumn{2}{c|}{(\ref{forec:abort-1})}								& (\ref{forec:abort-2})	& \multicolumn{2}{c|}{(\ref{forec:abort-1})}	\\ \cline{2-8}
															& \boldmath$\neq 0$	& \multicolumn{3}{c|}{(\ref{forec:abort-6})}														& (\ref{forec:abort-3})	& (\ref{forec:abort-5})	& (\ref{forec:abort-4})	\\
					\hline
				\end{tabular}
			  \end{center}
			  For example, if $k_1 = 0$ and $\Abort[a_1] = 0$ and the premise is true by 
			  the induction hypothesis~(\ref{forec_proofs:H1}), then from the (\ref{forec:abort-2}) rule
			  we have:
			  \begin{prooftree}
			  			\AxiomC{$\langle \StateP_1 \rangle ~ \thread{1}:\body{1}
									\xrightarrow[~~\Input~~]{k_1 = 0} 
								\langle \StateP_1' \rangle ~ \thread{1}:$}
					\LeftLabel{(\ref{forec:abort-2})}\RightLabel{$(\Abort[a_1] = 0)$}
					\UnaryInfC{$\langle \StateP_1 \rangle ~ \thread{1}: \mathtt{weak}?~\mathtt{abort}(a_1, \body{1})
									\xrightarrow[~~\Input~~]{0} 
								\langle \StateP_1' \rangle ~ \thread{1}:$}
			  \end{prooftree}
			  The other cases are similar. Thus, any preemptive composition of reactive programs 
			  has at least one transition and is, therefore, reactive.

		\item Consider $\thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})$.
			  Due to the induction hypotheses, the table below shows that at least one
			  \verb$par$ rule can be applied to every combination of $k_1$ and $k_2$:
			  \begin{center}
			  	\def\arraystretch{1.3}
				\begin{tabular}{| c c | c | c | c |}
					\cline{3-5}
					\multicolumn{2}{c|}{}				& \multicolumn{3}{c |}{\boldmath$k_2$}													\\ 
					\multicolumn{2}{c|}{}				& \textbf{0}			& \textbf{1}			& \boldmath$\bot$						\\ \hline 
									& \textbf{0}		& (\ref{forec:par-5})	& (\ref{forec:par-6})	& \multirow{2}{*}{(\ref{forec:par-2})}	\\ \cline{2-4}
					\boldmath$k_1$	& \textbf{1}		& (\ref{forec:par-7})	& (\ref{forec:par-4})	&										\\ \cline{2-5}
									& \boldmath$\bot$	& \multicolumn{2}{c|}{(\ref{forec:par-3})}		& (\ref{forec:par-1})					\\
					\hline
				\end{tabular}
			  \end{center}
			  For example, if $k_1 = 0$ and $k_2 = 0$ and the premise is true by 
			  the induction hypotheses~(\ref{forec_proofs:H1}) and (\ref{forec_proofs:H2}), 
			  then from the (\ref{forec:par-5}) rule we have:
			  \begin{prooftree}
			  			\AxiomC{$\langle \StateP \rangle ~ \thread{1}:\body{1}
									\xrightarrow[~~\Input~~]{k_1 = 0} 
								\langle \StateP_1' \rangle ~ \thread{1}:
								\qquad\qquad
								\langle \StateP \rangle ~ \thread{2}:\body{2}
									\xrightarrow[~~\Input~~]{k_2 = 0} 
								\langle \StateP_2' \rangle ~ \thread{2}:$}
					\LeftLabel{(\ref{forec:par-5})}
					\UnaryInfC{$\langle \StateP \rangle ~ \thread{}: \mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})
									\xrightarrow[~~\Input~~]{\bot} 
								\langle \StateP'' \rangle ~ \thread{}: \mathtt{copy}$}
			  \end{prooftree}
			  The other cases are similar. Thus, any parallel composition of reactive 
			  programs has at least one transition and is, therefore, reactive.
	\end{enumerate}
\end{proof}

\begin{definition}
	\label{def:deterministic}
	A program $\thread{}:\body{}$ is \emph{\textbf{deterministic}} if, 
	in any state \StateP{}, for any input configuration~\Input{}, there 
	exists at most one transition such that:
	\begin{align*}
		\forall \StateP, \Input: \quad
		\text{if} \quad
		\langle \StateP \rangle ~ \thread{}:\body{} 
		&	\xrightarrow[~~\Input~~]{k'} 
		\langle \StateP'~ \rangle ~ \thread{}:\body{}'	\\
		\text{and} \quad
		\langle \StateP \rangle ~ \thread{}:\body{} 
		&	\xrightarrow[~~\Input~~]{k''} 
		\langle \StateP'' \rangle ~ \thread{}:\body{}''
		\quad \text{then} \quad 
		\StateP' = \StateP'', ~ \body{}' = \body{}'', ~ k' = k''
	\end{align*}
\end{definition}
Only the rewrite rules of the \verb$par$ statement allow state 
\StateP{} to be changed in parallel by multiple transitions. The
(\ref{forec:par-1}) rule aggregates the changes into a
single state. The (\ref{forec:par-4}), (\ref{forec:par-5}),
(\ref{forec:par-6}), and (\ref{forec:par-7}) rules use the
semantic function $\Combine$ (Algorithm~\ref{algo:Combine})
to combine the copies in the aggregated state. The
(\ref{forec:par-2}) and (\ref{forec:par-3}) rules only allow
one of the changed states to take effect. Before proving
that all ForeC programs are deterministic, we prove that the
aggregation of states and the semantic function $\Combine$
are both deterministic. This is captured by
Lemmas~\ref{lem:aggregation} and \ref{lem:Combine} below
with the assumption that all the combine functions are
deterministic.

\begin{definition}
	\label{def:combine}
	A combine function $cf$ is any C function with two input
	values~$\val_1$ and $\val_2$ of identical type, which
	returns a value of the same type.
\end{definition}

\begin{hypothesis} 
	\label{hyp:combine}
	Each combine function $cf$ always returns the same value regardless
	of the current state, provided that the input values, $\val_1$
	and $\val_2$, are identical:
%
	\begin{align*}
		\forall \StateP, \StateP', \Input, \thread{},& \val_1, \val_2:	\\
		\qquad \qquad
		& \Eval(\StateP.\Environment, \Input, \thread{}, cf(\val_1, \val_2)) = \Eval(\StateP'.\Environment, \Input, \thread{}, cf(\val_1, \val_2))
	\end{align*}
%
	Because the combine functions are defined in~C, we require that the
	combine functions always terminate without error.\end{hypothesis}

\begin{lemma}
	\label{lem:aggregation}
	For any initial state\footnotemark[7] $\StateP = \langle \Environment, \Abort \rangle$, 
	let $\StateP' = \langle \Environment', \Abort' \rangle$ and 
	$\StateP'' = \langle \Environment'', \Abort'' \rangle$ be the states
	of two threads after their transition.
	If the threads can only change their own private variables and 
	copies of shared variables, then the aggregation of 
	$\StateP'$ and $\StateP''$ is \emph{\textbf{deterministic}} 
	if there exists only one aggregated state:
	\begin{align*}
		\forall \StateP = \langle \Environment, \Abort \rangle,& 
				\StateP' = \langle \Environment', \Abort' \rangle,
				\StateP'' = \langle \Environment'', \Abort'' \rangle:	\\
		\text{if} \quad
		\Environment_1^A &= \left ( \Environment' \setminus (\Environment' \cap \Environment) \right ) \cup \left ( \Environment'' \setminus (\Environment'' \cap \Environment) \right ) \cup \left ( \Environment' \cap \Environment'' \right )			\\
		\text{and} \quad
		\Environment_2^A &= \left ( \Environment' \setminus (\Environment' \cap \Environment) \right ) \cup \left ( \Environment'' \setminus (\Environment'' \cap \Environment) \right ) \cup \left ( \Environment' \cap \Environment'' \right )
		\quad \text{then} \quad \Environment_1^A = \Environment_2^A	\\
		\text{if} \quad
		\Abort_1^A &= \left ( \Abort' \setminus (\Abort' \cap \Abort) \right ) \cup \left ( \Abort'' \setminus (\Abort'' \cap \Abort) \right ) \cup \left ( \Abort' \cap \Abort'' \right )	\\
		\text{and} \quad
		\Abort_2^A &= \left ( \Abort' \setminus (\Abort' \cap \Abort) \right ) \cup \left ( \Abort'' \setminus (\Abort'' \cap \Abort) \right ) \cup \left ( \Abort' \cap \Abort'' \right )
		\quad \text{then} \quad \Abort_1^A = \Abort_2^A
	\end{align*}
\end{lemma}
\footnotetext[7]{Recall from
Section~\ref{sec:forec_semantics:notation} that
\Environment{} maps the global and thread scopes to their
own store of variables, $\Environment: \Id \hookrightarrow
\Store$. Variables are mapped to a value and status,
$\Store: \Var \hookrightarrow (\Val, \Sts)$. The notation $\Environment[\thread{}][\var]$
looks up the value and status $(\val, \sts)$ of thread
\thread{}'s copy of \var{}. Recall that \Abort{} maps the \texttt{abort} 
identifiers to their preemption statuses, $\Abort: \mathcal{A} \to Val$. 
The notation $\Abort[a]$ looks up the preemption status \val{}
of \texttt{abort} $a$.}
\begin{proof}
	We begin by proving that the aggregation of environments $\Environment'$
	and $\Environment''$ is deterministic.
	If the threads can only change their private variables and 
	copies of shared variables, then their changes to \Environment{}
	are always mutually exclusive. That is, for any two threads 
	$\thread{}'$ and $\thread{}''$, where $\thread{}' \neq \thread{}''$, 
	the threads never access each other's store because
	$\Environment[\thread{}'] \neq \Environment[\thread{}'']$. 
	Moreover, by definition, the threads never access each other's private variables
	in $\Environment[\Global]$. Intersecting 
	two environments, e.g., $\Environment' \cap \Environment$, always gives 
	a new environment containing the variables that have the same values and 
	statuses in $\Environment'$ and $\Environment$, i.e., have not changed. 
	$\Environment' \setminus (\Environment' \cap \Environment)$ always
	gives a new environment containing the variables that have changed in 
	$\Environment'$. Operations on sets are deterministic because two
	variables are either identical or not.
	The aggregation always takes the union of the changes in $\Environment'$ (i.e., 
	$\Environment' \setminus (\Environment' \cap \Environment)$) 
	and in $\Environment''$ (i.e., 
	$\Environment'' \setminus (\Environment'' \cap \Environment)$) 
	with the unchanged variables in $\Environment'$ and $\Environment''$
	(i.e., $\Environment' \cap \Environment''$). 
	Because the changes in $\Environment'$ and $\Environment''$ are always 
	mutually exclusive, the aggregation always takes the union of three disjoint
	environments.
	
	We now prove that the aggregation of two sets of preemption statuses $\Abort'$
	and $\Abort''$ is deterministic. Threads can only change \Abort{} by 
	executing a \verb$status$ statement (the (\ref{forec:status}) 
	rule). By construction, each \verb$status$ statement has 
	a unique \verb$abort$ identifier $a$. Thus, changes to 
	\Abort{} are always mutually exclusive. 
	Intersecting two sets of preemption statuses, e.g., $\Abort' \cap \Abort$, always gives 
	a new set containing the statuses that have the same values in 
	$\Abort'$ and $\Abort$, i.e., have not changed. 
	$\Abort' \setminus (\Abort' \cap \Abort)$ always
	gives a new set containing the statuses that have changed in 
	$\Abort'$. Operations on sets are deterministic because two
	statuses are either identical or not.
	The aggregation always takes the union of the changes in $\Abort'$ (i.e., 
	$\Abort' \setminus (\Abort' \cap \Abort)$) 
	and in $\Abort''$ (i.e., 
	$\Abort'' \setminus (\Abort'' \cap \Abort)$) 
	with the unchanged statuses in $\Abort'$ and $\Abort''$
	(i.e., $\Abort' \cap \Abort''$). 
	Because the changes in $\Abort'$ and $\Abort''$ are always 
	mutually exclusive, the aggregation always takes the union of three disjoint 
	sets.
\end{proof}

\begin{lemma}
	\label{lem:Combine}
	If all combine functions are deterministic, then
	the semantic function $\Combine$ is \emph{\textbf{deterministic}} if, 
	in any state $S = \langle \Environment, \Abort \rangle$, for any three 
	threads \thread{1}, \thread{2}, and \thread{0}, there exists only 
	one environment that can be returned:
	\begin{align*}
		\forall \StateP = \langle \Environment, \Abort \rangle,  \forall \thread{1}, \thread{2}, \thread{0}: \quad
		\text{if}  \quad \Environment'~ &= \Combine(\Environment, \thread{1}, \thread{2}, \thread{0})	\\
		\text{and} \quad \Environment'' &= \Combine(\Environment, \thread{1}, \thread{2}, \thread{0})
		\quad \text{then} \quad \Environment' = \Environment''
	\end{align*}
\end{lemma}
\begin{proof}
%	We show that the semantic function $\Combine$ is deterministic
%	by showing that Algorithm~\ref{algo:Combine} is deterministic.
%	The algorithm consists of a single loop (line~\ref{algo:Combine_for}) 
%	that iterates through all the shared variables \var{} in the program, 
%	returned by $\GetShared(\Global)$. For a given environment~\Environment{}, 
%	$\GetShared(\Global)$ always returns the same set of shared variables. 
%	Line~\ref{algo:Combine_pre} gets the only \verb$orig$ value of the 
%	shared variable \var{} and line~\ref{algo:Combine_default} gets all
%	the threads (out of \thread{1} and \thread{2}) that have a copy of \var{}. Each shared variable is 
%	associated with exactly one combine policy: \verb$all$, \verb$new$, 
%	or \verb$mod$. Thus, if its policy is \verb$all$, 
%	then the algorithm skips to line~\ref{algo:Combine_if}. If its policy 
%	is \verb$new$, then line~\ref{algo:Combine_new} is performed before 
%	skipping to line~\ref{algo:Combine_if}. If its policy is \verb$mod$, then 
%	line~\ref{algo:Combine_mod} is performed before skipping to 
%	line~\ref{algo:Combine_if}. For a given \Environment{}, only
%	a unique set of threads \Thread{} can be built for 
%	lines~\ref{algo:Combine_default}, \ref{algo:Combine_new}, and 
%	\ref{algo:Combine_mod}. 
%	
%	When the algorithm reaches 
%	line~\ref{algo:Combine_if}, the number of threads in \Thread{} is 
%	either zero, one, or two. If there are zero threads, then the 
%	algorithm skips to line~\ref{algo:Combine_for_end} and the 
%	iteration ends. If there is one thread, then line~\ref{algo:Combine_assign1}
%	is performed to assign that thread's copy of \var{} to thread 
%	\thread{0}'s copy. The algorithm then skips to line~\ref{algo:Combine_for_end} 
%	and the iteration ends. If there are two threads, then 
%	lines~\ref{algo:Combine_c}--\ref{algo:Combine_assign2} are performed.
%	Line~\ref{algo:Combine_c} retrieves the unique combine function $cf$
%	for the shared variable \var{}. Line~\ref{algo:Combine_combine}
%	uses the combine function to return the only possible combined value
%	(by Definition~\ref{def:combine}).
%	Line~\ref{algo:Combine_assign2} assigns the combined value to 
%	thread \thread{0}'s copy of \var{}. The algorithm then skips to 
%	line~\ref{algo:Combine_for_end} and the iteration ends.
%	
%	When all the shared 
%	variables have been considered, the loop terminates and 
%	line~\ref{algo:Combine_return} returns the updated environment
%	without the stores of threads \thread{1} and \thread{2}.
%	Notice that the actions performed in each iteration of the loop 
%	(line~\ref{algo:Combine_for}) are completely independent of 
%	other iterations. For any 
%	environment \Environment{} and threads \thread{1}, \thread{2},
%	and \thread{0}, we have shown that each line of the algorithm 
%	has exactly one outcome, leading to exactly one possible 
%	environment being returned. Hence, the semantic function $\Combine$ 
%	is deterministic.
	The semantic function $\Combine$ is an algorithm that 
	intializes all its local variables (\texttt{preVal}, \Thread{}, $cf$, \val{}), 
	that is side-effect-free, and that uses only deterministic instructions. 
	In particular, line~\ref{algo:Combine_combine} in Algorithm~\ref{algo:Combine} 
	is deterministic due to the hypothesis that all combine functions~$cf$ are 
	deterministic (Hypothesis~\ref{hyp:combine}).
	Hence, the semantic function $\Combine$ is deterministic.
\end{proof}

\begin{theorem}
	\label{thm:deterministic}
	If all combine functions are deterministic, then
	all ForeC programs are \emph{\textbf{deterministic}}. 
\end{theorem}
\begin{proof}
	The proof can be shown by a structural induction on $\thread{}:\body{}$.
	
	\textbf{Base cases:}
	The (\ref{forec:nop}), (\ref{forec:copy}), (\ref{forec:pause}), 
	and (\ref{forec:status}) rules imply that the following kernel 
	statements have at most one transition:
	\begin{align*}
		\langle \StateP \rangle ~ \thread{}:\mathtt{nop}
		&	\xrightarrow[~~\Input~~]{0} 
		\langle \StateP \rangle ~ \thread{}:									\\
		%
		\langle \StateP \rangle ~ \thread{}:\mathtt{copy}
		&	\xrightarrow[~~\Input~~]{0} 
		\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}						\\
		%
		\langle \StateP \rangle ~ \thread{}:\mathtt{pause}
		&	\xrightarrow[~~\Input~~]{1} 
		\langle \StateP \rangle ~ \thread{}:\mathtt{copy}						\\
		%
		\langle \StateP \rangle ~ \thread{}:\mathtt{status}(a, \expression)
		&	\xrightarrow[~~\Input~~]{0} 
		\langle \StateP' \rangle ~ \thread{}:\mathtt{nop}
	\end{align*}
	The assignment, \verb$if$--\verb$else$, and \verb$while$ kernel constructs 
	are each described by a pair of rewrite rules with complementary premises that 
	do not depend on other transitions: (\ref{forec:assign-shared}) and 
	(\ref{forec:assign-private}), (\ref{forec:if-then}) and (\ref{forec:if-else}), 
	and (\ref{forec:loop-then}) and (\ref{forec:loop-else}).
	The premises are complementary in the sense that, if the premise of one rule is \emph{true}, 
	then the premise of the other rule must be \emph{false}, and vice versa. 
	This implies that these kernel constructs have at most one transition:
	\begin{align*}
		\text{if } \var \in \GetShared(\thread{}) \text{ then} \quad &
		\langle \StateP \rangle ~ \thread{}:\var \mathtt{=} \expression
			\xrightarrow[~~\Input~~]{0} 
		\langle \StateP' \rangle ~ \thread{}:									\\
		\text{otherwise} \quad &
		\langle \StateP \rangle ~ \thread{}:\var \mathtt{=} \expression
			\xrightarrow[~~\Input~~]{0} 
		\langle \StateP'' \rangle ~ \thread{}:									\\
		%
		\text{if } \Eval(\StateP.\Environment, \Input, \thread{}, \expression) \neq 0 \text{ then} \quad &
		\langle \StateP \rangle ~ \thread{}:\mathtt{if}~(\expression)~\body{1}~\mathtt{else}~\body{2}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \StateP \rangle ~ \thread{}:\body{1}							\\
		\text{otherwise} \quad &
		\langle \StateP \rangle ~ \thread{}:\mathtt{if}~(\expression)~\body{1}~\mathtt{else}~\body{2}
			\xrightarrow[~~\Input~~]{\bot} 
		\langle \StateP \rangle ~ \thread{}:\body{2}							\\
		%
		\text{if } \Eval(\StateP.\Environment, \Input, \thread{}, \expression) \neq 0 \text{ then} \quad &
		\langle \StateP \rangle ~ \thread{}:\mathtt{while}~(\expression)~\body{}
			\xrightarrow[~~\Input~~]{\bot}
		\langle \StateP \rangle ~ \thread{}:\body{};~\mathtt{while}~(\expression)~\body{}	\\
		\text{otherwise} \quad &
		\langle \StateP \rangle ~ \thread{}:\mathtt{while}~(\expression)~\body{}
			\xrightarrow[~~\Input~~]{0}
		\langle \StateP \rangle ~ \thread{}:
	\end{align*}
	Of the rewrite rules considered in the base case, only the (\ref{forec:copy}),
	(\ref{forec:status}), (\ref{forec:assign-shared}), and (\ref{forec:assign-private})
	rules make direct changes to state \StateP{}. The (\ref{forec:copy}) rule 
	changes only the store $\Environment[\thread{}]$ of the executing thread 
	\thread{}. This can be verified by inspecting Algorithm~\ref{algo:Copy} of the 
	semantic function $\Copy$. By construction, each \verb$status$ statement has a 
	unique \verb$abort$ identifier $a$. Thus, the (\ref{forec:status}) rule never
	changes the status of the same \verb$abort$ identifier. The 
	(\ref{forec:assign-shared}) rule changes only the store 
	$\Environment[\thread{}]$ of the executing thread \thread{}. The 
	(\ref{forec:assign-private}) rule changes only the private variables in 
	$\Environment[\Global]$ of the executing thread.

	\textbf{Induction step:}
	The sequence operator (\verb$;$), \verb$abort$, and \verb$par$ 
	kernel statements allow the composition of kernel constructs.
	For some $\thread{1}:\body{1}$ and $\thread{2}:\body{2}$ that 
	are arbitrary compositions of kernel constructs, assume the 
	induction hypotheses that they each have at most one transition:
	\begin{align*}
		\text{If} \quad \exists \StateP_1', \StateP_1'', \body{1}', \body{1}'', k_1', k_1''
		\quad \text{such that} \quad
		&
		\tag{H3}
		\label{forec_proofs:H3}
		\langle \StateP_1 \rangle ~ \thread{1}:\body{1} 
			\xrightarrow[~~\Input~~]{k_1'} 
		\langle \StateP_1' \rangle ~ \thread{1}:\body{1}'					\\
		%
		\text{and} \quad
		&
		\langle \StateP_1 \rangle ~ \thread{1}:\body{1} 
			\xrightarrow[~~\Input~~]{k_1''} 
		\langle \StateP_1'' \rangle ~ \thread{1}:\body{1}''					\\
		%
		\text{then} \quad 
		&
		\StateP_1' = \StateP_1'', ~ \body{1}' = \body{1}'', ~ k_1' = k_1''
	\end{align*}
	\begin{align*}
		\text{If} \quad \exists \StateP_2', \StateP_2'', \body{2}', \body{2}'', k_2', k_2''
		\quad \text{such that} \quad
		&
		\tag{H4}
		\label{forec_proofs:H4}
		\langle \StateP_2 \rangle ~ \thread{2}:\body{2} 
			\xrightarrow[~~\Input~~]{k_2'} 
		\langle \StateP_2' \rangle ~ \thread{2}:\body{2}'				\\
		%
		\text{and} \quad
		&
		\langle \StateP_2 \rangle ~ \thread{2}:\body{2} 
			\xrightarrow[~~\Input~~]{k''} 
		\langle \StateP_2'' \rangle ~ \thread{2}:\body{2}''				\\
		%
		\text{then} \quad 
		&
		\StateP_2' = \StateP_2'', ~ \body{2}' = \body{2}'', ~ k_2' = k_2''
	\end{align*}
	Next, we show that the sequence operator (\verb$;$), and the 
	\verb$abort$ and \verb$par$ kernel statements have at most one transition.
	\begin{enumerate}
		\item Consider the fragment $\thread{1}:\body{1};~\body{2}$. 
			  Due to the induction hypothesis~(\ref{forec_proofs:H3}), there is only
			  one possible transition for the fragment $\thread{1}:\body{1}$,
			  \begin{align*}
			  	  \text{which is either} \quad
				  \langle \StateP_1 \rangle ~ \thread{1}:\body{1} 
				  &	\xrightarrow[~~\Input~~]{k_1 = 0} 
				  \langle \StateP_1' \rangle ~ \thread{1}:			\\
				  %
				  \text{or} \quad
				  \langle \StateP_1 \rangle ~ \thread{1}:\body{1} 
				  &	\xrightarrow[~~\Input~~]{k_1 \in \lbrace 1, \bot \rbrace} 
				  \langle \StateP_1' \rangle ~ \thread{1}:\body{1}'
			  \end{align*}
			  The table below shows that at most one sequence rule can be 
			  applied depending on the completion code $k_1$:
			  \begin{center}
			  	\def\arraystretch{1.3}
				\begin{tabular}{| c | c | c |}
					\hline
					\multicolumn{3}{| c |}{\boldmath$k_1$}										\\ 
					~~~~~\textbf{0}~~~~~	& ~~~~~\textbf{1}~~~~~	& ~~~~~\boldmath$\bot$~~~~~	\\ \hline 
					(\ref{forec:seq-right})	& \multicolumn{2}{c|}{(\ref{forec:seq-left})}		\\
					\hline
				\end{tabular}
			  \end{center}
			  So, thanks to the induction hypothesis~(\ref{forec_proofs:H3}), 
			  the sequence operator ``\texttt{;}'' is deterministic.
			  
		\item Consider the \texttt{abort} kernel statement in the fragment
			  $\thread{1}: \mathtt{weak}?~\mathtt{abort}(a_1, \body{1})$.
			  Due to the induction hypothesis~(\ref{forec_proofs:H3}), there is only
			  one possible transition for the program fragment $\thread{1}:\body{1}$,
			  \begin{align*}
			  	  \text{which is either} \quad
				  \langle \StateP_1 \rangle ~ \thread{1}:\body{1} 
				  &	\xrightarrow[~~\Input~~]{k_1 = 0} 
				  \langle \StateP_1' \rangle ~ \thread{1}:			\\
				  %
				  \text{or} \quad
				  \langle \StateP_1 \rangle ~ \thread{1}:\body{1} 
				  &	\xrightarrow[~~\Input~~]{k_1 \in \lbrace 1, \bot \rbrace} 
				  \langle \StateP_1' \rangle ~ \thread{1}:\body{1}'
			  \end{align*}
			  The table below shows that at most one \texttt{abort} rule can be 
			  applied depending on the completion code $k_1$ and the 
			  preemption status $\Abort[a_1]$:
			  \begin{center}
				\def\arraystretch{1.3}
				\begin{tabular}{| c c | c | c | c | c | c | c |}
					\cline{3-8}
					\multicolumn{2}{c|}{}										& \multicolumn{3}{c |}{\textbf{Strong \texttt{abort},} \boldmath$k_1$} 								& \multicolumn{3}{c |}{\textbf{Weak \texttt{abort},} \boldmath$k_1$}	\\ 
					\multicolumn{2}{c|}{}										& ~~~~~\textbf{0}~~~~~	& ~~~~~\textbf{1}~~~~~							& ~~~~~\boldmath$\bot$~~~~~	& ~~~~~\textbf{0}~~~~~	& ~~~~~\textbf{1}~~~~~	& \boldmath$\bot$		\\ \hline 
					\multirow{2}{*}{\boldmath$\Abort[a_1]$}	& \boldmath$= 0$	& (\ref{forec:abort-2})	& \multicolumn{2}{c|}{(\ref{forec:abort-1})}								& (\ref{forec:abort-2})	& \multicolumn{2}{c|}{(\ref{forec:abort-1})}	\\ \cline{2-8}
															& \boldmath$\neq 0$	& \multicolumn{3}{c|}{(\ref{forec:abort-6})}														& (\ref{forec:abort-3})	& (\ref{forec:abort-5})	& (\ref{forec:abort-4})	\\
					\hline
				\end{tabular}
			  \end{center}
			  So, thanks to the induction hypothesis~(\ref{forec_proofs:H3}), 
			  the \texttt{abort} kernel statement is deterministic.
 
 		\item Consider the \texttt{par} kernel statement in the fragment
 			  $\thread{}:\mathtt{par}(\thread{1}:\body{1},~\thread{2}:\body{2})$.
 			  Due to the induction hypotheses~(\ref{forec_proofs:H3}) and (\ref{forec_proofs:H4}), 
 			  there is only one possible transition for the program fragment $\thread{1}:\body{1}$,
			  \begin{align*}
			  	  \text{which is either} \quad
				  \langle \StateP_1 \rangle ~ \thread{1}:\body{1} 
				  &	\xrightarrow[~~\Input~~]{k_1 = 0} 
				  \langle \StateP_1' \rangle ~ \thread{1}:			\\
				  %
				  \text{or} \quad
				  \langle \StateP_1 \rangle ~ \thread{1}:\body{1} 
				  &	\xrightarrow[~~\Input~~]{k_1 \in \lbrace 1, \bot \rbrace} 
				  \langle \StateP_1' \rangle ~ \thread{1}:\body{1}'
			  \end{align*}
			  and there is only one possible transition for the program fragment $\thread{2}:\body{2}$, 
			  \begin{align*}
			  	  \text{which is either} \quad
				  \langle \StateP_2 \rangle ~ \thread{2}:\body{2} 
				  &	\xrightarrow[~~\Input~~]{k_2 = 0} 
				  \langle \StateP_2' \rangle ~ \thread{2}:			\\
				  %
				  \text{or} \quad
				  \langle \StateP_2 \rangle ~ \thread{2}:\body{2} 
				  &	\xrightarrow[~~\Input~~]{k_2 \in \lbrace 1, \bot \rbrace} 
				  \langle \StateP_2' \rangle ~ \thread{2}:\body{2}'
			  \end{align*}
			  The table below shows that at most one \texttt{par} rule can 
			  applied depending on the completion codes $k_1$ and $k_2$:
			  \begin{center}
				\def\arraystretch{1.3}
				\begin{tabular}{| c c | c | c | c |}
					\cline{3-5}
					\multicolumn{2}{c|}{}				& \multicolumn{3}{c |}{\boldmath$k_2$}													\\ 
					\multicolumn{2}{c|}{}				& \textbf{0}			& \textbf{1}			& \boldmath$\bot$						\\ \hline 
									& \textbf{0}		& (\ref{forec:par-5})	& (\ref{forec:par-6})	& \multirow{2}{*}{(\ref{forec:par-2})}	\\ \cline{2-4}
					\boldmath$k_1$	& \textbf{1}		& (\ref{forec:par-7})	& (\ref{forec:par-4})	&										\\ \cline{2-5}
									& \boldmath$\bot$	& \multicolumn{2}{c|}{(\ref{forec:par-3})}		& (\ref{forec:par-1})					\\
					\hline
				\end{tabular}
			  \end{center}
			  So, thanks to the induction hypotheses~(\ref{forec_proofs:H3}) and (\ref{forec_proofs:H4}), 
			  the \texttt{par} kernel statement is deterministic.
	\end{enumerate}
\end{proof}

%\begin{observation}
%	\label{obs:confluence}
%	The ForeC rewrite rules are \emph{\textbf{confluent}}. That is, if
%	\begin{align*}
%		\forall \StateP, \Input: \quad
%		\langle \StateP \rangle ~ \thread{}:\body{} 
%		&	\xrightarrow[~~\Input~~]{k_1}
%		\langle \StateP_1' \rangle ~ \thread{}:\body{1}'	\\
%		%
%		\quad \text{and} \quad
%		\langle \StateP \rangle ~ \thread{}:\body{} 
%		&	\xrightarrow[~~\Input~~]{k_2}
%		\langle \StateP_2' \rangle ~ \thread{}:\body{2}'
%	\end{align*}
%	then there exists $\StateP^*$, $\body{}^*$, and $k^*$ such that
%	\begin{align*}
%		\langle \StateP_1' \rangle ~ \thread{}:\body{1}'
%			\xrightarrow[~~\Input~~]{k_1'}
%		&	\dotsb
%			\xrightarrow[~~\Input~~]{k^*} 
%		\langle \StateP^* \rangle ~ \thread{}:\body{}^*	\\
%		%
%		\quad \text{and} \quad
%		\langle \StateP_2' \rangle ~ \thread{}:\body{2}'
%			\xrightarrow[~~\Input~~]{k_2'}
%		&	\dotsb
%			\xrightarrow[~~\Input~~]{k^*} 
%		\langle \StateP^* \rangle ~ \thread{}:\body{}^*
%	\end{align*}
%	From Theorems~\ref{thm:reactive} and \ref{thm:deterministic},
%	we know that $\langle \StateP \rangle ~ \thread{}:\body{}$ 
%	has exactly one possible transition. For the initial transitions 
%	$\langle \StateP \rangle ~ \thread{}:\body{} \xrightarrow[~~\Input~~]{k_1} \langle \StateP_1' \rangle ~ \thread{}:\body{1}'$
%	and
%	$\langle \StateP \rangle ~ \thread{}:\body{} \xrightarrow[~~\Input~~]{k_2} \langle \StateP_2' \rangle ~ \thread{}:\body{2}'$,
%	it must be that $\StateP_1' = \StateP_2'$, $\body{1}' = \body{2}'$, 
%	and $k_1 = k_2$. It follows that subsequent transitions of both
%	$\langle \StateP_1' \rangle ~ \thread{}:\body{1}'$ and 
%	$\langle \StateP_2' \rangle ~ \thread{}:\body{2}'$ must have
%	the same resulting state $\StateP^*$, program fragment $\body{}^*$, 
%	and completion code $k^*$.	
%\end{observation}

