\section{Shared Variables}
\setcounter{section}{1}
\label{sec:forec_combine}
This appendix describes how shared variables are passed by
value or by reference into functions, and how the combine policies and combine
functions work together to combine more than two copies of a
shared variable. We compare the behaviors of the combine
policies, \verb$all$, \verb$new$, and \verb$mod$, using an
illustrative example. We also provide additional examples of
combine functions for primitive C data types and for
programmer-specified data structures. 

\subsection{Passing Shared Variables by Value and by Reference}
\label{sec:forec_combine:passing}
Following the C convention, a function argument in ForeC can
be passed by value or by reference. An argument passed
by value can either be a shared or a private variable.
E.g., in Figure~\ref{fig:forec_combine:passing}, 
line~\ref{fig:forec_combine:passing_f_call} makes a
call to function \texttt{f} with the arguments \texttt{x} (a
shared variable) and \texttt{y} (a private variable).
Function \texttt{f} (line~\ref{fig:forec_combine:passing_f}) 
declares two variables \texttt{d} (a
private variable) and \texttt{e} (a shared variable) that
are initialized with the values $3$ (from \texttt{x}) and
$5$ (from \texttt{y}), respectively.

When passed by reference, the address
of the function's argument is copied into the function's parameter.
Changes made to the dereferenced parameter are made to
the argument. The syntax for a function parameter
that passes a shared variable by reference should begin with
``\texttt{shared}~\emph{data\_type}\texttt{*}~\emph{p}''. 
This follows the C convention for other type qualifiers such 
as ``\texttt{const}'', where ``\texttt{const~int*~p}''
declares a pointer \texttt{p} to a constant \texttt{int} variable.
E.g., in Figure~\ref{fig:forec_combine:passing} on 
line~\ref{fig:forec_combine:passing_g}, the parameter of
function \texttt{g} declares a pointer \texttt{p} to a shared 
\texttt{int} variable. On line~\ref{fig:forec_combine:passing_g_call}, 
the ``\texttt{\&}'' unary 
operator is used to pass the shared variable \texttt{x} by 
reference into \texttt{g}.

Just like ``\texttt{int~const*~p}'' declares a constant pointer 
\texttt{p} to an \texttt{int} variable, ``\texttt{int shared* p}''
declares a shared pointer \texttt{p} to an \texttt{int} variable. 
This means that the address stored in \texttt{p} is shared among 
multiple threads. The final possibility is ``\texttt{shared~int~shared*~p}'' 
which declares a shared pointer \texttt{p} to a shared \texttt{int} 
variable.

\begin{figure}
	\centering

	\begin{minipage}[b]{0.8\textwidth}
		\lstinputlisting[style=full]{./code/forec/combine/passing.c}
	\end{minipage}

	\caption{Example of passing a shared variable by value and by reference.}
	\label{fig:forec_combine:passing}
\end{figure}

\newpage


\subsection{Combining More Than Two Copies}
\label{sec:forec_combine:copies}
The ForeC program shown in
Figure~\ref{fig:forec_combine:multiple_forec} is used to
explain how multiple copies of a shared variable are
combined. The program's control-flow graph is shown in
Figure~\ref{fig:forec_combine:multiple_cfg}. The program has
a shared variable called \verb$s$ that uses the combine
function \verb$plus$. The initial value of \verb$s$ is $3$ 
for the program's first tick.
Figure~\ref{fig:forec:combine_copies} shows the copies of
\verb$s$ at the end of the first tick, organized by the
thread genealogy. Each node represents a thread and the 
current value of its local
copy, e.g., {\setlength{\fboxsep}{3pt}\fbox{main: 3}} means
that the \verb$main$ thread has a local copy 
of \texttt{s} with the value $3$.
Copies that were assigned a value during the tick have the
$\bullet$ symbol, e.g., 
{\setlength{\fboxsep}{3pt}\fbox{tA: 1$\bullet$}} means that 
thread \verb$tA$'s copy has been assigned the value $1$. 
Arrows are drawn from the 
child threads to their parents to show the thread genealogy.
Threads \texttt{tC} and \texttt{tD} create their copies
from \verb$tA$'s copy (see Section~\ref{sec:forec:shared_variables_copying}). 
Hence, the value of thread \verb$tC$'s 
copy is $1$. Threads \texttt{tE} and \texttt{tF} create
their copies from \texttt{tB}'s copy.

\begin{figure}
	\centering

	\subfloat[ForeC program.] {
		\begin{minipage}[b]{0.5\textwidth}
			\lstinputlisting[style=full]{./code/forec/combine/multiple.forec}
			\label{fig:forec_combine:multiple_forec}
		\end{minipage}
	}
	\hfill
	\subfloat[Control-flow graph.]{
		\includegraphics[width=0.45\columnwidth]{images/multiple_cfg}
		\label{fig:forec_combine:multiple_cfg}	
	}
	\caption{Example ForeC program.}
\end{figure}

\begin{figure}
	\centering

	\subfloat[The copies of \texttt{s} when tick 1 ends.]{
		\includegraphics[height=3cm]{images/combine}
		\label{fig:forec:combine_copies}	
	}
	\hfill
	\subfloat[Policy \texttt{all}.]{
		\includegraphics[height=3cm]{images/combine_all}
		\label{fig:forec:combine_all}	
	}

	\subfloat[Policy \texttt{new}.]{
		\includegraphics[height=3cm]{images/combine_new}
		\label{fig:forec:combine_new}	
	}
	\hspace{3.9cm}
	\subfloat[Policy \texttt{mod}.]{
		\includegraphics[height=3cm]{images/combine_mod}
		\label{fig:forec:combine_mod}	
	}
	\hspace{0.8cm}

	\caption{Effects of the combine policies.}
\end{figure}

The formal semantics of ForeC 
(Section~\ref{sec:forec_semantics}) defines how more than two
copies of a shared variable are combined. The 
copies from sibling threads (i.e., threads forked by 
the same \verb$par$ statement) are combined 
and the resulting combined value is assigned to their parent
thread. Then, the copies of the parent and its sibling 
are combined together and assigned to their parent. 
This continues until the \verb$main$ thread is reached.
Figure~\ref{fig:forec:combine_all} illustrates this
for the combine policy \verb$all$, where all the copies 
are combined. The final combined value is $11$ and
it is assigned to shared variable \verb$s$ to 
complete the global tick.

The combine policy \verb$new$ ignores the copies that have 
the same
value as their shared variable, which is not changed during 
the tick. For the copies shown
in Figure~\ref{fig:forec:combine_copies}, thread \verb$main$, \texttt{tB},
and \verb$tE$'s copies of \verb$s$ would be ignored.
Figure~\ref{fig:forec:combine_new} illustrates how the
copies are combined for the combine policy \verb$new$. Note
that thread \verb$tF$'s copy is assigned directly to
\verb$tB$ because its sibling's copy is ignored. The final
combined value is $8$.

For the combine policy \verb$mod$, the copies that have not
been assigned a value during the tick are ignored. For the
copies shown in Figure~\ref{fig:forec:combine_copies},
thread \verb$main$, \texttt{tB}, \verb$tC$, and \verb$tE$'s copies of 
\verb$s$ would be ignored.
Figure~\ref{fig:forec:combine_mod} illustrates how the
copies are combined for the combine policy \verb$mod$. The
final combined value is $7$.

%When combining two copies with a non-associative or
%non-commutative function (e.g., subtraction or division),
%the order that the copies are passed into the combine
%function can affect the results. To ensure deterministic
%combine behavior, a static order is used. The textual order
%that the child threads appear in their \verb$par$ statement
%is the order that their copies are passed into the combine
%function.


\subsection{Combine Policies Illustrated}
\label{sec:forec_combine:policies}
This section illustrates the behavior of the combine
policies \verb$all$, \verb$new$, and \verb$mod$ over
several ticks by using the example of
Figure~\ref{fig:forec_combine:button}.
Figure~\ref{fig:forec_combine:button_task} shows a block
diagram of the ForeC program of
Figure~\ref{fig:forec_combine:button_forec}. The
program outputs the number of times \texttt{button1} and
\texttt{button2} are pressed in each tick of the
program. On line~\ref{code:forec_combine:button_par} in
Figure~\ref{fig:forec_combine:button_forec}, threads
\verb$t1$ and \verb$t2$ are forked to check which 
buttons have been pressed. The results are assigned to the
shared variable \verb$count$.
Line~\ref{code:forec_combine:button_par} also forks thread
\verb$t3$ to read the value of \verb$count$ and to output it to
\verb$display$. Hence, three copies of \verb$count$ will be
created in each tick. The copies of
\verb$count$ are combined with the function \verb$plus$
(line~\ref{code:forec_combine:button_plus}) with 
the combine policy \texttt{mod}.
Figure~\ref{table:forec_combine:button_inputs} provides
possible input values for five ticks of the program.
For example, only \texttt{button1} is pressed in tick~$2$. 
Figure~\ref{table:forec_combine:button_mod}
shows the value of the shared variable
\texttt{count} and the value of each thread's local copy of \texttt{count}. 
The copies that were assigned a value during the
tick have the~$\bullet$ symbol. For tick~$1$, \texttt{count}~$= 0$, 
its initial value. From tick~$2$ 
onwards, the value of \texttt{count} corresponds to the number of 
button presses in the previous tick, because only
threads~\texttt{t1} and~\texttt{t2}'s modified copies are
combined.

Figure~\ref{table:forec_combine:button_new} illustrates the 
behavior of the combine policy \texttt{new} over several
ticks. The values of threads~\texttt{t1}, 
\texttt{t2}, and \texttt{t3}'s local copies 
are ignored when they have the same value as \texttt{count}.
Figure~\ref{table:forec_combine:button_all} illustrates the 
behavior of the combine policy \texttt{all} over several
ticks. In this case, threads~\texttt{t1}, \texttt{t2},
and \texttt{t3}'s local copies are always used
to compute the value of \texttt{count}. 
The value of \texttt{count} corresponds to the running
total of button presses, i.e., in tick~$6$ a total of four
button presses have occurred in previous ticks.

\begin{figure}
	\centering

	\subfloat[Button counter.]{
		\includegraphics[width=0.5\columnwidth]{images/button_task}
		\label{fig:forec_combine:button_task}	
	}

	\subfloat[ForeC program of the button counter.] {
		\begin{minipage}[b]{0.68\textwidth}
			\lstinputlisting[style=full]{./code/forec/combine/button.forec}
			\label{fig:forec_combine:button_forec}
		\end{minipage}
	}
	
	\caption{Example of counting the number of button inputs.}
	\label{fig:forec_combine:button}
\end{figure}

\begin{figure}
	\footnotesize

	\subfloat[Possible input values.] {
		\begin{tabular}{l c c c c c l}
											& \multicolumn{6}{c}{\textbf{Tick}}																\\ \cline{2-7}
											& \textbf{1}	& \textbf{2}	& \textbf{3}	& \textbf{4}	& \textbf{5}	& \textbf{6}	\\
			\hline
			\texttt{button1}				& 0				& 1				& 1				& 1				& 0				& $\dotsb$		\\
			\texttt{button2}				& 0				& 0				& 1				& 0				& 0				& $\dotsb$		\\
			\hline
																																			\\
																																			\\
		\end{tabular}
		\label{table:forec_combine:button_inputs}
	}
	\hfill
	\subfloat[Combine policy \texttt{mod}.] {
		\begin{tabular}{l c c c c c l}
									& \multicolumn{6}{c}{\textbf{Tick}}																\\ \cline{2-7}
			\textbf{\texttt{count}}	& \textbf{1}	& \textbf{2}	& \textbf{3}	& \textbf{4}	& \textbf{5}	& \textbf{6}	\\
			\hline
			\texttt{t1}'s copy		& 0$\bullet$	& 1$\bullet$	& 1$\bullet$	& 1$\bullet$	& 0$\bullet$	& $\dotsb$		\\
			\texttt{t2}'s copy		& 0$\bullet$	& 0$\bullet$	& 1$\bullet$	& 0$\bullet$	& 0$\bullet$	& $\dotsb$		\\
			\texttt{t3}'s copy		& 0~			& 0~			& 1~			& 2~			& 1~			& $\dotsb$		\\
			\hline
			\texttt{count}			& 0~			& 0~			& 1~			& 2~			& 1~			& 0				\\
			\hline
		\end{tabular}
		\label{table:forec_combine:button_mod}
	}
	
	\subfloat[Combine policy \texttt{new}.] {
		\begin{tabular}{l c c c c c l}
									& \multicolumn{6}{c}{\textbf{Tick}}																\\ \cline{2-7}
			\textbf{\texttt{count}}	& \textbf{1}	& \textbf{2}	& \textbf{3}	& \textbf{4}	& \textbf{5}	& \textbf{6}	\\
			\hline
			\texttt{t1}'s copy		& 0$\bullet$	& 1$\bullet$	& 1$\bullet$	& 1$\bullet$	& 0$\bullet$	& $\dotsb$		\\
			\texttt{t2}'s copy		& 0$\bullet$	& 0$\bullet$	& 1$\bullet$	& 0$\bullet$	& 0$\bullet$	& $\dotsb$		\\
			\texttt{t3}'s copy		& 0~			& 0~			& 1~			& 1~			& 0~			& $\dotsb$		\\
			\hline
			\texttt{count}			& 0~			& 0~			& 1~			& 1~			& 0~			& 0				\\
			\hline
		\end{tabular}
		\label{table:forec_combine:button_new}
	}
	\hfill
	\subfloat[Combine policy \texttt{all}.] {
		\begin{tabular}{l c c c c c l}
									& \multicolumn{6}{c}{\textbf{Tick}}																\\ \cline{2-7}
			\textbf{\texttt{count}}	& \textbf{1}	& \textbf{2}	& \textbf{3}	& \textbf{4}	& \textbf{5}	& \textbf{6}	\\
			\hline
			\texttt{t1}'s copy		& 0$\bullet$	& 1$\bullet$	& 1$\bullet$	& 1$\bullet$	& 0$\bullet$	& $\dotsb$		\\
			\texttt{t2}'s copy		& 0$\bullet$	& 0$\bullet$	& 1$\bullet$	& 0$\bullet$	& 0$\bullet$	& $\dotsb$		\\
			\texttt{t3}'s copy		& 0~			& 0~			& 1~			& 3~			& 4~			& $\dotsb$		\\
			\hline
			\texttt{count}			& 0~			& 0~			& 1~			& 3~			& 4~			& 4				\\
			\hline
		\end{tabular}
		\label{table:forec_combine:button_all}
	}

	\caption{The value of \texttt{count} under each combine policy.}
\end{figure}

\newpage


\subsection{Examples of Combine Functions}
\label{sec:forec_combine:functions}
The simplest combine functions are those based on the 
associative and commutative binary mathematical operators: 
\begin{itemize}
	\item Arithmetic addition (\texttt{+}) and multiplication (\texttt{*});
	\item Logical AND (\texttt{\&\&}) and OR (\texttt{||});
	\item Bitwise AND (\texttt{\&}) and OR (\texttt{|});
	\item Minimum and maximum using \texttt{if}--\texttt{else} statement.
\end{itemize}
The combine functions should be associative and commutative so 
as to make the \texttt{par} statement commutative and associative,
relying only on the nesting of binary \texttt{par} statements
to fork more than two child threads at the same time
(e.g., \texttt{par(par(t$_1$,t$_2$),t$_3$) = par(t$_1$,par(t$_2$,t$_3$))}). 
The programmer is free to write combine functions
based on non-commutative or non-associative binary operators
(e.g., \texttt{-}, \texttt{/}, or \texttt{\%}),
but this will violate the hypothesis of the theorem for determinism 
(Theorem~\ref{thm:deterministic}).

%\begin{figure}
%	\centering
%	
%	\subfloat[Minimum of two values.] {
%		\begin{minipage}[b]{0.44\textwidth}
%			\lstinputlisting[style=full]{./code/forec/combine/min.c}
%		\end{minipage}
%	}
%	\hfill
%	\subfloat[Maximum of two values.] {
%		\begin{minipage}[b]{0.44\textwidth}
%			\lstinputlisting[style=full]{./code/forec/combine/max.c}
%		\end{minipage}
%	}
%	
%	\subfloat[Addition of two values.] {
%		\begin{minipage}[b]{0.44\textwidth}
%			\lstinputlisting[style=full]{./code/forec/combine/add.c}
%		\end{minipage}
%	}
%	\hfill
%	\subfloat[Multiplication of two values.] {
%		\begin{minipage}[b]{0.44\textwidth}
%			\lstinputlisting[style=full]{./code/forec/combine/mul.c}
%		\end{minipage}
%	}
%
%	\subfloat[Bitwise AND of two values.] {
%		\begin{minipage}[b]{0.44\textwidth}
%			\lstinputlisting[style=full]{./code/forec/combine/band.c}
%		\end{minipage}
%	}
%	\hfill
%	\subfloat[Bitwise OR of two values.] {
%		\begin{minipage}[b]{0.44\textwidth}
%			\lstinputlisting[style=full]{./code/forec/combine/bor.c}
%		\end{minipage}
%	}
%
%	\subfloat[Logical AND of two values.] {
%		\begin{minipage}[b]{0.44\textwidth}
%			\lstinputlisting[style=full]{./code/forec/combine/land.c}
%		\end{minipage}
%	}
%	\hfill
%	\subfloat[Logical OR of two values.] {
%		\begin{minipage}[b]{0.44\textwidth}
%			\lstinputlisting[style=full]{./code/forec/combine/lor.c}
%		\end{minipage}
%	}
%
%	\caption{Examples of combine functions for primitive C data types.}
%	\label{fig:forec_combine:primative}
%\end{figure}

Combine functions can also be defined for 
user-defined data structures. For example,
Figure~\ref{fig:forec_combine:prodsum} defines a C-struct
called \verb$ProdSum$ that stores the product (\verb$prod$)
and sum (\verb$sum$) of the numbers assigned to it. The
combine function \verb$prodsum$ multiplies all the values in
\verb$prod$ and sums all the values in \verb$sum$. An
example of its behavior is provided after the function as
comments. 

For another example, line~\ref{code:mins:struct} of
Figure~\ref{fig:forec_combine:mins} defines a C-struct
called \texttt{Min} that stores an assigned value
(\verb$value$) and tracks the minimum value that has
been assigned (\verb$min$). The combine function
(line~\ref{code:mins:combine}) reads the 
\texttt{value}s and assigns the minimum 
value to \texttt{res.min}. The minimum value is also 
assigned to \texttt{res.value},
so that it will be read when it is combined with another copy.
An example of its behavior is provided after the function as
comments. Indeed, the combine function will only behave in
an associative and commutative manner if the threads only
write to \verb$value$ and do not read from it.

%Combine functions can use the \texttt{orig} 
%of a shared variable to perform computations that relate to 
%past values.

\begin{figure}
	\centering

	\subfloat[Product and sum of two values.] {
		\begin{minipage}[b]{0.9\textwidth}
			\lstinputlisting[style=full]{./code/forec/combine/prodsum.c}
			\label{fig:forec_combine:prodsum}
		\end{minipage}
	}
	
	\subfloat[Minimum of two values.] {
		\begin{minipage}[b]{0.9\textwidth}
			\lstinputlisting[style=full]{./code/forec/combine/mins.c}
			\label{fig:forec_combine:mins}
		\end{minipage}
	}

	\caption{Examples of combine functions for C-structs.}
\end{figure}

The behavior of combine functions can be extended with 
dedicated threads that perform additional computations on the 
combined values of one or more shared variables.
Figure~\ref{fig:forec_combine:plus2} is an example ForeC
program that calculates the average of three input
values \texttt{in[i]}, declared on line~\ref{code:forec_combine:plus2_in} 
in Figure~\ref{fig:forec_combine:plus2}. Line~\ref{code:forec_combine:plus2_par} 
forks three threads \texttt{f} (line~\ref{code:forec_combine:plus2_f}) 
to check the validity of each 
input. An input is valid if its value is greater than zero 
(line~\ref{code:forec_combine:plus2_valid}). In each tick, the threads 
assign valid inputs to their copy of the shared variable \texttt{val}.
The modified copies of \texttt{val} are combined with the 
combine function \texttt{sum} (line~\ref{code:forec_combine:plus2_sum}), 
which sums the input values and the number of valid inputs. 
The \texttt{average} thread (line~\ref{code:forec_combine:plus2_average}) 
reads the resulting combined value of \texttt{val} to calculate the 
average input value (line~\ref{code:forec_combine:plus2_average_val}).

\begin{figure}
	\centering

	\begin{minipage}[b]{0.8\textwidth}
		\lstinputlisting[style=full]{./code/forec/combine/plus2.forec}
		\label{fig:forec_combine:plus2}
	\end{minipage}
	
	\caption{Averaging two or more values.}
\end{figure}
