/* ----------------------------------------------------------------------------
 * SchedMCore - A MultiCore Scheduling Framework
 * Copyright (C) 2009-2010  ONERA
 * Copyright (C) 2009-2010  Frederic BONIOL, Mikel CORDOVILLA, Eric NOULARD, Claire PAGETTI
 * This file is part of SchedMCore
 *
 * SchedMCore is free software ; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation ; either version 2 of
 * the License, or (at your option) any later version.
 *
 * SchedMCore is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY ; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program ; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 *---------------------------------------------------------------------------- */

#include <stdio.h>
#include <stdlib.h>
#include "assemblage_includes.h"
/*
 * The following include file is generated by the Prelude compiler
 * Theoretically we should include main node specific include
 * i.e. assemblage_vX.h but we know that every main node
 * assemblage, assemblage_v2, assemblage_v3, etc... share the
 * very same data type.
 */
#include "assemblage.h"
#include "tilera_tools.h"

typedef enum NODE_RANK {
  AIRCRAFT_DYNAMICS, ALTITUDE_HOLD,
  H_FILTER, VZ_FILTER, VA_FILTER, VZ_CONTROL,
  ELEVATOR, ENGINE, Q_FILTER, AZ_FILTER, VA_CONTROL,
  DELTA_E_C, VA_C, DELTA_TH_C, H_C, 
  NODE_SIZE
} NodeRank_t;

#define MIN_VAL  0
#define MEAN_VAL 1
#define MAX_VAL  2

static uint64_t execTime[3][NODE_SIZE];
static const char * nodeNameTab[NODE_SIZE] =
  {
    "aircraft_dynamics", "altitude_hold",
    "h_filter", "Vz_filter", "Va_filter", "Vz_control",
    "elevator", "engine", "q_filter", "az_filter", "va_control",
    "delta_e_c", "Va_c", "delta_th_c", "h_c"
  };


int
main(int argc, const char * argv[]) {

    int i = 0;
    struct aircraft_dynamics_outs_t outputs;

    double h_c = 100;    /* inputs */
    double Va_c = -5.0;  /* inputs */
    double Va_meas;
    double Vz_meas;
    double q_meas;
    double az_meas;
    double h_meas;
    double delta_e,   T;
    double delta_e_c, delta_e_c_next;
    double Vz_c,      Vz_c_next;
    double delta_th_c, delta_th_c_next;

    int nb_steps = 10;

    uint64_t   now;
    NodeRank_t who;
    // RAZ measurement
    for (i=0;i<NODE_SIZE; ++i) {
      execTime[MIN_VAL][i]  = 0;
      execTime[MEAN_VAL][i] = 0;
      execTime[MAX_VAL][i]  = 0;
    }

    if (argc>1) {
      nb_steps = atoi(argv[1]);
    }

    /*****************************************/
    /* Initialisation de certaines variables */
    /*****************************************/

    delta_th_c = delta_th_eq;
    delta_e_c = delta_e_eq;

    Vz_c_next      = 0.0;
    delta_e_c_next = delta_e_c;
    delta_th_c_next = delta_th_c;

    /*****************************************************/
    /* Phase de simulation respectant le sch√©ma Simulink */
    /*****************************************************/

    printf("Will run for %d time step(s)\n",nb_steps);
    printf("CPU frequency is : %ld\n",getClockFrequency());
    // Go on a ZOL CPU
    setMyCpu(1);
    for (i = 0; i < nb_steps; i++) {

      // 200 Hz
      who = ENGINE;
      now = getTime();
      T       = engine(delta_th_c);
      now = getDeltaTime(now);
      execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];

      who = ELEVATOR;
      now = getTime();
      delta_e = elevator(delta_e_c);
      now = getDeltaTime(now);
      execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];

      who = AIRCRAFT_DYNAMICS;
      now = getTime();
      aircraft_dynamics(delta_e,T,&outputs);
      now = getDeltaTime(now);
      execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];

        //100 Hz
        if (i%2 == 0) {
	  who = H_FILTER;
	  now = getTime();
	  h_meas  = h_filter_100(outputs.h);
	  now = getDeltaTime(now);
	  execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];

	  who = VZ_FILTER;
	  now = getTime();
	  Vz_meas = Vz_filter_100(outputs.Vz);
	  now = getDeltaTime(now);
	  execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];

	  who = Q_FILTER;
	  now = getTime();
	  q_meas  = q_filter_100(outputs.q);
	  now = getDeltaTime(now);
	  execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];

	  who = VA_FILTER;
	  now = getTime();
	  Va_meas = Va_filter_100(outputs.Va);
	  now = getDeltaTime(now);
	  execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];

	  who = AZ_FILTER;
	  now = getTime();
	  az_meas = az_filter_100(outputs.az);
	  now = getDeltaTime(now);
	  execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];
        }

        //10 Hz
        if (i%20 == 0) {
	  who = ALTITUDE_HOLD;
	  now = getTime();
          Vz_c_next = altitude_hold_10(h_meas,h_c);
	  now = getDeltaTime(now);
	  execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];
        }

        if (i%20 == 19) {
            Vz_c      = Vz_c_next;
        }

        //50 Hz
        if (i%4 == 0) {
	  who = VA_CONTROL;
	  now = getTime();
          delta_th_c_next = Va_control_50(Va_meas,Vz_meas,q_meas,Va_c);
	  now = getDeltaTime(now);
	  execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];

	  who = VZ_CONTROL;
	  now = getTime();
          delta_e_c_next = Vz_control_50(Vz_meas,Vz_c,q_meas,az_meas);
	  now = getDeltaTime(now);
	  execTime[MAX_VAL][who] = now > execTime[MAX_VAL][who] ? now : execTime[MAX_VAL][who];
        }

        if (i%4 == 3) {
            delta_th_c = delta_th_c_next;
            output_delta_th_c(delta_th_c);
            delta_e_c = delta_e_c_next;
            output_delta_e_c(delta_e_c);
        }
    }

    printf("End of the simulation\n");
    // go back to non ZOL CPU
    setMyCpu(0);
    for (i=0;i<NODE_SIZE; ++i) {
      printf("%s = %ld / %lf ms\n", nodeNameTab[i],execTime[MAX_VAL][i],(double)(execTime[MAX_VAL][i])/((double)(getClockFrequency()/1000)));
    }
#ifdef NO_PRINT
#if INMEMORY_SAMPLE
    printf("Now printing in-memory sample...\n");
    print_inmemory_sample();
#endif
#endif
    return 0;
}
