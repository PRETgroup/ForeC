# 1 "./original/MatrixMultiply.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "./original/MatrixMultiply.c"
// Xilinx Microblaze
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Driver parameters

*

*******************************************************************/
# 18 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver MPMC */


/* Definitions for peripheral DDR_SDRAM */
# 42 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/


/* Definitions for peripheral DDR_SDRAM */
# 82 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral DDR_SDRAM */
# 105 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver GPIO */


/* Definitions for peripheral AUDIO */







/* Definitions for peripheral DIP_SWITCHES_8BIT */







/* Definitions for peripheral LEDS_4BIT */







/* Definitions for peripheral LEDS_POSITIONS */







/* Definitions for peripheral PUSH_BUTTONS_POSITION */







/******************************************************************/


/* Definitions for peripheral SRAM */



/******************************************************************/

/* Definitions for peripheral SRAM */



/******************************************************************/

/* Canonical definitions for peripheral SRAM */






/******************************************************************/


/* Definitions for peripheral DLMB_CNTLR_0 */




/* Definitions for peripheral ILMB_CNTLR_0 */




/* Definitions for peripheral MB_PLB_BRAM_CNTLR */




/******************************************************************/

/* Definitions for driver UARTLITE */


/* Definitions for peripheral MDM_0 */
# 205 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral MDM_0 */
# 218 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for bus frequencies */


/******************************************************************/

/* Canonical definitions for bus frequencies */

/******************************************************************/




/******************************************************************/


/* Definitions for peripheral MICROBLAZE_0 */
# 433 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 635 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 3 "./original/MatrixMultiply.c" 2

// Hardware counter connected via a direct FSL bus.
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 1
/*****************************************************************************

* Filename:          C:\Xilinx\12.1\MyProcessorIPLib\drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h

* Version:           1.00.a

* Description:       counter_dfsl (Counter DFSL) Driver Header File

* Date:              Fri Jul 02 14:27:25 2010 (by Create and Import Peripheral Wizard)

*****************************************************************************/
# 11 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 1



# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 60 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/***************************** Include Files *********************************/


/************************** Constant Definitions *****************************/
# 77 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/** Xilinx NULL, TRUE and FALSE legacy support. Deprecated. */
# 86 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/* the following constants and declarations are for unit test purposes and are
 * designed to be used in test applications.
 */






extern unsigned int XAssertStatus;
extern void XAssert(char *, int);

/**************************** Type Definitions *******************************/

/** @name Legacy types
 * Deprecated legacy types.
 * @{
 */
typedef unsigned char Xuint8; /**< unsigned 8-bit */
typedef char Xint8; /**< signed 8-bit */
typedef unsigned short Xuint16; /**< unsigned 16-bit */
typedef short Xint16; /**< signed 16-bit */
typedef unsigned long Xuint32; /**< unsigned 32-bit */
typedef long Xint32; /**< signed 32-bit */
typedef float Xfloat32; /**< 32-bit floating point */
typedef double Xfloat64; /**< 64-bit double precision FP */
typedef unsigned long Xboolean; /**< boolean (XTRUE or XFALSE) */

typedef struct
{
 Xuint32 Upper;
 Xuint32 Lower;
} Xuint64;

/** @name New types
 * New simple types.
 * @{
 */


typedef Xuint32 u32;
typedef Xuint16 u16;
typedef Xuint8 u8;





/*@}*/

/**
 * This data type defines an interrupt handler for a device.
 * The argument points to the instance of the component
 */
typedef void (*XInterruptHandler) (void *InstancePtr);

/**
 * This data type defines an exception handler for a processor.
 * The argument points to the instance of the component
 */
typedef void (*XExceptionHandler) (void *InstancePtr);

/**
 * This data type defines a callback to be invoked when an
 * assert occurs. The callback is invoked only when asserts are enabled
 */
typedef void (*XAssertCallback) (char *FilenamePtr, int LineNumber);

/***************** Macros (Inline Functions) Definitions *********************/

/*****************************************************************************/
/**
* Return the most significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The upper 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/


/*****************************************************************************/
/**
* Return the least significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The lower 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/





/*****************************************************************************/
/**
* This assert macro is to be used for functions that do not return anything
* (void). This in conjunction with the XWaitInAssert boolean can be used to
* accomodate tests so that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to
*           false, the assert occurs.
*
* @return   Returns void unless the XWaitInAssert variable is true, in which
*           case no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 214 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/*****************************************************************************/
/**
* This assert macro is to be used for functions that do return a value. This in
* conjunction with the XWaitInAssert boolean can be used to accomodate tests so
* that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to false,
*           the assert occurs.
*
* @return   Returns 0 unless the XWaitInAssert variable is true, in which case
*           no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 243 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do not
* return anything (void). Use for instances where an assert should always
* occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/







/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do return
* a value. Use for instances where an assert should always occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/
# 289 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/************************** Function Prototypes ******************************/

void XAssertSetCallback(XAssertCallback Routine);
void XNullHandler(void *NullParameter);
# 5 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE. 
// 
// File   : mb_interface.h
// Date   : 2002, March 20.
// Company: Xilinx
// Group  : Emerging Software Technologies
//
// Summary:
// Header file for mb_interface
//
// $Id: mb_interface.h,v 1.1.2.1 2009/09/24 23:37:36 haibing Exp $
//
////////////////////////////////////////////////////////////////////////////////




# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 33 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 2





extern void microblaze_enable_interrupts(void); /* Enable Interrupts */
extern void microblaze_disable_interrupts(void); /* Disable Interrupts */
extern void microblaze_enable_icache(void); /* Enable Instruction Cache */
extern void microblaze_disable_icache(void); /* Disable Instruction Cache */
extern void microblaze_enable_dcache(void); /* Enable Instruction Cache */
extern void microblaze_disable_dcache(void); /* Disable Instruction Cache */
extern void microblaze_enable_exceptions(void); /* Enable hardware exceptions */
extern void microblaze_disable_exceptions(void); /* Disable hardware exceptions */
extern void microblaze_register_handler(XInterruptHandler Handler, void *DataPtr); /* Register top level interrupt handler */
extern void microblaze_register_exception_handler(Xuint8 ExceptionId, XExceptionHandler Handler, void *DataPtr); /* Register exception handler */

extern void microblaze_invalidate_icache(); /* Invalidate the entire icache */
extern void microblaze_invalidate_dcache(); /* Invalidate the entire dcache */
extern void microblaze_flush_dcache(); /* Flush the whole dcache */
extern void microblaze_invalidate_icache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the icache */
extern void microblaze_invalidate_dcache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the dcache */
extern void microblaze_flush_dcache_range(unsigned int cacheaddr, unsigned int len); /* Flush a part of the dcache */

/* Deprecated */
extern void microblaze_update_icache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_icache_range (int , int ) __attribute__((deprecated));
extern void microblaze_update_dcache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_dcache_range (int , int ) __attribute__((deprecated));

/* necessary for pre-processor */



/* FSL Access Macros */

/* Blocking Data Read and Write to FSL no. id */



/* Non-blocking Data Read and Write to FSL no. id */



/* Blocking Control Read and Write to FSL no. id */



/* Non-blocking Control Read and Write to FSL no. id */



/* Polling versions of FSL access macros. This makes the FSL access interruptible */
# 104 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h"
/* FSL valid and error check macros. */




/* Pseudo assembler instructions */
# 257 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h"
/* Deprecated MicroBlaze FSL macros */
# 6 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 2





/* Extended FSL macros. These now replace all of the previous FSL macros */
# 12 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 2


typedef struct {
 int current; // Current counter value measured.
 int last; // Last value of the counter.
 int difference; // Difference between the current and last values.
 int min; // Minimum counter value.
 int avg; // Average counter value.
 int max; // Maximum counter value.
 long int total; // Cumulative value of all differences.
 int iterations; // Number of times values are added to the total.
} Counter;


// Initialise the current and last counter values.
# 40 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
// Start the counter with the specified value.



// Stop the counter and read the current value.



// Read the current counter value.
// Subtract 3 cycles for put and addk instruction.




// Calculate the difference between the current and last
// counter values.



// Accumulate the counter difference.




// Calculate the average differences.



// Update the maximum counter difference.





// Update the minimum counter difference.
# 6 "./original/MatrixMultiply.c" 2
Counter counter;



void multiply(void);

int main(int argc, char **args) {
 // Initialise and start counting the elapsed cycles for each reaction.
 counter.current = 0; counter.last = 0; counter.difference = 0; counter.min = 2147483647; counter.avg = 0; counter.max = 0; counter.total = 0; counter.iterations = 0;
 asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
 //--------------------------------------------------------------

 multiply();
 multiply();
 multiply();
 multiply();
 multiply();
 multiply();
 multiply();
 multiply();

 //--------------------------------------------------------------
 // Stop counting the elapsed cycles for the current reaction.
 asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
 asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
 counter.difference = counter.current - counter.last;
 if (counter.max < counter.difference) { counter.max = counter.difference; };
 if (counter.min > counter.difference) { counter.min = counter.difference; };
 counter.total += counter.difference; counter.iterations++;
 counter.avg = counter.total/counter.iterations;
 xil_printf("Total time: %d cycles\r\n", counter.total);
 xil_printf("Program termination\r\n");
 // forec:scheduler:counter:end

 asm volatile (".long 0x80000001\r\n");
 return 0;
}

void multiply(void) {
 int SIZE = 5;

 int matrixA[SIZE][SIZE];
 int matrixB[SIZE][SIZE];
 int matrixC[SIZE][SIZE];

 int sum;
 sum = 0;
 sum += matrixA[0][0] * matrixB[0][0];
 sum += matrixA[0][1] * matrixB[1][0];
 sum += matrixA[0][2] * matrixB[2][0];
 sum += matrixA[0][3] * matrixB[3][0];
 sum += matrixA[0][4] * matrixB[4][0];
 matrixC[0][0] = sum;
 sum = 0;
 sum += matrixA[0][0] * matrixB[0][1];
 sum += matrixA[0][1] * matrixB[1][1];
 sum += matrixA[0][2] * matrixB[2][1];
 sum += matrixA[0][3] * matrixB[3][1];
 sum += matrixA[0][4] * matrixB[4][1];
 matrixC[0][1] = sum;
 sum = 0;
 sum += matrixA[0][0] * matrixB[0][2];
 sum += matrixA[0][1] * matrixB[1][2];
 sum += matrixA[0][2] * matrixB[2][2];
 sum += matrixA[0][3] * matrixB[3][2];
 sum += matrixA[0][4] * matrixB[4][2];
 matrixC[0][2] = sum;
 sum = 0;
 sum += matrixA[0][0] * matrixB[0][3];
 sum += matrixA[0][1] * matrixB[1][3];
 sum += matrixA[0][2] * matrixB[2][3];
 sum += matrixA[0][3] * matrixB[3][3];
 sum += matrixA[0][4] * matrixB[4][3];
 matrixC[0][3] = sum;
 sum = 0;
 sum += matrixA[0][0] * matrixB[0][4];
 sum += matrixA[0][1] * matrixB[1][4];
 sum += matrixA[0][2] * matrixB[2][4];
 sum += matrixA[0][3] * matrixB[3][4];
 sum += matrixA[0][4] * matrixB[4][4];
 matrixC[0][4] = sum;
 sum = 0;
 sum += matrixA[1][0] * matrixB[0][0];
 sum += matrixA[1][1] * matrixB[1][0];
 sum += matrixA[1][2] * matrixB[2][0];
 sum += matrixA[1][3] * matrixB[3][0];
 sum += matrixA[1][4] * matrixB[4][0];
 matrixC[1][0] = sum;
 sum = 0;
 sum += matrixA[1][0] * matrixB[0][1];
 sum += matrixA[1][1] * matrixB[1][1];
 sum += matrixA[1][2] * matrixB[2][1];
 sum += matrixA[1][3] * matrixB[3][1];
 sum += matrixA[1][4] * matrixB[4][1];
 matrixC[1][1] = sum;
 sum = 0;
 sum += matrixA[1][0] * matrixB[0][2];
 sum += matrixA[1][1] * matrixB[1][2];
 sum += matrixA[1][2] * matrixB[2][2];
 sum += matrixA[1][3] * matrixB[3][2];
 sum += matrixA[1][4] * matrixB[4][2];
 matrixC[1][2] = sum;
 sum = 0;
 sum += matrixA[1][0] * matrixB[0][3];
 sum += matrixA[1][1] * matrixB[1][3];
 sum += matrixA[1][2] * matrixB[2][3];
 sum += matrixA[1][3] * matrixB[3][3];
 sum += matrixA[1][4] * matrixB[4][3];
 matrixC[1][3] = sum;
 sum = 0;
 sum += matrixA[1][0] * matrixB[0][4];
 sum += matrixA[1][1] * matrixB[1][4];
 sum += matrixA[1][2] * matrixB[2][4];
 sum += matrixA[1][3] * matrixB[3][4];
 sum += matrixA[1][4] * matrixB[4][4];
 matrixC[1][4] = sum;
 sum = 0;
 sum += matrixA[2][0] * matrixB[0][0];
 sum += matrixA[2][1] * matrixB[1][0];
 sum += matrixA[2][2] * matrixB[2][0];
 sum += matrixA[2][3] * matrixB[3][0];
 sum += matrixA[2][4] * matrixB[4][0];
 matrixC[2][0] = sum;
 sum = 0;
 sum += matrixA[2][0] * matrixB[0][1];
 sum += matrixA[2][1] * matrixB[1][1];
 sum += matrixA[2][2] * matrixB[2][1];
 sum += matrixA[2][3] * matrixB[3][1];
 sum += matrixA[2][4] * matrixB[4][1];
 matrixC[2][1] = sum;
 sum = 0;
 sum += matrixA[2][0] * matrixB[0][2];
 sum += matrixA[2][1] * matrixB[1][2];
 sum += matrixA[2][2] * matrixB[2][2];
 sum += matrixA[2][3] * matrixB[3][2];
 sum += matrixA[2][4] * matrixB[4][2];
 matrixC[2][2] = sum;
 sum = 0;
 sum += matrixA[2][0] * matrixB[0][3];
 sum += matrixA[2][1] * matrixB[1][3];
 sum += matrixA[2][2] * matrixB[2][3];
 sum += matrixA[2][3] * matrixB[3][3];
 sum += matrixA[2][4] * matrixB[4][3];
 matrixC[2][3] = sum;
 sum = 0;
 sum += matrixA[2][0] * matrixB[0][4];
 sum += matrixA[2][1] * matrixB[1][4];
 sum += matrixA[2][2] * matrixB[2][4];
 sum += matrixA[2][3] * matrixB[3][4];
 sum += matrixA[2][4] * matrixB[4][4];
 matrixC[2][4] = sum;
 sum = 0;
 sum += matrixA[3][0] * matrixB[0][0];
 sum += matrixA[3][1] * matrixB[1][0];
 sum += matrixA[3][2] * matrixB[2][0];
 sum += matrixA[3][3] * matrixB[3][0];
 sum += matrixA[3][4] * matrixB[4][0];
 matrixC[3][0] = sum;
 sum = 0;
 sum += matrixA[3][0] * matrixB[0][1];
 sum += matrixA[3][1] * matrixB[1][1];
 sum += matrixA[3][2] * matrixB[2][1];
 sum += matrixA[3][3] * matrixB[3][1];
 sum += matrixA[3][4] * matrixB[4][1];
 matrixC[3][1] = sum;
 sum = 0;
 sum += matrixA[3][0] * matrixB[0][2];
 sum += matrixA[3][1] * matrixB[1][2];
 sum += matrixA[3][2] * matrixB[2][2];
 sum += matrixA[3][3] * matrixB[3][2];
 sum += matrixA[3][4] * matrixB[4][2];
 matrixC[3][2] = sum;
 sum = 0;
 sum += matrixA[3][0] * matrixB[0][3];
 sum += matrixA[3][1] * matrixB[1][3];
 sum += matrixA[3][2] * matrixB[2][3];
 sum += matrixA[3][3] * matrixB[3][3];
 sum += matrixA[3][4] * matrixB[4][3];
 matrixC[3][3] = sum;
 sum = 0;
 sum += matrixA[3][0] * matrixB[0][4];
 sum += matrixA[3][1] * matrixB[1][4];
 sum += matrixA[3][2] * matrixB[2][4];
 sum += matrixA[3][3] * matrixB[3][4];
 sum += matrixA[3][4] * matrixB[4][4];
 matrixC[3][4] = sum;
 sum = 0;
 sum += matrixA[4][0] * matrixB[0][0];
 sum += matrixA[4][1] * matrixB[1][0];
 sum += matrixA[4][2] * matrixB[2][0];
 sum += matrixA[4][3] * matrixB[3][0];
 sum += matrixA[4][4] * matrixB[4][0];
 matrixC[4][0] = sum;
 sum = 0;
 sum += matrixA[4][0] * matrixB[0][1];
 sum += matrixA[4][1] * matrixB[1][1];
 sum += matrixA[4][2] * matrixB[2][1];
 sum += matrixA[4][3] * matrixB[3][1];
 sum += matrixA[4][4] * matrixB[4][1];
 matrixC[4][1] = sum;
 sum = 0;
 sum += matrixA[4][0] * matrixB[0][2];
 sum += matrixA[4][1] * matrixB[1][2];
 sum += matrixA[4][2] * matrixB[2][2];
 sum += matrixA[4][3] * matrixB[3][2];
 sum += matrixA[4][4] * matrixB[4][2];
 matrixC[4][2] = sum;
 sum = 0;
 sum += matrixA[4][0] * matrixB[0][3];
 sum += matrixA[4][1] * matrixB[1][3];
 sum += matrixA[4][2] * matrixB[2][3];
 sum += matrixA[4][3] * matrixB[3][3];
 sum += matrixA[4][4] * matrixB[4][3];
 matrixC[4][3] = sum;
 sum = 0;
 sum += matrixA[4][0] * matrixB[0][4];
 sum += matrixA[4][1] * matrixB[1][4];
 sum += matrixA[4][2] * matrixB[2][4];
 sum += matrixA[4][3] * matrixB[3][4];
 sum += matrixA[4][4] * matrixB[4][4];
 matrixC[4][4] = sum;
}
