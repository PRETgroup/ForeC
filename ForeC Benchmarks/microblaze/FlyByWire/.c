# 1 "FlyByWire.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "FlyByWire.c"
/*==============================================================

| Hardware architecture specific declarations:

| Cores, mutex and input/output information.

*=============================================================*/
# 5 "FlyByWire.c"
// Xilinx Microblaze
# 1 "../microblaze_0/include/xparameters.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Driver parameters

*

*******************************************************************/
# 18 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Definitions for driver MPMC */


/* Definitions for peripheral DDR_SDRAM */
# 42 "../microblaze_0/include/xparameters.h"
/******************************************************************/


/* Definitions for peripheral DDR_SDRAM */
# 82 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral DDR_SDRAM */
# 105 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Definitions for driver GPIO */


/* Definitions for peripheral AUDIO */







/* Definitions for peripheral DIP_SWITCHES_8BIT */







/* Definitions for peripheral LEDS_4BIT */







/* Definitions for peripheral LEDS_POSITIONS */







/* Definitions for peripheral PUSH_BUTTONS_POSITION */







/******************************************************************/


/* Definitions for peripheral SRAM */



/******************************************************************/

/* Definitions for peripheral SRAM */



/******************************************************************/

/* Canonical definitions for peripheral SRAM */






/******************************************************************/


/* Definitions for peripheral DLMB_CNTLR_0 */




/* Definitions for peripheral ILMB_CNTLR_0 */




/* Definitions for peripheral MB_PLB_BRAM_CNTLR */




/******************************************************************/

/* Definitions for driver UARTLITE */


/* Definitions for peripheral MDM_0 */
# 205 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral MDM_0 */
# 218 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Definitions for bus frequencies */


/******************************************************************/

/* Canonical definitions for bus frequencies */

/******************************************************************/




/******************************************************************/


/* Definitions for peripheral MICROBLAZE_0 */
# 433 "../microblaze_0/include/xparameters.h"
/******************************************************************/
# 635 "../microblaze_0/include/xparameters.h"
/******************************************************************/
# 7 "FlyByWire.c" 2

// Xilinx Microblaze Processor Version Register
# 1 "../microblaze_0/include/pvr.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2006 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE.
//
// $Id: pvr.h,v 1.1.2.1 2009/09/24 23:37:37 haibing Exp $
////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************/
/**
*
* @file pvr.h
*
* This header file contains defines for structures used by the microblaze 
* PVR routines
*
******************************************************************************/




# 1 "../microblaze_0/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 60 "../microblaze_0/include/xbasic_types.h"
/***************************** Include Files *********************************/


/************************** Constant Definitions *****************************/
# 77 "../microblaze_0/include/xbasic_types.h"
/** Xilinx NULL, TRUE and FALSE legacy support. Deprecated. */
# 86 "../microblaze_0/include/xbasic_types.h"
/* the following constants and declarations are for unit test purposes and are
 * designed to be used in test applications.
 */






extern unsigned int XAssertStatus;
extern void XAssert(char *, int);

/**************************** Type Definitions *******************************/

/** @name Legacy types
 * Deprecated legacy types.
 * @{
 */
typedef unsigned char Xuint8; /**< unsigned 8-bit */
typedef char Xint8; /**< signed 8-bit */
typedef unsigned short Xuint16; /**< unsigned 16-bit */
typedef short Xint16; /**< signed 16-bit */
typedef unsigned long Xuint32; /**< unsigned 32-bit */
typedef long Xint32; /**< signed 32-bit */
typedef float Xfloat32; /**< 32-bit floating point */
typedef double Xfloat64; /**< 64-bit double precision FP */
typedef unsigned long Xboolean; /**< boolean (XTRUE or XFALSE) */

typedef struct
{
 Xuint32 Upper;
 Xuint32 Lower;
} Xuint64;

/** @name New types
 * New simple types.
 * @{
 */


typedef Xuint32 u32;
typedef Xuint16 u16;
typedef Xuint8 u8;





/*@}*/

/**
 * This data type defines an interrupt handler for a device.
 * The argument points to the instance of the component
 */
typedef void (*XInterruptHandler) (void *InstancePtr);

/**
 * This data type defines an exception handler for a processor.
 * The argument points to the instance of the component
 */
typedef void (*XExceptionHandler) (void *InstancePtr);

/**
 * This data type defines a callback to be invoked when an
 * assert occurs. The callback is invoked only when asserts are enabled
 */
typedef void (*XAssertCallback) (char *FilenamePtr, int LineNumber);

/***************** Macros (Inline Functions) Definitions *********************/

/*****************************************************************************/
/**
* Return the most significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The upper 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/


/*****************************************************************************/
/**
* Return the least significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The lower 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/





/*****************************************************************************/
/**
* This assert macro is to be used for functions that do not return anything
* (void). This in conjunction with the XWaitInAssert boolean can be used to
* accomodate tests so that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to
*           false, the assert occurs.
*
* @return   Returns void unless the XWaitInAssert variable is true, in which
*           case no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 214 "../microblaze_0/include/xbasic_types.h"
/*****************************************************************************/
/**
* This assert macro is to be used for functions that do return a value. This in
* conjunction with the XWaitInAssert boolean can be used to accomodate tests so
* that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to false,
*           the assert occurs.
*
* @return   Returns 0 unless the XWaitInAssert variable is true, in which case
*           no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 243 "../microblaze_0/include/xbasic_types.h"
/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do not
* return anything (void). Use for instances where an assert should always
* occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/







/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do return
* a value. Use for instances where an assert should always occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/
# 289 "../microblaze_0/include/xbasic_types.h"
/************************** Function Prototypes ******************************/

void XAssertSetCallback(XAssertCallback Routine);
void XNullHandler(void *NullParameter);
# 34 "../microblaze_0/include/pvr.h" 2
# 1 "../microblaze_0/include/xparameters.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Driver parameters

*

*******************************************************************/
# 18 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Definitions for driver MPMC */


/* Definitions for peripheral DDR_SDRAM */
# 42 "../microblaze_0/include/xparameters.h"
/******************************************************************/


/* Definitions for peripheral DDR_SDRAM */
# 82 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral DDR_SDRAM */
# 105 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Definitions for driver GPIO */


/* Definitions for peripheral AUDIO */







/* Definitions for peripheral DIP_SWITCHES_8BIT */







/* Definitions for peripheral LEDS_4BIT */







/* Definitions for peripheral LEDS_POSITIONS */







/* Definitions for peripheral PUSH_BUTTONS_POSITION */







/******************************************************************/


/* Definitions for peripheral SRAM */



/******************************************************************/

/* Definitions for peripheral SRAM */



/******************************************************************/

/* Canonical definitions for peripheral SRAM */






/******************************************************************/


/* Definitions for peripheral DLMB_CNTLR_0 */




/* Definitions for peripheral ILMB_CNTLR_0 */




/* Definitions for peripheral MB_PLB_BRAM_CNTLR */




/******************************************************************/

/* Definitions for driver UARTLITE */


/* Definitions for peripheral MDM_0 */
# 205 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral MDM_0 */
# 218 "../microblaze_0/include/xparameters.h"
/******************************************************************/

/* Definitions for bus frequencies */


/******************************************************************/

/* Canonical definitions for bus frequencies */

/******************************************************************/




/******************************************************************/


/* Definitions for peripheral MICROBLAZE_0 */
# 433 "../microblaze_0/include/xparameters.h"
/******************************************************************/
# 635 "../microblaze_0/include/xparameters.h"
/******************************************************************/
# 35 "../microblaze_0/include/pvr.h" 2
# 1 "../microblaze_0/include/mb_interface.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE. 
// 
// File   : mb_interface.h
// Date   : 2002, March 20.
// Company: Xilinx
// Group  : Emerging Software Technologies
//
// Summary:
// Header file for mb_interface
//
// $Id: mb_interface.h,v 1.1.2.1 2009/09/24 23:37:36 haibing Exp $
//
////////////////////////////////////////////////////////////////////////////////




# 1 "../microblaze_0/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 33 "../microblaze_0/include/mb_interface.h" 2





extern void microblaze_enable_interrupts(void); /* Enable Interrupts */
extern void microblaze_disable_interrupts(void); /* Disable Interrupts */
extern void microblaze_enable_icache(void); /* Enable Instruction Cache */
extern void microblaze_disable_icache(void); /* Disable Instruction Cache */
extern void microblaze_enable_dcache(void); /* Enable Instruction Cache */
extern void microblaze_disable_dcache(void); /* Disable Instruction Cache */
extern void microblaze_enable_exceptions(void); /* Enable hardware exceptions */
extern void microblaze_disable_exceptions(void); /* Disable hardware exceptions */
extern void microblaze_register_handler(XInterruptHandler Handler, void *DataPtr); /* Register top level interrupt handler */
extern void microblaze_register_exception_handler(Xuint8 ExceptionId, XExceptionHandler Handler, void *DataPtr); /* Register exception handler */

extern void microblaze_invalidate_icache(); /* Invalidate the entire icache */
extern void microblaze_invalidate_dcache(); /* Invalidate the entire dcache */
extern void microblaze_flush_dcache(); /* Flush the whole dcache */
extern void microblaze_invalidate_icache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the icache */
extern void microblaze_invalidate_dcache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the dcache */
extern void microblaze_flush_dcache_range(unsigned int cacheaddr, unsigned int len); /* Flush a part of the dcache */

/* Deprecated */
extern void microblaze_update_icache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_icache_range (int , int ) __attribute__((deprecated));
extern void microblaze_update_dcache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_dcache_range (int , int ) __attribute__((deprecated));

/* necessary for pre-processor */



/* FSL Access Macros */

/* Blocking Data Read and Write to FSL no. id */



/* Non-blocking Data Read and Write to FSL no. id */



/* Blocking Control Read and Write to FSL no. id */



/* Non-blocking Control Read and Write to FSL no. id */



/* Polling versions of FSL access macros. This makes the FSL access interruptible */
# 104 "../microblaze_0/include/mb_interface.h"
/* FSL valid and error check macros. */




/* Pseudo assembler instructions */
# 257 "../microblaze_0/include/mb_interface.h"
/* Deprecated MicroBlaze FSL macros */
# 36 "../microblaze_0/include/pvr.h" 2
# 1 "../microblaze_0/include/bspconfig.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Configurations for Standalone BSP

*

*******************************************************************/
# 37 "../microblaze_0/include/pvr.h" 2






/* Defs */
typedef struct pvr_s {



  unsigned int pvr[1];

} pvr_t;




/* Basic PVR mask */
# 67 "../microblaze_0/include/pvr.h"
/* User 2 PVR mask */


/* Configuration PVR masks */
# 96 "../microblaze_0/include/pvr.h"
/* Debug and exception PVR masks */






/* ICache config PVR masks */







/* DCache config PVR masks */







/* ICache base address PVR mask */


/* ICache high address PVR mask */


/* DCache base address PVR mask */


/* DCache high address PVR mask */


/* Target family PVR mask */


/* MSR Reset value PVR mask */


/* MMU value PVR mask */



/* PVR access macros */
# 206 "../microblaze_0/include/pvr.h"
/* Protos */
int microblaze_get_pvr (pvr_t *pvr);
# 10 "FlyByWire.c" 2

// Hardware counter connected via a direct FSL bus.
# 1 "../drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 1
/*****************************************************************************

* Filename:          C:\Xilinx\12.1\MyProcessorIPLib\drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h

* Version:           1.00.a

* Description:       counter_dfsl (Counter DFSL) Driver Header File

* Date:              Fri Jul 02 14:27:25 2010 (by Create and Import Peripheral Wizard)

*****************************************************************************/
# 11 "../drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
# 1 "../microblaze_0/include/fsl.h" 1



# 1 "../microblaze_0/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 5 "../microblaze_0/include/fsl.h" 2
# 1 "../microblaze_0/include/mb_interface.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE. 
// 
// File   : mb_interface.h
// Date   : 2002, March 20.
// Company: Xilinx
// Group  : Emerging Software Technologies
//
// Summary:
// Header file for mb_interface
//
// $Id: mb_interface.h,v 1.1.2.1 2009/09/24 23:37:36 haibing Exp $
//
////////////////////////////////////////////////////////////////////////////////
# 6 "../microblaze_0/include/fsl.h" 2





/* Extended FSL macros. These now replace all of the previous FSL macros */
# 12 "../drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 2


typedef struct {
 int current;
 int last;
 int difference;
 int min;
 int avg;
 int max;
 long int total;
} Counter;


// Initialise the current and last counter values.
# 38 "../drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
// Start the counter with the specified value.




// Stop the counter and read the current value.



// Read the current counter value.
// Subtract 2 cycles for put and addk instruction.




// Calculate the difference between the current and last
// counter values.



// Accumulate the counter difference.



// Update the maximum counter difference.





// Update the minimum counter difference.
# 13 "FlyByWire.c" 2
Counter counter;

// ForeC hardware mutex
# 1 "../drivers/forec_mutex_v1_00_a/src/forec_mutex.h" 1
/*****************************************************************************

* Filename:          C:\Xilinx\12.1\MyProcessorIPLib\drivers/forec_mutex_v1_00_a/src/forec_mutex.h

* Version:           1.00.a

* Description:       forec_mutex (ForeC Mutex) Driver Header File

* Date:              Fri Jul 02 14:27:25 2010 (by Create and Import Peripheral Wizard)

*****************************************************************************/
# 1 "../microblaze_0/include/fsl.h" 1
# 13 "../drivers/forec_mutex_v1_00_a/src/forec_mutex.h" 2





// resetBit() only functions on core0
// Resets bits to one
# 17 "FlyByWire.c" 2






/*==============================================================

| ForeC type definitions:

| Defines the types of storage elements specific to ForeC.

*=============================================================*/
# 27 "FlyByWire.c"
// Status values.
typedef enum {
 // PAR
 FOREC_PAR_OFF, // 0
 FOREC_PAR_ON, // 1

 // Core
 FOREC_CORE_REACTING, // 2
 FOREC_CORE_REACTED, // 3
 FOREC_CORE_TERMINATED // 4
} Status;

// Store child thread information.
typedef struct _Thread {
 void *programCounter;
 struct _Thread *nextThread;
 struct _Thread *prevThread;
} Thread;

// Store parent thread information
typedef struct {
 void *programCounter;
 int parStatus;
 int parId;
} Parent;

// Keep track of child threads executing on
// a processor core.
typedef struct {
 int sync;
 int activeThreads;
 int status;
 int reactionCounter;
} Core;

// Global variable for spin-locking idle cores. Keeps round-robin bus busy.
volatile int spinLock = 1;

// Shared control variables for par(...)s -------------------------
// Thread main with par(...)s
Parent mainParParent;
Core mainParCore0;
Core mainParCore1;
Core mainParCore2;
Core mainParCore3;
Core mainParCore4;
Core mainParCore5;
Core mainParCore6;
int mainParReactionCounter;

// Thread servo with par(...)s
Parent servoParParent;
Core servoParCore1;
Core servoParCore3;
Core servoParCore4;
Core servoParCore5;
int servoParReactionCounter;


/*==============================================================

| Original global declarations:

| Global declarations in the original program code.

*=============================================================*/
# 90 "FlyByWire.c"
/* input */ char radioInput__global_0_0 = '0';
/* input */ char spiInput__global_0_0 = '0';
/* output */ int servoOutput0__global_0_0;
/* output */ int servoOutput1__global_0_0;
/* output */ int servoOutput2__global_0_0;
/* output */ int servoOutput3__global_0_0;

/* shared */ int terminate__0_0_pre_global = 0;
/* shared */ int isSafe__0_0_pre_global = 1;

const int MAX_DOWN_TIME__global_0_0 = 0;
const char INVALID__global_0_0 = '0';
const char VALID__global_0_0 = '1';
const int MANUAL__global_0_0 = 0;
const int AUTOMATIC__global_0_0 = 1;

int getMode(const int communicationInput);
int autopilot(const int mode, const int communicationInput);
void computation(void);

// thread flight__thread(void);
// thread servo__thread(void);
// thread servo0__thread(void);
// thread servo1__thread(void);
// thread servo2__thread(void);
// thread servo3__thread(void);
// thread timer__thread(void);
// thread failsafe__thread(void);

// Shared variables for internal usage ----------------------------
// global
/* shared */ int isSafe__0_0_global_main;
/* shared */ int terminate__0_0_global_main;

// main

// par0
/* shared */ int isSafe__0_0_global_failsafe;


// forec:scheduler:boot:start
int main(int argc__main_0_0, char *argv__main_0_0[]) {

/*==============================================================

| Multicore startup:

| Platform dependent code.  Core identifies itself and

| executes its corresponding start up code.

*=============================================================*/
# 138 "FlyByWire.c"
 // Initialise ForeC specific values ----------------------------
 // Thread main with par(...)s
 mainParParent.parStatus = FOREC_PAR_OFF;
 mainParCore0.sync = 1;
 mainParCore0.status = FOREC_CORE_REACTING;
 mainParCore1.sync = 1;
 mainParCore1.status = FOREC_CORE_REACTING;
 mainParCore2.sync = 1;
 mainParCore2.status = FOREC_CORE_REACTING;
 mainParCore3.sync = 1;
 mainParCore3.status = FOREC_CORE_REACTING;
 mainParCore4.sync = 1;
 mainParCore4.status = FOREC_CORE_REACTING;
 mainParCore5.sync = 1;
 mainParCore5.status = FOREC_CORE_REACTING;
 mainParCore6.sync = 1;
 mainParCore6.status = FOREC_CORE_REACTING;
 mainParReactionCounter = 0;

 // Thread servo with par(...)s
 servoParParent.parStatus = FOREC_PAR_OFF;
 servoParCore1.sync = 1;
 servoParCore1.status = FOREC_CORE_REACTING;
 servoParCore3.sync = 1;
 servoParCore3.status = FOREC_CORE_REACTING;
 servoParCore4.sync = 1;
 servoParCore4.status = FOREC_CORE_REACTING;
 servoParCore5.sync = 1;
 servoParCore5.status = FOREC_CORE_REACTING;
 servoParReactionCounter = 0;


 // ForeC mutex -------------------------------------------------
 unsigned int forec_mutex_value;
 asm volatile ("put\t%0,rfsl" "1" :: "d" (0));

 // Variables for par()s ----------------------------------------
 // par0
 Thread failsafe__thread;
 Thread flight__thread;
 Thread servo__thread;
 Thread timer__thread;
 Thread mainReactionStartMaster0;
 Thread mainReactionStartSlave1;
 Thread mainReactionStartSlave2;
 Thread mainReactionStartSlave3;
 Thread mainReactionStartSlave4;
 Thread mainReactionStartSlave5;
 Thread mainReactionStartSlave6;
 Thread mainReactionEndMaster0;
 Thread mainReactionEndSlave1;
 Thread mainReactionEndSlave2;
 Thread mainReactionEndSlave3;
 Thread mainReactionEndSlave4;
 Thread mainReactionEndSlave5;
 Thread mainReactionEndSlave6;
 Thread servoParHandlerMaster1;
 Thread servoParHandlerSlave3;
 Thread servoParHandlerSlave4;
 Thread servoParHandlerSlave5;
 Thread abortWeak0Check0;
 Thread abortWeak0Check1;
 Thread abortWeak0Check2;
 Thread abortWeak0Check3;
 Thread abortWeak0Check4;
 Thread abortWeak0Check5;
 Thread abortWeak0Check6;

 // par1
 Thread servo0__thread;
 Thread servo1__thread;
 Thread servo2__thread;
 Thread servo3__thread;
 Thread servoReactionStartMaster1;
 Thread servoReactionStartSlave3;
 Thread servoReactionStartSlave4;
 Thread servoReactionStartSlave5;
 Thread servoReactionEndMaster1;
 Thread servoReactionEndSlave3;
 Thread servoReactionEndSlave4;
 Thread servoReactionEndSlave5;
 Thread abortStrong2Check1;
 Thread abortStrong2Check3;
 Thread abortStrong2Check4;
 Thread abortStrong2Check5;


 // Synchronise execution of cores ------------------------------
 // pvr = Processor Version Register
 unsigned int pvr0;
 asm volatile ("mfs\t%0,rpvr" "0" "\n\t" : "=d" (pvr0));
 pvr0 &= 0x000000FF;

 switch (pvr0) {
  case (0):
   while(mainParCore1.sync);
   while(mainParCore2.sync);
   while(mainParCore3.sync);
   while(mainParCore4.sync);
   while(mainParCore5.sync);
   while(mainParCore6.sync);
   goto mainParCore0;

  case (1):
   mainParCore1.sync = 0;
   goto mainParCore1;

  case (2):
   mainParCore2.sync = 0;
   goto mainParCore2;

  case (3):
   mainParCore3.sync = 0;
   goto mainParCore3;

  case (4):
   mainParCore4.sync = 0;
   goto mainParCore4;

  case (5):
   mainParCore5.sync = 0;
   goto mainParCore5;

  case (6):
   mainParCore6.sync = 0;
   goto mainParCore6;

  default:
   // "Lock-up" unused cores.
  //	while (spinLock == 1);
   while(1);
 }
// forec:scheduler:boot:end

/*==============================================================

| Core specific instructions:

| Contains par, abort and synchronisation handlers.

*=============================================================*/
# 276 "FlyByWire.c"
 /*--------------------------------------------------------------

	| Master core: core0

	| ForeC program's main() function:

	| Original main() function code with ForeC constructs

	| translated into C code.

	*-------------------------------------------------------------*/
# 282 "FlyByWire.c"
 // forec:thread:main:start
mainParCore0: {
 // forec:scheduler:counter:start
 // Initialise and start counting the elapsed cycles for each reaction.
 counter.current = 0; counter.last = 0; counter.difference = 0; counter.min = 2147483647; counter.avg = 0; counter.max = 0; counter.total = 0;
 counter.last = counter.current; asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
 // forec:scheduler:counter:end

 radioInput__global_0_0 = INVALID__global_0_0;
 spiInput__global_0_0 = INVALID__global_0_0;
 servoOutput0__global_0_0 = 0;
 servoOutput1__global_0_0 = 0;
 servoOutput2__global_0_0 = 0;
 servoOutput3__global_0_0 = 0;

 while (!terminate__0_0_pre_global) {
  /* abortWeak0 */ {
   // forec:statement:par:par0:start
   // par0(servo__thread, timer__thread, flight__thread, failsafe__thread);
   // Set the par(...) information.
   mainParParent.parId = 0;
   mainParParent.parStatus = FOREC_PAR_ON;

   // Link the threads and handlers together.
   mainReactionStartMaster0.programCounter = &&mainReactionStartMaster0;
   failsafe__thread.programCounter = &&failsafe__thread;
   mainReactionStartMaster0.nextThread = &failsafe__thread;
   failsafe__thread.prevThread = &mainReactionStartMaster0;
   abortWeak0Check0.programCounter = &&abortWeak0Check0;
   failsafe__thread.nextThread = &abortWeak0Check0;
   abortWeak0Check0.prevThread = &failsafe__thread;
   mainReactionEndMaster0.programCounter = &&mainReactionEndMaster0;
   abortWeak0Check0.nextThread = &mainReactionEndMaster0;
   mainReactionEndMaster0.prevThread = &abortWeak0Check0;

   // Link the last and first threads/handlers together.
   mainReactionEndMaster0.nextThread = &mainReactionStartMaster0;
   mainReactionStartMaster0.prevThread = &mainReactionEndMaster0;

   // Set the join address.
   mainParParent.programCounter = &&par0JoinAddress_mainParCore0;

   // Set the core information.
   mainParCore0.activeThreads = 1;
   mainParCore0.reactionCounter = mainParReactionCounter;

   // Go to the first thread.
   goto failsafe__thread;
   par0JoinAddress_mainParCore0:;
   // forec:statement:par:par0:end
   abortEnd_abortWeak0:;
  } // when (!isSafe__0_0_pre_global);
  // forec:statement:abort:abortWeak0:scope:end

  // forec:statement:pause:pause0:start
  // Delay shared variables.
  terminate__0_0_pre_global = terminate__0_0_global_main;
  isSafe__0_0_pre_global = isSafe__0_0_global_main;
  // pause;

  // forec:scheduler:counter:start
  // Stop counting the elapsed cycles for the current reaction.
  asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
  asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
  counter.difference = counter.current - counter.last;
  if (counter.max < counter.difference) { counter.max = counter.difference; };
  if (counter.min > counter.difference) { counter.min = counter.difference; };
  counter.total += counter.difference;
  xil_printf("Reaction time: %d cycles	Min: %d	Max: %d\r\n", counter.difference, counter.min, counter.max);
  if (mainParReactionCounter == 10000) {
   xil_printf("Total time for 10,000 reactions: %d cycles\r\n", counter.total);
  }
  // Restart the counting of elapsed cycles for the next reaction.
  counter.current = 0; counter.last = 0;
  counter.last = counter.current; asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
  // forec:scheduler:counter:end
  // forec:statement:pause:pause0:end
  asm volatile ("nop");
 }
 // forec:scheduler:threadRemove:main:start

 // forec:scheduler:counter:start
 // Stop counting the elapsed cycles for the current reaction.
 asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
 asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
 counter.difference = counter.current - counter.last;
 if (counter.max < counter.difference) { counter.max = counter.difference; };
 if (counter.min > counter.difference) { counter.min = counter.difference; };
 counter.total += counter.difference;
 xil_printf("Reaction time: %d cycles	Min: %d	Max: %d\r\n", counter.difference, counter.min, counter.max);
 if (mainParReactionCounter == 10000) {
  xil_printf("Total time for 10,000 reactions: %d cycles\r\n", counter.total);
 }
 xil_printf("Program termination\r\n");
 // forec:scheduler:counter:end

 return 0;
 // forec:scheduler:threadRemove:main:end
} // mainParCore0
 // forec:thread:main:end

// forec:scheduler:parHandler:main:master:0:start
mainParHandlerMaster0: {
 if (mainParParent.parId == -2) {
  // Iteration
  // Wait for other cores to complete their reaction.
  while(mainParCore1.status == FOREC_CORE_REACTING);
  while(mainParCore2.status == FOREC_CORE_REACTING);
  while(mainParCore3.status == FOREC_CORE_REACTING);
  while(mainParCore4.status == FOREC_CORE_REACTING);
  while(mainParCore5.status == FOREC_CORE_REACTING);
  while(mainParCore6.status == FOREC_CORE_REACTING);

  mainParParent.parStatus = FOREC_PAR_OFF;
  mainParParent.parId = -1;

  // Set slave cores' status to reacting.
  mainParCore1.status = FOREC_CORE_REACTING;
  mainParCore2.status = FOREC_CORE_REACTING;
  mainParCore3.status = FOREC_CORE_REACTING;
  mainParCore4.status = FOREC_CORE_REACTING;
  mainParCore5.status = FOREC_CORE_REACTING;
  mainParCore6.status = FOREC_CORE_REACTING;

  // Increment the reaction counter for synchronisation.
  mainParReactionCounter++;

  // Return to thread main.
  goto *mainParParent.programCounter;
 }

 // Control should not reach here.
 goto mainParHandlerMaster0;
}
// forec:scheduler:parHandler:main:master:0:end


 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:master:0:start
 //-- main:
mainReactionStartMaster0: {
 // Go to the next thread.
 goto *mainReactionStartMaster0.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:master:0:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:master:0:start
 //-- main:
mainReactionEndMaster0: {
 // Determine if the core can still react or not.
 if (mainParCore0.activeThreads) {
  mainParCore0.status = FOREC_CORE_REACTED;
 } else {
  mainParCore0.status = FOREC_CORE_TERMINATED;
 }

 // Wait for other cores to complete their reaction.
 while(mainParCore1.status == FOREC_CORE_REACTING);
 while(mainParCore2.status == FOREC_CORE_REACTING);
 while(mainParCore3.status == FOREC_CORE_REACTING);
 while(mainParCore4.status == FOREC_CORE_REACTING);
 while(mainParCore5.status == FOREC_CORE_REACTING);
 while(mainParCore6.status == FOREC_CORE_REACTING);


 // Reset the mutex.
 asm volatile ("put\t%0,rfsl" "1" :: "d" (0));

 int parId = mainParParent.parId;
 // Combine shared variables.
 if (parId == 0) {
  isSafe__0_0_global_main = 0 + isSafe__0_0_global_failsafe;
 } else {
  // Nothing
 }

 // Return back to the parent thread if all the cores have terminated.
 if (1 && mainParCore0.status == FOREC_CORE_TERMINATED && mainParCore1.status == FOREC_CORE_TERMINATED && mainParCore2.status == FOREC_CORE_TERMINATED && mainParCore3.status == FOREC_CORE_TERMINATED && mainParCore4.status == FOREC_CORE_TERMINATED && mainParCore5.status == FOREC_CORE_TERMINATED && mainParCore6.status == FOREC_CORE_TERMINATED) {
  mainParParent.parStatus = FOREC_PAR_OFF;
  mainParParent.parId = -1;

  // Set slave cores' status to reacting
  mainParCore1.status = FOREC_CORE_REACTING;
  mainParCore2.status = FOREC_CORE_REACTING;
  mainParCore3.status = FOREC_CORE_REACTING;
  mainParCore4.status = FOREC_CORE_REACTING;
  mainParCore5.status = FOREC_CORE_REACTING;
  mainParCore6.status = FOREC_CORE_REACTING;

  // Increment the reaction counter for synchronization.
  mainParReactionCounter++;

  goto *mainParParent.programCounter;
 }

 // Delay shared variables.
 if (parId == 0) {
  isSafe__0_0_pre_global = isSafe__0_0_global_main;
 } else {
  // Nothing
 }

 // Set slave cores' status to reacting
 mainParCore1.status = FOREC_CORE_REACTING;
 mainParCore2.status = FOREC_CORE_REACTING;
 mainParCore3.status = FOREC_CORE_REACTING;
 mainParCore4.status = FOREC_CORE_REACTING;
 mainParCore5.status = FOREC_CORE_REACTING;
 mainParCore6.status = FOREC_CORE_REACTING;

 // forec:scheduler:counter:start
 // Stop counting the elapsed cycles for the current reaction.
 asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
 asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
 counter.difference = counter.current - counter.last;
 if (counter.max < counter.difference) { counter.max = counter.difference; };
 if (counter.min > counter.difference) { counter.min = counter.difference; };
 counter.total += counter.difference;
 xil_printf("Reaction time: %d cycles	Min: %d	Max: %d\r\n", counter.difference, counter.min, counter.max);
 if (mainParReactionCounter == 10000) {
  xil_printf("Total time for 10,000 reactions: %d cycles\r\n", counter.total);
 }
 // Restart counting of the elapsed cycles for the next reaction.
 counter.current = 0; counter.last = 0;
 counter.last = counter.current; asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
 // forec:scheduler:counter:end

 // Increment the reaction counter for synchronization.
 mainParReactionCounter++;

 // Go to the next thread.
 goto *mainReactionEndMaster0.nextThread -> programCounter;
}
 // forec:scheduler:reactionEnd:main:master:0:end



 // Abort check handlers ----------------------------------------
 // forec:scheduler:abortHandler:abortWeak0:0:start
 // abortWeak0 (!isSafe__0_0_pre_global)
abortWeak0Check0: {
 // Check the abort condition.
 if (!isSafe__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  mainParCore0.activeThreads = 0;

  // Update the parent thread to resume at the end of the abort scope.
  mainParParent.programCounter = &&abortEnd_abortWeak0;

  goto mainReactionEndMaster0;
 }

 // Continue to the next thread.
 goto *abortWeak0Check0.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortWeak0:0:end


// forec:scheduler:parHandler:main:slave:1:start
/*--------------------------------------------------------------

| Slave core: core1

*-------------------------------------------------------------*/
# 550 "FlyByWire.c"
mainParCore1: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave1.programCounter = &&mainReactionStartSlave1;
  servo__thread.programCounter = &&servo__thread;
  mainReactionStartSlave1.nextThread = &servo__thread;
  servo__thread.prevThread = &mainReactionStartSlave1;
  servoParHandlerMaster1.programCounter = &&servoParHandlerMaster1;
  servo__thread.nextThread = &servoParHandlerMaster1;
  servoParHandlerMaster1.prevThread = &servo__thread;
  abortWeak0Check1.programCounter = &&abortWeak0Check1;
  servoParHandlerMaster1.nextThread = &abortWeak0Check1;
  abortWeak0Check1.prevThread = &servoParHandlerMaster1;
  mainReactionEndSlave1.programCounter = &&mainReactionEndSlave1;
  abortWeak0Check1.nextThread = &mainReactionEndSlave1;
  mainReactionEndSlave1.prevThread = &abortWeak0Check1;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave1.nextThread = &mainReactionStartSlave1;
  mainReactionStartSlave1.prevThread = &mainReactionEndSlave1;

  // Set the core information.
  mainParCore1.activeThreads = 2;
  mainParCore1.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto servo__thread;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore1.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore1.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore1.reactionCounter == mainParReactionCounter);
   mainParCore1.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...)
  goto mainParCore1;
 }

 // Control shouldn't reach here.
 goto mainParCore1;
}
// forec:scheduler:parHandler:main:slave:1:end

 // Nested par(...) handlers ------------------------------------
 // forec:scheduler:parHandler:servo:master:1:start
 //-- Thread servo par(...) handlers
servoParHandlerMaster1: {
 // Check the execution status of the nested par(...)s.
 if (servoParParent.parStatus == FOREC_PAR_OFF) {
  // Release the mutex.
  asm volatile ("put\t%0,rfsl" "0" :: "d" (((31) << 1) + 0));

  goto *servoParHandlerMaster1.nextThread -> programCounter;
 }
 // Release the mutex.
 asm volatile ("put\t%0,rfsl" "0" :: "d" (((31) << 1) + 0));

 int parId = servoParParent.parId;

 // Check the par(...) ID.
 if (parId == 1) {
  asm ("# par1 begin");
  // Link the threads and handlers together.
  servoReactionStartMaster1.programCounter = &&servoReactionStartMaster1;
  abortStrong2Check1.programCounter = &&abortStrong2Check1;
  servoReactionStartMaster1.nextThread = &abortStrong2Check1;
  abortStrong2Check1.prevThread = &servoReactionStartMaster1;
  servo0__thread.programCounter = &&servo0__thread;
  abortStrong2Check1.nextThread = &servo0__thread;
  servo0__thread.prevThread = &abortStrong2Check1;
  servoReactionEndMaster1.programCounter = &&servoReactionEndMaster1;
  servo0__thread.nextThread = &servoReactionEndMaster1;
  servoReactionEndMaster1.prevThread = &servo0__thread;

  // Swap the nested par handler with the linked list.
  servoParHandlerMaster1.prevThread -> nextThread = &servoReactionStartMaster1;
  servoReactionStartMaster1.prevThread = servoParHandlerMaster1.prevThread;
  servoReactionEndMaster1.nextThread = servoParHandlerMaster1.nextThread;
  servoParHandlerMaster1.nextThread -> prevThread = &servoReactionEndMaster1;

  // Set the core information.
  servoParCore1.activeThreads = 1;
  servoParCore1.reactionCounter = servoParReactionCounter;

  // Go to the first thread.
  goto servo0__thread;
  asm ("# par1 end");
 } else if (parId == -2) {
  // Iteration
  // Wait for other cores to complete their reaction.
  while(servoParCore3.status == FOREC_CORE_REACTING);
  while(servoParCore4.status == FOREC_CORE_REACTING);
  while(servoParCore5.status == FOREC_CORE_REACTING);

  servoParParent.parStatus = FOREC_PAR_OFF;
  servoParParent.parId = -1;

  asm volatile ("put\t%0,rfsl" "0" :: "d" ((31 << 1) + 1));

  // Set slave cores' status to reacting.
  servoParCore3.status = FOREC_CORE_REACTING;
  servoParCore4.status = FOREC_CORE_REACTING;
  servoParCore5.status = FOREC_CORE_REACTING;

  // Increment the reaction counter for synchronisation.
  servoParReactionCounter++;

  // Return to thread servo.
  goto *servoParParent.programCounter;
 } else if (parId == -3) {
  // Thread termination
  mainParCore1.activeThreads--;
  servoParCore1.activeThreads--;

  // Wait for other cores to complete their reaction.
  while(servoParCore3.status == FOREC_CORE_REACTING);
  while(servoParCore4.status == FOREC_CORE_REACTING);
  while(servoParCore5.status == FOREC_CORE_REACTING);

  servoParParent.parStatus = FOREC_PAR_OFF;
  servoParParent.parId = -1;

  // Set slave cores' status to reacting.
  servoParCore3.status = FOREC_CORE_REACTING;
  servoParCore4.status = FOREC_CORE_REACTING;
  servoParCore5.status = FOREC_CORE_REACTING;

  // Increment the reaction counter for synchronisation.
  servoParReactionCounter++;

  // Delete this par(...) handler.
  servoParHandlerMaster1.prevThread -> nextThread = servoParHandlerMaster1.nextThread;
  servoParHandlerMaster1.nextThread -> prevThread = servoParHandlerMaster1.prevThread;

  // Return to thread servo.
  goto *servoParParent.programCounter;
 } else {
  // Unscheduled par(...)
  servoParCore1.reactionCounter = servoParReactionCounter;

  servoParHandlerMaster1.programCounter = &&wrongParId_servoParHandlerMaster1;
  wrongParId_servoParHandlerMaster1:;

  servoParCore1.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore1.reactionCounter == servoParReactionCounter);
  servoParCore1.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (servoParParent.parStatus == FOREC_PAR_ON && servoParParent.parId == parId) {
   goto *servoParHandlerMaster1.nextThread -> programCounter;
  }

  // Go back to the top and wait for the next nested par(...)
  servoParHandlerMaster1.programCounter = &&servoParHandlerMaster1;
  goto servoParHandlerMaster1;
 }

 // Control should not reach here.
 goto servoParHandlerMaster1;
}
 // forec:scheduler:parHandler:servo:master:1:end


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:1:start
 //-- main:
mainReactionStartSlave1: {
 // Go to the next thread.
 goto *mainReactionStartSlave1.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:1:end

 // forec:scheduler:reactionStart:servo:master:1:start
 //-- servo:
servoReactionStartMaster1: {
 // Go to the next thread.
 goto *servoReactionStartMaster1.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:servo:master:1:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:1:start
 //-- main:
mainReactionEndSlave1: {
 // Determine if the core can still react or not.
 if (mainParCore1.activeThreads) {
  mainParCore1.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore1.reactionCounter == mainParReactionCounter);
  mainParCore1.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave1.nextThread -> programCounter;
 } else {
  int parId = mainParParent.parId;

  mainReactionEndSlave1.programCounter = &&terminated_mainReactionEndSlave1;
  terminated_mainReactionEndSlave1:;

  mainParCore1.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore1.reactionCounter == mainParReactionCounter);
  mainParCore1.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave1.nextThread -> programCounter;
  }

  goto mainParCore1;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave1;
}
 // forec:scheduler:reactionEnd:main:slave:1:end

 // forec:scheduler:reactionEnd:servo:master:1:start
 //-- servo:
servoReactionEndMaster1: {
 // Determine if the core can still react or not.
 if (servoParCore1.activeThreads) {
  servoParCore1.status = FOREC_CORE_REACTED;
 } else {
  servoParCore1.status = FOREC_CORE_TERMINATED;
 }

 // Wait for other cores to complete their reaction.
 while(servoParCore3.status == FOREC_CORE_REACTING);
 while(servoParCore4.status == FOREC_CORE_REACTING);
 while(servoParCore5.status == FOREC_CORE_REACTING);


 // Return back to the parent thread if all the cores have terminated.
 if (1 && servoParCore1.status == FOREC_CORE_TERMINATED && servoParCore3.status == FOREC_CORE_TERMINATED && servoParCore4.status == FOREC_CORE_TERMINATED && servoParCore5.status == FOREC_CORE_TERMINATED) {
  asm volatile ("put\t%0,rfsl" "0" :: "d" ((31 << 1) + 1));

  servoParParent.parStatus = FOREC_PAR_OFF;
  servoParParent.parId = -1;

  // Set slave cores' status to reacting
  servoParCore3.status = FOREC_CORE_REACTING;
  servoParCore4.status = FOREC_CORE_REACTING;
  servoParCore5.status = FOREC_CORE_REACTING;

  // Increment the reaction counter for synchronization.
  servoParReactionCounter++;

  // Swap the reaction (start & end) handlers with (thread servo & nested par handler).
  servoReactionStartMaster1.prevThread -> nextThread = &servo__thread;
  servo__thread.prevThread = servoReactionStartMaster1.prevThread;
  servo__thread.nextThread = &servoParHandlerMaster1;
  servoParHandlerMaster1.prevThread = &servo__thread;
  servoParHandlerMaster1.nextThread = servoReactionEndMaster1.nextThread;
  servoReactionEndMaster1.nextThread -> prevThread = &servoParHandlerMaster1;

  goto *servoParParent.programCounter;
 }

 // Set slave cores' status to reacting
 servoParCore3.status = FOREC_CORE_REACTING;
 servoParCore4.status = FOREC_CORE_REACTING;
 servoParCore5.status = FOREC_CORE_REACTING;

 // Increment the reaction counter for synchronization.
 servoParReactionCounter++;

 // Go to the next thread.
 goto *servoReactionEndMaster1.nextThread -> programCounter;
}
 // forec:scheduler:reactionEnd:servo:master:1:end



 // Abort check handlers ----------------------------------------
 // forec:scheduler:abortHandler:abortWeak0:1:start
 // abortWeak0 (!isSafe__0_0_pre_global)
abortWeak0Check1: {
 // Check the abort condition.
 if (!isSafe__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  mainParCore1.activeThreads = 0;

  goto mainReactionEndSlave1;
 }

 // Continue to the next thread.
 goto *abortWeak0Check1.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortWeak0:1:end
 // forec:scheduler:abortHandler:abortStrong2:1:start
 // abortStrong2 (terminate__0_0_pre_global)
abortStrong2Check1: {
 // Check the abort condition.
 if (terminate__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  servoParCore1.activeThreads = 0;

  // Update the parent thread to resume at the end of the abort scope.
  servoParParent.programCounter = &&abortEnd_abortStrong2;

  goto servoReactionEndMaster1;
 }

 // Continue to the next thread.
 goto *abortStrong2Check1.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortStrong2:1:end

// forec:scheduler:parHandler:main:slave:2:start
/*--------------------------------------------------------------

| Slave core: core2

*-------------------------------------------------------------*/
# 884 "FlyByWire.c"
mainParCore2: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave2.programCounter = &&mainReactionStartSlave2;
  flight__thread.programCounter = &&flight__thread;
  mainReactionStartSlave2.nextThread = &flight__thread;
  flight__thread.prevThread = &mainReactionStartSlave2;
  abortWeak0Check2.programCounter = &&abortWeak0Check2;
  flight__thread.nextThread = &abortWeak0Check2;
  abortWeak0Check2.prevThread = &flight__thread;
  mainReactionEndSlave2.programCounter = &&mainReactionEndSlave2;
  abortWeak0Check2.nextThread = &mainReactionEndSlave2;
  mainReactionEndSlave2.prevThread = &abortWeak0Check2;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave2.nextThread = &mainReactionStartSlave2;
  mainReactionStartSlave2.prevThread = &mainReactionEndSlave2;

  // Set the core information.
  mainParCore2.activeThreads = 1;
  mainParCore2.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto flight__thread;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore2.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore2.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore2.reactionCounter == mainParReactionCounter);
   mainParCore2.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...)
  goto mainParCore2;
 }

 // Control shouldn't reach here.
 goto mainParCore2;
}
// forec:scheduler:parHandler:main:slave:2:end

 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:2:start
 //-- main:
mainReactionStartSlave2: {
 // Go to the next thread.
 goto *mainReactionStartSlave2.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:2:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:2:start
 //-- main:
mainReactionEndSlave2: {
 // Determine if the core can still react or not.
 if (mainParCore2.activeThreads) {
  mainParCore2.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore2.reactionCounter == mainParReactionCounter);
  mainParCore2.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave2.nextThread -> programCounter;
 } else {
  int parId = mainParParent.parId;

  mainReactionEndSlave2.programCounter = &&terminated_mainReactionEndSlave2;
  terminated_mainReactionEndSlave2:;

  mainParCore2.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore2.reactionCounter == mainParReactionCounter);
  mainParCore2.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave2.nextThread -> programCounter;
  }

  goto mainParCore2;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave2;
}
 // forec:scheduler:reactionEnd:main:slave:2:end



 // Abort check handlers ----------------------------------------
 // forec:scheduler:abortHandler:abortWeak0:2:start
 // abortWeak0 (!isSafe__0_0_pre_global)
abortWeak0Check2: {
 // Check the abort condition.
 if (!isSafe__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  mainParCore2.activeThreads = 0;

  goto mainReactionEndSlave2;
 }

 // Continue to the next thread.
 goto *abortWeak0Check2.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortWeak0:2:end

// forec:scheduler:parHandler:main:slave:3:start
/*--------------------------------------------------------------

| Slave core: core3

*-------------------------------------------------------------*/
# 1015 "FlyByWire.c"
mainParCore3: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave3.programCounter = &&mainReactionStartSlave3;
  servoParHandlerSlave3.programCounter = &&servoParHandlerSlave3;
  mainReactionStartSlave3.nextThread = &servoParHandlerSlave3;
  servoParHandlerSlave3.prevThread = &mainReactionStartSlave3;
  abortWeak0Check3.programCounter = &&abortWeak0Check3;
  servoParHandlerSlave3.nextThread = &abortWeak0Check3;
  abortWeak0Check3.prevThread = &servoParHandlerSlave3;
  mainReactionEndSlave3.programCounter = &&mainReactionEndSlave3;
  abortWeak0Check3.nextThread = &mainReactionEndSlave3;
  mainReactionEndSlave3.prevThread = &abortWeak0Check3;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave3.nextThread = &mainReactionStartSlave3;
  mainReactionStartSlave3.prevThread = &mainReactionEndSlave3;

  // Set the core information.
  mainParCore3.activeThreads = 1;
  mainParCore3.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto servoParHandlerSlave3;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore3.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore3.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore3.reactionCounter == mainParReactionCounter);
   mainParCore3.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...)
  goto mainParCore3;
 }

 // Control shouldn't reach here.
 goto mainParCore3;
}
// forec:scheduler:parHandler:main:slave:3:end

 // Nested par(...) handlers ------------------------------------
 // forec:scheduler:parHandler:servo:slave:3:start
 //-- Thread servo par(...) handlers
servoParHandlerSlave3: {
 // Synchronise the checking of the nested par(...) via a mutex.
 asm volatile ("get\t%0,rfsl" "0" : "=d" (forec_mutex_value));
 while ((unsigned)(forec_mutex_value & 0x80000000) == (unsigned)0x80000000) {
  asm volatile ("get\t%0,rfsl" "0" : "=d" (forec_mutex_value));
 }

 // Check the execution status of the nested par(...)s.
 if (servoParParent.parStatus == FOREC_PAR_OFF) {
  goto *servoParHandlerSlave3.nextThread -> programCounter;
 }

 int parId = servoParParent.parId;

 // Check the par(...) ID.
 if (parId == 1) {
  asm ("# par1 begin");
  // Link the threads and handlers together.
  servoReactionStartSlave3.programCounter = &&servoReactionStartSlave3;
  abortStrong2Check3.programCounter = &&abortStrong2Check3;
  servoReactionStartSlave3.nextThread = &abortStrong2Check3;
  abortStrong2Check3.prevThread = &servoReactionStartSlave3;
  servo2__thread.programCounter = &&servo2__thread;
  abortStrong2Check3.nextThread = &servo2__thread;
  servo2__thread.prevThread = &abortStrong2Check3;
  servoReactionEndSlave3.programCounter = &&servoReactionEndSlave3;
  servo2__thread.nextThread = &servoReactionEndSlave3;
  servoReactionEndSlave3.prevThread = &servo2__thread;

  // Swap the nested par handler with the linked list.
  servoParHandlerSlave3.prevThread -> nextThread = &servoReactionStartSlave3;
  servoReactionStartSlave3.prevThread = servoParHandlerSlave3.prevThread;
  servoReactionEndSlave3.nextThread = servoParHandlerSlave3.nextThread;
  servoParHandlerSlave3.nextThread -> prevThread = &servoReactionEndSlave3;

  // Set the core information.
  servoParCore3.activeThreads = 1;
  servoParCore3.reactionCounter = servoParReactionCounter;

  // Go to the first thread.
  goto servo2__thread;
  asm ("# par1 end");
 } else if (parId == -2) {
  // Iteration
  servoParCore3.reactionCounter = servoParReactionCounter;
  servoParCore3.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore3.reactionCounter == servoParReactionCounter);

  // Go to the next thread.
  goto servoParHandlerSlave3;
 } else if (parId == -3) {
  // Thread termination
  mainParCore3.activeThreads--;
  servoParCore3.activeThreads--;

  servoParCore3.reactionCounter = servoParReactionCounter;
  servoParCore3.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore3.reactionCounter == servoParReactionCounter);

  // Delete this par(...) handler.
  servoParHandlerSlave3.prevThread -> nextThread = servoParHandlerSlave3.nextThread;
  servoParHandlerSlave3.nextThread -> prevThread = servoParHandlerSlave3.prevThread;

  // Go to the next thread.
  goto *servoParHandlerSlave3.nextThread -> programCounter;
 } else {
  // Unscheduled par(...)
  servoParCore3.reactionCounter = servoParReactionCounter;

  servoParHandlerSlave3.programCounter = &&wrongParId_servoParHandlerSlave3;
  wrongParId_servoParHandlerSlave3:;

  servoParCore3.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore3.reactionCounter == servoParReactionCounter);
  servoParCore3.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (servoParParent.parStatus == FOREC_PAR_ON && servoParParent.parId == parId) {
   goto *servoParHandlerSlave3.nextThread -> programCounter;
  }

  // Go back to the top and wait for the next nested par(...)
  servoParHandlerSlave3.programCounter = &&servoParHandlerSlave3;
  goto servoParHandlerSlave3;
 }

 // Control should not reach here.
 goto servoParHandlerSlave3;
}
 // forec:scheduler:parHandler:servo:slave:3:end


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:3:start
 //-- main:
mainReactionStartSlave3: {
 // Go to the next thread.
 goto *mainReactionStartSlave3.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:3:end

 // forec:scheduler:reactionStart:servo:slave:3:start
 //-- servo:
servoReactionStartSlave3: {
 // Go to the next thread.
 goto *servoReactionStartSlave3.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:servo:slave:3:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:3:start
 //-- main:
mainReactionEndSlave3: {
 // Determine if the core can still react or not.
 if (mainParCore3.activeThreads) {
  mainParCore3.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore3.reactionCounter == mainParReactionCounter);
  mainParCore3.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave3.nextThread -> programCounter;
 } else {
  int parId = mainParParent.parId;

  mainReactionEndSlave3.programCounter = &&terminated_mainReactionEndSlave3;
  terminated_mainReactionEndSlave3:;

  mainParCore3.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore3.reactionCounter == mainParReactionCounter);
  mainParCore3.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave3.nextThread -> programCounter;
  }

  goto mainParCore3;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave3;
}
 // forec:scheduler:reactionEnd:main:slave:3:end

 // forec:scheduler:reactionEnd:servo:slave:3:start
 //-- servo:
servoReactionEndSlave3: {
 // Determine if the core can still react or not.
 if (servoParCore3.activeThreads) {
  servoParCore3.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (servoParCore3.reactionCounter == servoParReactionCounter);
  servoParCore3.reactionCounter++;

  // Continue reacting.
  goto *servoReactionEndSlave3.nextThread -> programCounter;
 } else {
  int parId = servoParParent.parId;

  servoReactionEndSlave3.programCounter = &&terminated_servoReactionEndSlave3;
  terminated_servoReactionEndSlave3:;

  servoParCore3.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore3.reactionCounter == servoParReactionCounter);
  servoParCore3.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (servoParParent.parStatus == FOREC_PAR_ON && servoParParent.parId == parId) {
   goto *servoReactionEndSlave3.nextThread -> programCounter;
  }

  // Swap the reaction (start & end) handlers with the nested par handler.
  servoReactionStartSlave3.prevThread -> nextThread = &servoParHandlerSlave3;
  servoParHandlerSlave3.prevThread = servoReactionStartSlave3.prevThread;
  servoParHandlerSlave3.nextThread = servoReactionEndSlave3.nextThread;
  servoReactionEndSlave3.nextThread -> prevThread = &servoParHandlerSlave3;
  goto servoParHandlerSlave3;
 }

 // Control shouldn't reach here.
 goto servoReactionEndSlave3;
}
 // forec:scheduler:reactionEnd:servo:slave:3:end



 // Abort check handlers ----------------------------------------
 // forec:scheduler:abortHandler:abortWeak0:3:start
 // abortWeak0 (!isSafe__0_0_pre_global)
abortWeak0Check3: {
 // Check the abort condition.
 if (!isSafe__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  mainParCore3.activeThreads = 0;

  goto mainReactionEndSlave3;
 }

 // Continue to the next thread.
 goto *abortWeak0Check3.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortWeak0:3:end
 // forec:scheduler:abortHandler:abortStrong2:3:start
 // abortStrong2 (terminate__0_0_pre_global)
abortStrong2Check3: {
 // Check the abort condition.
 if (terminate__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  servoParCore3.activeThreads = 0;

  goto servoReactionEndSlave3;
 }

 // Continue to the next thread.
 goto *abortStrong2Check3.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortStrong2:3:end

// forec:scheduler:parHandler:main:slave:4:start
/*--------------------------------------------------------------

| Slave core: core4

*-------------------------------------------------------------*/
# 1310 "FlyByWire.c"
mainParCore4: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave4.programCounter = &&mainReactionStartSlave4;
  servoParHandlerSlave4.programCounter = &&servoParHandlerSlave4;
  mainReactionStartSlave4.nextThread = &servoParHandlerSlave4;
  servoParHandlerSlave4.prevThread = &mainReactionStartSlave4;
  abortWeak0Check4.programCounter = &&abortWeak0Check4;
  servoParHandlerSlave4.nextThread = &abortWeak0Check4;
  abortWeak0Check4.prevThread = &servoParHandlerSlave4;
  mainReactionEndSlave4.programCounter = &&mainReactionEndSlave4;
  abortWeak0Check4.nextThread = &mainReactionEndSlave4;
  mainReactionEndSlave4.prevThread = &abortWeak0Check4;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave4.nextThread = &mainReactionStartSlave4;
  mainReactionStartSlave4.prevThread = &mainReactionEndSlave4;

  // Set the core information.
  mainParCore4.activeThreads = 1;
  mainParCore4.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto servoParHandlerSlave4;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore4.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore4.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore4.reactionCounter == mainParReactionCounter);
   mainParCore4.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...)
  goto mainParCore4;
 }

 // Control shouldn't reach here.
 goto mainParCore4;
}
// forec:scheduler:parHandler:main:slave:4:end

 // Nested par(...) handlers ------------------------------------
 // forec:scheduler:parHandler:servo:slave:4:start
 //-- Thread servo par(...) handlers
servoParHandlerSlave4: {
 // Synchronise the checking of the nested par(...) via a mutex.
 asm volatile ("get\t%0,rfsl" "0" : "=d" (forec_mutex_value));
 while ((unsigned)(forec_mutex_value & 0x80000000) == (unsigned)0x80000000) {
  asm volatile ("get\t%0,rfsl" "0" : "=d" (forec_mutex_value));
 }

 // Check the execution status of the nested par(...)s.
 if (servoParParent.parStatus == FOREC_PAR_OFF) {
  goto *servoParHandlerSlave4.nextThread -> programCounter;
 }

 int parId = servoParParent.parId;

 // Check the par(...) ID.
 if (parId == 1) {
  asm ("# par1 begin");
  // Link the threads and handlers together.
  servoReactionStartSlave4.programCounter = &&servoReactionStartSlave4;
  abortStrong2Check4.programCounter = &&abortStrong2Check4;
  servoReactionStartSlave4.nextThread = &abortStrong2Check4;
  abortStrong2Check4.prevThread = &servoReactionStartSlave4;
  servo3__thread.programCounter = &&servo3__thread;
  abortStrong2Check4.nextThread = &servo3__thread;
  servo3__thread.prevThread = &abortStrong2Check4;
  servoReactionEndSlave4.programCounter = &&servoReactionEndSlave4;
  servo3__thread.nextThread = &servoReactionEndSlave4;
  servoReactionEndSlave4.prevThread = &servo3__thread;

  // Swap the nested par handler with the linked list.
  servoParHandlerSlave4.prevThread -> nextThread = &servoReactionStartSlave4;
  servoReactionStartSlave4.prevThread = servoParHandlerSlave4.prevThread;
  servoReactionEndSlave4.nextThread = servoParHandlerSlave4.nextThread;
  servoParHandlerSlave4.nextThread -> prevThread = &servoReactionEndSlave4;

  // Set the core information.
  servoParCore4.activeThreads = 1;
  servoParCore4.reactionCounter = servoParReactionCounter;

  // Go to the first thread.
  goto servo3__thread;
  asm ("# par1 end");
 } else if (parId == -2) {
  // Iteration
  servoParCore4.reactionCounter = servoParReactionCounter;
  servoParCore4.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore4.reactionCounter == servoParReactionCounter);

  // Go to the next thread.
  goto servoParHandlerSlave4;
 } else if (parId == -3) {
  // Thread termination
  mainParCore4.activeThreads--;
  servoParCore4.activeThreads--;

  servoParCore4.reactionCounter = servoParReactionCounter;
  servoParCore4.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore4.reactionCounter == servoParReactionCounter);

  // Delete this par(...) handler.
  servoParHandlerSlave4.prevThread -> nextThread = servoParHandlerSlave4.nextThread;
  servoParHandlerSlave4.nextThread -> prevThread = servoParHandlerSlave4.prevThread;

  // Go to the next thread.
  goto *servoParHandlerSlave4.nextThread -> programCounter;
 } else {
  // Unscheduled par(...)
  servoParCore4.reactionCounter = servoParReactionCounter;

  servoParHandlerSlave4.programCounter = &&wrongParId_servoParHandlerSlave4;
  wrongParId_servoParHandlerSlave4:;

  servoParCore4.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore4.reactionCounter == servoParReactionCounter);
  servoParCore4.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (servoParParent.parStatus == FOREC_PAR_ON && servoParParent.parId == parId) {
   goto *servoParHandlerSlave4.nextThread -> programCounter;
  }

  // Go back to the top and wait for the next nested par(...)
  servoParHandlerSlave4.programCounter = &&servoParHandlerSlave4;
  goto servoParHandlerSlave4;
 }

 // Control should not reach here.
 goto servoParHandlerSlave4;
}
 // forec:scheduler:parHandler:servo:slave:4:end


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:4:start
 //-- main:
mainReactionStartSlave4: {
 // Go to the next thread.
 goto *mainReactionStartSlave4.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:4:end

 // forec:scheduler:reactionStart:servo:slave:4:start
 //-- servo:
servoReactionStartSlave4: {
 // Go to the next thread.
 goto *servoReactionStartSlave4.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:servo:slave:4:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:4:start
 //-- main:
mainReactionEndSlave4: {
 // Determine if the core can still react or not.
 if (mainParCore4.activeThreads) {
  mainParCore4.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore4.reactionCounter == mainParReactionCounter);
  mainParCore4.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave4.nextThread -> programCounter;
 } else {
  int parId = mainParParent.parId;

  mainReactionEndSlave4.programCounter = &&terminated_mainReactionEndSlave4;
  terminated_mainReactionEndSlave4:;

  mainParCore4.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore4.reactionCounter == mainParReactionCounter);
  mainParCore4.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave4.nextThread -> programCounter;
  }

  goto mainParCore4;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave4;
}
 // forec:scheduler:reactionEnd:main:slave:4:end

 // forec:scheduler:reactionEnd:servo:slave:4:start
 //-- servo:
servoReactionEndSlave4: {
 // Determine if the core can still react or not.
 if (servoParCore4.activeThreads) {
  servoParCore4.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (servoParCore4.reactionCounter == servoParReactionCounter);
  servoParCore4.reactionCounter++;

  // Continue reacting.
  goto *servoReactionEndSlave4.nextThread -> programCounter;
 } else {
  int parId = servoParParent.parId;

  servoReactionEndSlave4.programCounter = &&terminated_servoReactionEndSlave4;
  terminated_servoReactionEndSlave4:;

  servoParCore4.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore4.reactionCounter == servoParReactionCounter);
  servoParCore4.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (servoParParent.parStatus == FOREC_PAR_ON && servoParParent.parId == parId) {
   goto *servoReactionEndSlave4.nextThread -> programCounter;
  }

  // Swap the reaction (start & end) handlers with the nested par handler.
  servoReactionStartSlave4.prevThread -> nextThread = &servoParHandlerSlave4;
  servoParHandlerSlave4.prevThread = servoReactionStartSlave4.prevThread;
  servoParHandlerSlave4.nextThread = servoReactionEndSlave4.nextThread;
  servoReactionEndSlave4.nextThread -> prevThread = &servoParHandlerSlave4;
  goto servoParHandlerSlave4;
 }

 // Control shouldn't reach here.
 goto servoReactionEndSlave4;
}
 // forec:scheduler:reactionEnd:servo:slave:4:end



 // Abort check handlers ----------------------------------------
 // forec:scheduler:abortHandler:abortWeak0:4:start
 // abortWeak0 (!isSafe__0_0_pre_global)
abortWeak0Check4: {
 // Check the abort condition.
 if (!isSafe__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  mainParCore4.activeThreads = 0;

  goto mainReactionEndSlave4;
 }

 // Continue to the next thread.
 goto *abortWeak0Check4.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortWeak0:4:end
 // forec:scheduler:abortHandler:abortStrong2:4:start
 // abortStrong2 (terminate__0_0_pre_global)
abortStrong2Check4: {
 // Check the abort condition.
 if (terminate__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  servoParCore4.activeThreads = 0;

  goto servoReactionEndSlave4;
 }

 // Continue to the next thread.
 goto *abortStrong2Check4.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortStrong2:4:end

// forec:scheduler:parHandler:main:slave:5:start
/*--------------------------------------------------------------

| Slave core: core5

*-------------------------------------------------------------*/
# 1605 "FlyByWire.c"
mainParCore5: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave5.programCounter = &&mainReactionStartSlave5;
  servoParHandlerSlave5.programCounter = &&servoParHandlerSlave5;
  mainReactionStartSlave5.nextThread = &servoParHandlerSlave5;
  servoParHandlerSlave5.prevThread = &mainReactionStartSlave5;
  abortWeak0Check5.programCounter = &&abortWeak0Check5;
  servoParHandlerSlave5.nextThread = &abortWeak0Check5;
  abortWeak0Check5.prevThread = &servoParHandlerSlave5;
  mainReactionEndSlave5.programCounter = &&mainReactionEndSlave5;
  abortWeak0Check5.nextThread = &mainReactionEndSlave5;
  mainReactionEndSlave5.prevThread = &abortWeak0Check5;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave5.nextThread = &mainReactionStartSlave5;
  mainReactionStartSlave5.prevThread = &mainReactionEndSlave5;

  // Set the core information.
  mainParCore5.activeThreads = 1;
  mainParCore5.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto servoParHandlerSlave5;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore5.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore5.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore5.reactionCounter == mainParReactionCounter);
   mainParCore5.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...)
  goto mainParCore5;
 }

 // Control shouldn't reach here.
 goto mainParCore5;
}
// forec:scheduler:parHandler:main:slave:5:end

 // Nested par(...) handlers ------------------------------------
 // forec:scheduler:parHandler:servo:slave:5:start
 //-- Thread servo par(...) handlers
servoParHandlerSlave5: {
 // Synchronise the checking of the nested par(...) via a mutex.
 asm volatile ("get\t%0,rfsl" "0" : "=d" (forec_mutex_value));
 while ((unsigned)(forec_mutex_value & 0x80000000) == (unsigned)0x80000000) {
  asm volatile ("get\t%0,rfsl" "0" : "=d" (forec_mutex_value));
 }

 // Check the execution status of the nested par(...)s.
 if (servoParParent.parStatus == FOREC_PAR_OFF) {
  goto *servoParHandlerSlave5.nextThread -> programCounter;
 }

 int parId = servoParParent.parId;

 // Check the par(...) ID.
 if (parId == 1) {
  asm ("# par1 begin");
  // Link the threads and handlers together.
  servoReactionStartSlave5.programCounter = &&servoReactionStartSlave5;
  abortStrong2Check5.programCounter = &&abortStrong2Check5;
  servoReactionStartSlave5.nextThread = &abortStrong2Check5;
  abortStrong2Check5.prevThread = &servoReactionStartSlave5;
  servo1__thread.programCounter = &&servo1__thread;
  abortStrong2Check5.nextThread = &servo1__thread;
  servo1__thread.prevThread = &abortStrong2Check5;
  servoReactionEndSlave5.programCounter = &&servoReactionEndSlave5;
  servo1__thread.nextThread = &servoReactionEndSlave5;
  servoReactionEndSlave5.prevThread = &servo1__thread;

  // Swap the nested par handler with the linked list.
  servoParHandlerSlave5.prevThread -> nextThread = &servoReactionStartSlave5;
  servoReactionStartSlave5.prevThread = servoParHandlerSlave5.prevThread;
  servoReactionEndSlave5.nextThread = servoParHandlerSlave5.nextThread;
  servoParHandlerSlave5.nextThread -> prevThread = &servoReactionEndSlave5;

  // Set the core information.
  servoParCore5.activeThreads = 1;
  servoParCore5.reactionCounter = servoParReactionCounter;

  // Go to the first thread.
  goto servo1__thread;
  asm ("# par1 end");
 } else if (parId == -2) {
  // Iteration
  servoParCore5.reactionCounter = servoParReactionCounter;
  servoParCore5.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore5.reactionCounter == servoParReactionCounter);

  // Go to the next thread.
  goto servoParHandlerSlave5;
 } else if (parId == -3) {
  // Thread termination
  mainParCore5.activeThreads--;
  servoParCore5.activeThreads--;

  servoParCore5.reactionCounter = servoParReactionCounter;
  servoParCore5.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore5.reactionCounter == servoParReactionCounter);

  // Delete this par(...) handler.
  servoParHandlerSlave5.prevThread -> nextThread = servoParHandlerSlave5.nextThread;
  servoParHandlerSlave5.nextThread -> prevThread = servoParHandlerSlave5.prevThread;

  // Go to the next thread.
  goto *servoParHandlerSlave5.nextThread -> programCounter;
 } else {
  // Unscheduled par(...)
  servoParCore5.reactionCounter = servoParReactionCounter;

  servoParHandlerSlave5.programCounter = &&wrongParId_servoParHandlerSlave5;
  wrongParId_servoParHandlerSlave5:;

  servoParCore5.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore5.reactionCounter == servoParReactionCounter);
  servoParCore5.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (servoParParent.parStatus == FOREC_PAR_ON && servoParParent.parId == parId) {
   goto *servoParHandlerSlave5.nextThread -> programCounter;
  }

  // Go back to the top and wait for the next nested par(...)
  servoParHandlerSlave5.programCounter = &&servoParHandlerSlave5;
  goto servoParHandlerSlave5;
 }

 // Control should not reach here.
 goto servoParHandlerSlave5;
}
 // forec:scheduler:parHandler:servo:slave:5:end


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:5:start
 //-- main:
mainReactionStartSlave5: {
 // Go to the next thread.
 goto *mainReactionStartSlave5.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:5:end

 // forec:scheduler:reactionStart:servo:slave:5:start
 //-- servo:
servoReactionStartSlave5: {
 // Go to the next thread.
 goto *servoReactionStartSlave5.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:servo:slave:5:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:5:start
 //-- main:
mainReactionEndSlave5: {
 // Determine if the core can still react or not.
 if (mainParCore5.activeThreads) {
  mainParCore5.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore5.reactionCounter == mainParReactionCounter);
  mainParCore5.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave5.nextThread -> programCounter;
 } else {
  int parId = mainParParent.parId;

  mainReactionEndSlave5.programCounter = &&terminated_mainReactionEndSlave5;
  terminated_mainReactionEndSlave5:;

  mainParCore5.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore5.reactionCounter == mainParReactionCounter);
  mainParCore5.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave5.nextThread -> programCounter;
  }

  goto mainParCore5;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave5;
}
 // forec:scheduler:reactionEnd:main:slave:5:end

 // forec:scheduler:reactionEnd:servo:slave:5:start
 //-- servo:
servoReactionEndSlave5: {
 // Determine if the core can still react or not.
 if (servoParCore5.activeThreads) {
  servoParCore5.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (servoParCore5.reactionCounter == servoParReactionCounter);
  servoParCore5.reactionCounter++;

  // Continue reacting.
  goto *servoReactionEndSlave5.nextThread -> programCounter;
 } else {
  int parId = servoParParent.parId;

  servoReactionEndSlave5.programCounter = &&terminated_servoReactionEndSlave5;
  terminated_servoReactionEndSlave5:;

  servoParCore5.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (servoParCore5.reactionCounter == servoParReactionCounter);
  servoParCore5.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (servoParParent.parStatus == FOREC_PAR_ON && servoParParent.parId == parId) {
   goto *servoReactionEndSlave5.nextThread -> programCounter;
  }

  // Swap the reaction (start & end) handlers with the nested par handler.
  servoReactionStartSlave5.prevThread -> nextThread = &servoParHandlerSlave5;
  servoParHandlerSlave5.prevThread = servoReactionStartSlave5.prevThread;
  servoParHandlerSlave5.nextThread = servoReactionEndSlave5.nextThread;
  servoReactionEndSlave5.nextThread -> prevThread = &servoParHandlerSlave5;
  goto servoParHandlerSlave5;
 }

 // Control shouldn't reach here.
 goto servoReactionEndSlave5;
}
 // forec:scheduler:reactionEnd:servo:slave:5:end



 // Abort check handlers ----------------------------------------
 // forec:scheduler:abortHandler:abortWeak0:5:start
 // abortWeak0 (!isSafe__0_0_pre_global)
abortWeak0Check5: {
 // Check the abort condition.
 if (!isSafe__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  mainParCore5.activeThreads = 0;

  goto mainReactionEndSlave5;
 }

 // Continue to the next thread.
 goto *abortWeak0Check5.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortWeak0:5:end
 // forec:scheduler:abortHandler:abortStrong2:5:start
 // abortStrong2 (terminate__0_0_pre_global)
abortStrong2Check5: {
 // Check the abort condition.
 if (terminate__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  servoParCore5.activeThreads = 0;

  goto servoReactionEndSlave5;
 }

 // Continue to the next thread.
 goto *abortStrong2Check5.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortStrong2:5:end

// forec:scheduler:parHandler:main:slave:6:start
/*--------------------------------------------------------------

| Slave core: core6

*-------------------------------------------------------------*/
# 1900 "FlyByWire.c"
mainParCore6: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave6.programCounter = &&mainReactionStartSlave6;
  timer__thread.programCounter = &&timer__thread;
  mainReactionStartSlave6.nextThread = &timer__thread;
  timer__thread.prevThread = &mainReactionStartSlave6;
  abortWeak0Check6.programCounter = &&abortWeak0Check6;
  timer__thread.nextThread = &abortWeak0Check6;
  abortWeak0Check6.prevThread = &timer__thread;
  mainReactionEndSlave6.programCounter = &&mainReactionEndSlave6;
  abortWeak0Check6.nextThread = &mainReactionEndSlave6;
  mainReactionEndSlave6.prevThread = &abortWeak0Check6;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave6.nextThread = &mainReactionStartSlave6;
  mainReactionStartSlave6.prevThread = &mainReactionEndSlave6;

  // Set the core information.
  mainParCore6.activeThreads = 1;
  mainParCore6.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto timer__thread;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore6.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore6.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore6.reactionCounter == mainParReactionCounter);
   mainParCore6.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...)
  goto mainParCore6;
 }

 // Control shouldn't reach here.
 goto mainParCore6;
}
// forec:scheduler:parHandler:main:slave:6:end

 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:6:start
 //-- main:
mainReactionStartSlave6: {
 // Go to the next thread.
 goto *mainReactionStartSlave6.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:6:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:6:start
 //-- main:
mainReactionEndSlave6: {
 // Determine if the core can still react or not.
 if (mainParCore6.activeThreads) {
  mainParCore6.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore6.reactionCounter == mainParReactionCounter);
  mainParCore6.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave6.nextThread -> programCounter;
 } else {
  int parId = mainParParent.parId;

  mainReactionEndSlave6.programCounter = &&terminated_mainReactionEndSlave6;
  terminated_mainReactionEndSlave6:;

  mainParCore6.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore6.reactionCounter == mainParReactionCounter);
  mainParCore6.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave6.nextThread -> programCounter;
  }

  goto mainParCore6;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave6;
}
 // forec:scheduler:reactionEnd:main:slave:6:end



 // Abort check handlers ----------------------------------------
 // forec:scheduler:abortHandler:abortWeak0:6:start
 // abortWeak0 (!isSafe__0_0_pre_global)
abortWeak0Check6: {
 // Check the abort condition.
 if (!isSafe__0_0_pre_global) {
  // Force the reaction end handler to terminate the par(...).
  mainParCore6.activeThreads = 0;

  goto mainReactionEndSlave6;
 }

 // Continue to the next thread.
 goto *abortWeak0Check6.nextThread -> programCounter;
}
 // forec:scheduler:abortHandler:abortWeak0:6:end



/*==============================================================

| ForeC threads:

| Threads code translated into C code.

*=============================================================*/
# 2033 "FlyByWire.c"
 // forec:thread:flight:start
 /*--------------------------------------------------------------

	| Thread flight

	*-------------------------------------------------------------*/
# 2038 "FlyByWire.c"
 // Thread local declarations -----------------------------------
 int mode__flight_0_0;
 int decision__flight_0_0;

 // Thread body -------------------------------------------------
 flight__thread: {
  /* abortStrong1 */ {
   // forec:statement:abort:abortStrong1:start
   if (terminate__0_0_pre_global) {
    goto abortEnd_abortStrong1;
   }
   // forec:statement:abort:abortStrong1:end

   while (1) {
    if (getMode(radioInput__global_0_0) == INVALID__global_0_0) {
     mode__flight_0_0 = getMode(radioInput__global_0_0);
    } else {
     // if0
    }
    decision__flight_0_0 = autopilot(mode__flight_0_0, radioInput__global_0_0);

    // forec:statement:pause:pause1:start
    // pause;
    flight__thread.programCounter = &&pause1;
    goto *flight__thread.nextThread -> programCounter;
    pause1:;
    // forec:statement:pause:pause1:end
    // Strong aborts:
    // forec:statement:abort:abortStrong1:start
    if (terminate__0_0_pre_global) {
     goto abortEnd_abortStrong1;
    }
    // forec:statement:abort:abortStrong1:end
    asm volatile ("nop");
   }
   abortEnd_abortStrong1:;
  } // when (terminate__0_0_pre_global);
  // forec:statement:abort:abortStrong1:scope:end

  // forec:scheduler:threadRemove:flight:start

  // Delete thread from the linked list and core.
  mainParCore2.activeThreads--;
  flight__thread.nextThread -> prevThread = flight__thread.prevThread;
  flight__thread.prevThread -> nextThread = flight__thread.nextThread;
  goto *flight__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:flight:end
 } // flight__thread
 // forec:thread:flight:end

 // forec:thread:servo:start
 /*--------------------------------------------------------------

	| Thread servo

	*-------------------------------------------------------------*/
# 2093 "FlyByWire.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 servo__thread: {
  /* abortStrong2 */ {
   // forec:statement:abort:abortStrong2:start
   if (terminate__0_0_pre_global) {
    goto abortEnd_abortStrong2;
   }
   // forec:statement:abort:abortStrong2:end

   while (1) {
    // forec:statement:par:par1:start
    // par1(servo0__thread, servo1__thread, servo2__thread, servo3__thread);
    // Set the par(...) information.
    servoParParent.parId = 1;
    servoParParent.parStatus = FOREC_PAR_ON;
    servoParParent.programCounter = &&par1JoinAddress_servoParParent;

    // Remove this thread from the linked list.
    servo__thread.nextThread -> prevThread = servo__thread.prevThread;
    servo__thread.prevThread -> nextThread = servo__thread.nextThread;
    goto servoParHandlerMaster1;
    par1JoinAddress_servoParParent:;
    // forec:statement:par:par1:end

    computation();

    // forec:statement:pause:pause2:start
    // pause;
    servo__thread.programCounter = &&pause2;
    goto *servo__thread.nextThread -> programCounter;
    pause2:;
    // forec:statement:pause:pause2:end
    // Strong aborts:
    // forec:statement:abort:abortStrong2:start
    if (terminate__0_0_pre_global) {
     goto abortEnd_abortStrong2;
    }
    // forec:statement:abort:abortStrong2:end
    asm volatile ("nop");
   }
   abortEnd_abortStrong2:;
  } // when (terminate__0_0_pre_global);
  // forec:statement:abort:abortStrong2:scope:end

  // forec:scheduler:threadRemove:servo:start
  // Delete par handler
  servoParParent.parId = -3;
  servoParParent.parStatus = FOREC_PAR_ON;
  servoParParent.programCounter = &&servo_endAddress;
  goto servoParHandlerMaster1;
  servo_endAddress:;

  // Delete thread from the linked list and core.
  mainParCore1.activeThreads--;
  servo__thread.nextThread -> prevThread = servo__thread.prevThread;
  servo__thread.prevThread -> nextThread = servo__thread.nextThread;
  goto *servo__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:servo:end
 } // servo__thread
 // forec:thread:servo:end

 // forec:thread:servo0:start
 /*--------------------------------------------------------------

	| Thread servo0

	*-------------------------------------------------------------*/
# 2162 "FlyByWire.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 servo0__thread: {
  computation();
  computation();
  computation();
  computation();
  computation();
  servoOutput0__global_0_0 = 0;

  // forec:scheduler:threadRemove:servo0:start

  // Delete thread from the linked list and core.
  servoParCore1.activeThreads--;
  servo0__thread.nextThread -> prevThread = servo0__thread.prevThread;
  servo0__thread.prevThread -> nextThread = servo0__thread.nextThread;
  goto *servo0__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:servo0:end
 } // servo0__thread
 // forec:thread:servo0:end

 // forec:thread:servo1:start
 /*--------------------------------------------------------------

	| Thread servo1

	*-------------------------------------------------------------*/
# 2190 "FlyByWire.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 servo1__thread: {
  computation();
  computation();
  computation();
  computation();
  computation();
  servoOutput1__global_0_0 = 1;

  // forec:scheduler:threadRemove:servo1:start

  // Delete thread from the linked list and core.
  servoParCore5.activeThreads--;
  servo1__thread.nextThread -> prevThread = servo1__thread.prevThread;
  servo1__thread.prevThread -> nextThread = servo1__thread.nextThread;
  goto *servo1__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:servo1:end
 } // servo1__thread
 // forec:thread:servo1:end

 // forec:thread:servo2:start
 /*--------------------------------------------------------------

	| Thread servo2

	*-------------------------------------------------------------*/
# 2218 "FlyByWire.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 servo2__thread: {
  computation();
  computation();
  computation();
  computation();
  computation();
  servoOutput2__global_0_0 = 2;

  // forec:scheduler:threadRemove:servo2:start

  // Delete thread from the linked list and core.
  servoParCore3.activeThreads--;
  servo2__thread.nextThread -> prevThread = servo2__thread.prevThread;
  servo2__thread.prevThread -> nextThread = servo2__thread.nextThread;
  goto *servo2__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:servo2:end
 } // servo2__thread
 // forec:thread:servo2:end

 // forec:thread:servo3:start
 /*--------------------------------------------------------------

	| Thread servo3

	*-------------------------------------------------------------*/
# 2246 "FlyByWire.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 servo3__thread: {
  computation();
  computation();
  computation();
  computation();
  computation();
  servoOutput3__global_0_0 = 3;

  // forec:scheduler:threadRemove:servo3:start

  // Delete thread from the linked list and core.
  servoParCore4.activeThreads--;
  servo3__thread.nextThread -> prevThread = servo3__thread.prevThread;
  servo3__thread.prevThread -> nextThread = servo3__thread.nextThread;
  goto *servo3__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:servo3:end
 } // servo3__thread
 // forec:thread:servo3:end

 // forec:thread:timer:start
 /*--------------------------------------------------------------

	| Thread timer

	*-------------------------------------------------------------*/
# 2274 "FlyByWire.c"
 // Thread local declarations -----------------------------------
 int _1Hz__timer_0_0;
 int _20Hz__timer_0_0;
 char newLine__timer_2_0;

 // Thread body -------------------------------------------------
 timer__thread: {
  _1Hz__timer_0_0 = 61;
  _20Hz__timer_0_0 = 4;

  /* abortStrong3 */ {
   // forec:statement:abort:abortStrong3:start
   if (terminate__0_0_pre_global) {
    goto abortEnd_abortStrong3;
   }
   // forec:statement:abort:abortStrong3:end

   while (1) {
    if (_1Hz__timer_0_0 == 61) {
     computation();
     _1Hz__timer_0_0 = 61;
    } else {
     // if1
    }
    if (_20Hz__timer_0_0 == 4) {
     computation();
     _20Hz__timer_0_0 = 4;
    } else {
     // if2
    }
    newLine__timer_2_0 = '\n';

    while (newLine__timer_2_0 == '\n') {
     newLine__timer_2_0 = '-';

     // forec:statement:pause:pause3:start
     // pause;
     timer__thread.programCounter = &&pause3;
     goto *timer__thread.nextThread -> programCounter;
     pause3:;
     // forec:statement:pause:pause3:end
     // Strong aborts:
     // forec:statement:abort:abortStrong3:start
     if (terminate__0_0_pre_global) {
      goto abortEnd_abortStrong3;
     }
     // forec:statement:abort:abortStrong3:end
     asm volatile ("nop");
    }

    // forec:statement:pause:pause4:start
    // pause;
    timer__thread.programCounter = &&pause4;
    goto *timer__thread.nextThread -> programCounter;
    pause4:;
    // forec:statement:pause:pause4:end
    // Strong aborts:
    // forec:statement:abort:abortStrong3:start
    if (terminate__0_0_pre_global) {
     goto abortEnd_abortStrong3;
    }
    // forec:statement:abort:abortStrong3:end
    asm volatile ("nop");
   }
   abortEnd_abortStrong3:;
  } // when (terminate__0_0_pre_global);
  // forec:statement:abort:abortStrong3:scope:end

  // forec:scheduler:threadRemove:timer:start

  // Delete thread from the linked list and core.
  mainParCore6.activeThreads--;
  timer__thread.nextThread -> prevThread = timer__thread.prevThread;
  timer__thread.prevThread -> nextThread = timer__thread.nextThread;
  goto *timer__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:timer:end
 } // timer__thread
 // forec:thread:timer:end

 // forec:thread:failsafe:start
 /*--------------------------------------------------------------

	| Thread failsafe

	*-------------------------------------------------------------*/
# 2358 "FlyByWire.c"
 // Thread local declarations -----------------------------------
 int radioDownTime__failsafe_0_0;
 int spiDownTime__failsafe_0_0;

 // Thread body -------------------------------------------------
 failsafe__thread: {
  radioDownTime__failsafe_0_0 = 0;
  spiDownTime__failsafe_0_0 = 0;

  /* abortStrong4 */ {
   // forec:statement:abort:abortStrong4:start
   if (terminate__0_0_pre_global) {
    goto abortEnd_abortStrong4;
   }
   // forec:statement:abort:abortStrong4:end

   while (1) {
    computation();
    computation();
    computation();
    computation();
    if (radioInput__global_0_0 == INVALID__global_0_0) {
     radioDownTime__failsafe_0_0++;
    } else {
     // ifElse3
     radioDownTime__failsafe_0_0 = 0;
    }
    computation();
    computation();
    computation();
    computation();
    if (spiInput__global_0_0 == INVALID__global_0_0) {
     spiDownTime__failsafe_0_0++;
    } else {
     // ifElse4
     spiDownTime__failsafe_0_0 = 0;
    }
    isSafe__0_0_global_failsafe = (radioDownTime__failsafe_0_0 < MAX_DOWN_TIME__global_0_0) || (spiDownTime__failsafe_0_0 < MAX_DOWN_TIME__global_0_0);

    // forec:statement:pause:pause5:start
    // pause;
    failsafe__thread.programCounter = &&pause5;
    goto *failsafe__thread.nextThread -> programCounter;
    pause5:;
    // forec:statement:pause:pause5:end
    // Strong aborts:
    // forec:statement:abort:abortStrong4:start
    if (terminate__0_0_pre_global) {
     goto abortEnd_abortStrong4;
    }
    // forec:statement:abort:abortStrong4:end
    asm volatile ("nop");
   }
   abortEnd_abortStrong4:;
  } // when (terminate__0_0_pre_global);
  // forec:statement:abort:abortStrong4:scope:end

  // forec:scheduler:threadRemove:failsafe:start

  // Delete thread from the linked list and core.
  mainParCore0.activeThreads--;
  failsafe__thread.nextThread -> prevThread = failsafe__thread.prevThread;
  failsafe__thread.prevThread -> nextThread = failsafe__thread.nextThread;
  goto *failsafe__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:failsafe:end
 } // failsafe__thread
 // forec:thread:failsafe:end


} // End of the main() function.

int getMode(const int communicationInput__getMode_0_0) {
 int mask__getMode_0_0 = (communicationInput__getMode_0_0 & 0x02) - 1;
 mask__getMode_0_0 = mask__getMode_0_0 > 0;
 mask__getMode_0_0 = 3;
 computation();
 computation();
 return INVALID__global_0_0;
}

int autopilot(const int mode__autopilot_0_0, const int communicationInput__autopilot_0_0) {
 computation();
 computation();
 computation();
 computation();
 computation();
 computation();
 return communicationInput__autopilot_0_0*mode__autopilot_0_0;
}

void computation(void) {
 long result__computation_0_0 = 1;
 int i__computation_0_0 = 1;
 result__computation_0_0 += (long)((int)result__computation_0_0%i__computation_0_0)*(result__computation_0_0/result__computation_0_0);
}
