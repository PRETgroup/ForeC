////////////////////////////////////////////////////////////////////////////////
//
// Module       : sync_fft_che_top_tb.c
//
////////////////////////////////////////////////////////////////////////////////

shared int numberOfPipelineStages = 7;

// Constant definitions  
static const int oversampling_factor = 2;         // Data oversampling factor 
static const int buffer_len = 64;
//static const int Latency_on = 0; // switch on Latency as it is in vhdl-model 1=On 0=Off
static const int cordic_steps_c = 11;
static const int inter_reg_steps_c = 3;
static const int coriq0_in_width_c = 18;
static const int coriq0_out_width_c = 2;
static const int coriq0_alpha_width_c = 11;
static const int max_iq_width_c = 20;
static const int max_angle_width_c = 12;
static const int INTMAX = 2147483647;
static const unsigned int UINTMAX = 4294967295u;

static const long arctanTable[32] = {
	0             ,
	1267733622    , /*(long) (atan2(1.0 ,         2.0) * PI_factor),   1 */
	669835629     , /*(long) (atan2(1.0 ,         4.0) * PI_factor),   2 */
	340019024     , /*(long) (atan2(1.0 ,         8.0) * PI_factor),   3 */
	170669324     , /*(long) (atan2(1.0 ,        16.0) * PI_factor),   4 */
	85417861      , /*(long) (atan2(1.0 ,        32.0) * PI_factor),   5 */
	42719353      , /*(long) (atan2(1.0 ,        64.0) * PI_factor),   6 */
	21360980      , /*(long) (atan2(1.0 ,       128.0) * PI_factor),   7 */
	10680653      , /*(long) (atan2(1.0 ,       256.0) * PI_factor),   8 */
	5340347       , /*(long) (atan2(1.0 ,       512.0) * PI_factor),   9 */
	2670176       , /*(long) (atan2(1.0 ,      1024.0) * PI_factor),  10 */
	1335088       , /*(long) (atan2(1.0 ,      2048.0) * PI_factor),  11 */
	667544        , /*(long) (atan2(1.0 ,      4096.0) * PI_factor),  12 */
	333772        , /*(long) (atan2(1.0 ,      8192.0) * PI_factor),  13 */
	166886        , /*(long) (atan2(1.0 ,     16384.0) * PI_factor),  14 */
	83443         , /*(long) (atan2(1.0 ,     32768.0) * PI_factor),  15 */
	41722         , /*(long) (atan2(1.0 ,     65536.0) * PI_factor),  16 */
	20861         , /*(long) (atan2(1.0 ,    131072.0) * PI_factor),  17 */
	10430         , /*(long) (atan2(1.0 ,    262144.0) * PI_factor),  18 */
	5215          , /*(long) (atan2(1.0 ,    524288.0) * PI_factor),  19 */
	2608          , /*(long) (atan2(1.0 ,   1048576.0) * PI_factor),  20 */
	1304          , /*(long) (atan2(1.0 ,   2097152.0) * PI_factor),  21 */
	652           , /*(long) (atan2(1.0 ,   4194304.0) * PI_factor),  22 */
	326           , /*(long) (atan2(1.0 ,   8388608.0) * PI_factor),  23 */
	163           , /*(long) (atan2(1.0 ,  16777216.0) * PI_factor),  24 */
	81            , /*(long) (atan2(1.0 ,  33554432.0) * PI_factor),  25 */
	41            , /*(long) (atan2(1.0 ,  67108864.0) * PI_factor),  26 */
	20            , /*(long) (atan2(1.0 , 134217728.0) * PI_factor),  27 */
	10            , /*(long) (atan2(1.0 , 268435456.0) * PI_factor),  28 */
	5             , /*(long) (atan2(1.0 , 536870912.0) * PI_factor),  29 */
	3             , /*(long) (atan2(1.0 ,1073741824.0) * PI_factor),  30 */
	1               /*(long) (atan2(1.0 ,2147483648.0) * PI_factor)   31 */
};

static const int arctan_divisor_y0[10] = {
	2,		// 1
	8,		// 3
	16,		// 4
	64,		// 6
	128,	// 7
	512,	// 9
	1024,	// 10
	4096,	// 12
	8192,	// 13
	32768	// 15
};

static const int arctan_divisor_y1[10] = {
	1,		// 0
	4,		// 2
	8,		// 3
	32,		// 5
	64,		// 6
	256,	// 8
	512,	// 9
	2048,	// 11
	4096,	// 12
	16384	// 14
};

static const int arctan_divisor_x0[10] = {
	2,	// 1
	2,	// 1
	4,	// 2
	4,	// 2
	8,	// 3
	8,	// 3
	16,	// 4
	16,	// 4
	32,	// 5
	32	// 5
};

static const int arctan_divisor_x1[10] = {
	1,	// 0
	1,	// 0
	2,	// 1
	2,	// 1
	4,	// 2
	4,	// 2
	8,	// 3
	8,	// 3
	16,	// 4
	16	// 4
};

static const int correl_sum_len = 256;          // 2*8*16 = 256 Length of sliding summation over the correlations
static const int burst_threshold = 300; // Threshold value for burst detection criteria
static const int FreqEstStartSlSum = 16;  // Number of samples which will be used for
static const int FreqEstStopSlSum = 240; // the error estimation. 

static const int InLen_frac_bits = 0; // number of fractional bits in InLen
static const int Latency_on = 0; // switch on Latency as it is in vhdl-model 1=On 0=Off
static const int OutLen = 12; // precision of result
static const int Stages = 12; // number of cordic stages
static const int InLen = 10; // width of input signals
static const int FS_on = 1; // FS_on for output MUX
static const int AngLen = 11; // width of input angle
static const int IntAngLen = 16; // internal width of angle
static const int IntXYLen = 12; // internal width of x,y
static const int IntRegStages = 3; // number of cordic stages between two register stages
static const int fs_out_scale = 6;

static const int cordic_turn_divisor0[12] = {
	1,
	2,
	4,
	8,
	16,
	32,
	64,
	128,
	256,
	512,
	1024,
	2048
};

static const long arc_tan_array_c[31] = {
	1267733622,
	669835629,
	340019024,
	170669324,
	85417861,
	42719353,
	21360980,
	10680653,
	5340347,
	2670176,
	1335088,
	667544,
	333772,
	166886,
	83443,
	41722,
	20861,
	10430,
	5215,
	2608,
	1304,
	652,
	326,
	163,
	81,
	41,
	20,
	10,
	5,
	3,
	1
};

static const int Searchwin_length = 120;
static const int time_corr_long_thresh = 2000;
static const int buffer_depth = 37;

static const int data_quant_trs_real[64] = {
   -7.000000,
    1.000000,
    4.000000,
   -4.000000,
   -1.000000,
    4.000000,
   -6.000000,
   -5.000000,
   -2.000000,
   -3.000000,
   -3.000000,
    3.000000,
    4.000000,
   -6.000000,
   -3.000000,
    2.000000,
    3.000000,
    5.000000,
   -1.000000,
    3.000000,
    1.000000,
   -6.000000,
    1.000000,
    3.000000,
    4.000000,
   -2.000000,
   -5.000000,
    3.000000,
    1.000000,
    4.000000,
    2.000000,
   -1.000000,
    7.000000,
   -1.000000,
    2.000000,
    4.000000,
    1.000000,
    3.000000,
   -5.000000,
   -2.000000,
    4.000000,
    3.000000,
    1.000000,
   -6.000000,
    1.000000,
    3.000000,
   -1.000000,
    5.000000,
    3.000000,
    2.000000,
   -3.000000,
   -6.000000,
    4.000000,
    3.000000,
   -3.000000,
   -3.000000,
   -2.000000,
   -5.000000,
   -6.000000,
    4.000000,
   -1.000000,
   -4.000000,
    4.000000,
    1.000000
};
static const int data_quant_trs_imag[64] = {
    0.000000,
   -4.000000,
   -5.000000,
   -5.000000,
   -3.000000,
    3.000000,
    1.000000,
    1.000000,
    7.000000,
    1.000000,
   -4.000000,
   -1.000000,
   -4.000000,
   -3.000000,
   -2.000000,
   -4.000000,
    3.000000,
    1.000000,
   -7.000000,
    1.000000,
    3.000000,
    2.000000,
    5.000000,
   -1.000000,
    2.000000,
    5.000000,
    3.000000,
    4.000000,
   -2.000000,
   -4.000000,
    5.000000,
    5.000000,
    0.000000,
   -5.000000,
   -5.000000,
    4.000000,
    2.000000,
   -4.000000,
   -3.000000,
   -5.000000,
   -2.000000,
    1.000000,
   -5.000000,
   -2.000000,
   -3.000000,
   -1.000000,
    7.000000,
   -1.000000,
   -3.000000,
    4.000000,
    2.000000,
    3.000000,
    4.000000,
    1.000000,
    4.000000,
   -1.000000,
   -7.000000,
   -1.000000,
   -1.000000,
   -3.000000,
    3.000000,
    5.000000,
    5.000000,
    4.000000
};

// Known transmitted LTS sequence
int long_pattern_array[52] = {1, 1,-1,-1, 1, 1,-1, 1,-1, 1, 1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1,-1, 1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1,-1, 1,-1,-1,-1,-1,-1, 1, 1,-1,-1, 1,-1, 1,-1, 1, 1, 1, 1}; 
shared int *long_pattern = long_pattern_array;

static const int twiddle21_size = 12;
static const float twiddle21_re[12 /*twiddle21_size*/] = {
	 1.00000000e+00, 
	 7.07106769e-01, 
	-4.37113883e-08, 
	-7.07106769e-01,
	 1.00000000e+00, 
	 9.23879504e-01, 
	 7.07106769e-01, 
	 3.82683426e-01, 
	 1.00000000e+00, 
	 3.82683426e-01, 
	-7.07106769e-01, 
	-9.23879504e-01
};

static const float twiddle21_im[12 /*twiddle21_size*/] = {
	 0.00000000e+00, 
	-7.07106769e-01, 
	-1.00000000e+00, 
	-7.07106769e-01,
	 0.00000000e+00, 
	-3.82683456e-01, 
	-7.07106769e-01, 
	-9.23879504e-01, 
	 0.00000000e+00, 
	-9.23879504e-01, 
	-7.07106769e-01, 
	 3.82683426e-01
};

static const int twiddle43_size = 48;
static const float twiddle43_re[48 /*twiddle43_size*/] = {
	 1.00000000e+00,
	 9.80785251e-01, 
	 9.23879504e-01, 
	 8.31469595e-01, 
	 7.07106769e-01, 
	 5.55570185e-01, 
	 3.82683426e-01, 
	 1.95090234e-01,
	-4.37113883e-08, 
	-1.95090324e-01, 
	-3.82683516e-01, 
	-5.55570364e-01, 
	-7.07106769e-01, 
	-8.31469655e-01, 
	-9.23879623e-01, 
	-9.80785310e-01,
	 1.00000000e+00, 
	 9.95184720e-01, 
	 9.80785251e-01, 
	 9.56940353e-01, 
	 9.23879504e-01, 
	 8.81921232e-01, 
	 8.31469595e-01, 
	 7.73010433e-01,
	 7.07106769e-01, 
	 6.34393275e-01, 
	 5.55570185e-01, 
	 4.71396655e-01, 
	 3.82683426e-01, 
	 2.90284634e-01, 
	 1.95090234e-01,
	 9.80171338e-02,
	 1.00000000e+00, 
	 9.56940353e-01, 
	 8.31469595e-01, 
	 6.34393275e-01, 
	 3.82683426e-01, 
	 9.80171338e-02, 
	-1.95090324e-01, 
	-4.71396834e-01,
	-7.07106769e-01, 
	-8.81921351e-01, 
	-9.80785310e-01, 
	-9.95184720e-01, 
	-9.23879504e-01, 
	-7.73010373e-01, 
	-5.55570006e-01, 
	-2.90284544e-01
};

static const float twiddle43_im[48 /*twiddle43_size*/] = {
	 0.00000000e+00, 
	-1.95090324e-01, 
	-3.82683456e-01, 
	-5.55570245e-01, 
	-7.07106769e-01, 
	-8.31469655e-01, 
	-9.23879504e-01, 
	-9.80785310e-01,
	-1.00000000e+00, 
	-9.80785251e-01, 
	-9.23879504e-01, 
	-8.31469536e-01, 
	-7.07106769e-01, 
	-5.55570185e-01, 
	-3.82683277e-01, 
	-1.95090309e-01,
	 0.00000000e+00, 
	-9.80171412e-02, 
	-1.95090324e-01, 
	-2.90284663e-01, 
	-3.82683456e-01, 
	-4.71396744e-01, 
	-5.55570245e-01, 
	-6.34393334e-01,
	-7.07106769e-01, 
	-7.73010433e-01, 
	-8.31469655e-01, 
	-8.81921291e-01, 
	-9.23879504e-01, 
	-9.56940353e-01, 
	-9.80785310e-01, 
	-9.95184720e-01,
	 0.00000000e+00, 
	-2.90284663e-01, 
	-5.55570245e-01, 
	-7.73010433e-01, 
	-9.23879504e-01, 
	-9.95184720e-01, 
	-9.80785251e-01, 
	-8.81921232e-01,
	-7.07106769e-01, 
	-4.71396625e-01, 
	-1.95090309e-01, 
	 9.80172679e-02, 
	 3.82683426e-01, 
	 6.34393394e-01, 
	 8.31469774e-01, 
	 9.56940353e-01
};

typedef struct {
	int re;
	int im;
} icomplex;

typedef struct {
	float re;
	float im;
} fcomplex;

shared int input_size = 100000;
static const icomplex inputData[100] = {
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	0.00000000e+00, 
	1.00000000e+00, 
	0.00000000e+00, 
	-1.00000000e+00, 
	2.00000000e+00, 
	1.00000000e+00, 
	-1.20000000e+01, 
	-2.00000000e+01, 
	-8.00000000e+00, 
	3.00000000e+00, 
	-1.00000000e+00, 
	-3.00000000e+00, 
	7.00000000e+00, 
	3.00000000e+00, 
	-1.00000000e+01, 
	-6.00000000e+00, 
	3.00000000e+00, 
	-6.00000000e+00, 
	-1.40000000e+01, 
	0.00000000e+00, 
	1.00000000e+01, 
	-4.00000000e+00, 
	-1.40000000e+01, 
	-3.00000000e+00, 
	-3.00000000e+00, 
	-9.00000000e+00, 
	2.00000000e+00, 
	5.00000000e+00, 
	-1.40000000e+01, 
	-1.00000000e+01, 
	2.60000000e+01, 
	2.70000000e+01, 
	-1.50000000e+01, 
	-2.50000000e+01, 
	3.00000000e+00, 
	1.20000000e+01, 
	-5.00000000e+00, 
	-7.00000000e+00, 
	4.00000000e+00, 
	2.00000000e+01, 
	3.40000000e+01, 
	3.30000000e+01, 
	1.80000000e+01, 
	2.00000000e+01, 
	3.40000000e+01, 
	2.10000000e+01, 
	-4.00000000e+00, 
	-1.70000000e+01, 
	-1.90000000e+01, 
	-2.00000000e+00, 
	3.00000000e+01, 
	2.40000000e+01, 
	-3.80000000e+01, 
	-5.60000000e+01, 
	2.20000000e+01, 
	7.80000000e+01, 
	4.70000000e+01, 
	4.20000000e+01, 
	1.17000000e+02, 
	1.46000000e+02, 
	5.70000000e+01, 
	-3.20000000e+01, 
	-2.40000000e+01, 
	3.00000000e+01, 
	3.70000000e+01, 
	-1.30000000e+01, 
	-3.30000000e+01, 
	1.10000000e+01, 
	3.10000000e+01, 
	-4.30000000e+01, 
	-9.70000000e+01, 
	-9.00000000e+00, 
	6.20000000e+01, 
	-4.60000000e+01, 
	-1.38000000e+02, 
	-1.60000000e+01, 
	7.70000000e+01, 
	-7.70000000e+01, 
	-2.35000000e+02, 
	-1.65000000e+02, 
	-2.00000000e+00, 
	1.04000000e+02, 
	1.30000000e+02, 
	4.00000000e+01, 
	-7.80000000e+01, 
	-2.60000000e+01, 
	6.40000000e+01, 
	-3.00000000e+01, 
	-1.23000000e+02 
};

// freq_sync_correl_2STS
// Autocorrelation of two STS for burst detection
void computeStage0(const int bufferToggle, const icomplex freq_sync_correl_2STS_input, int data_store_real_0[], int data_store_imag_0[]);
icomplex freq_sync_correl_2STS_output[/*numberOfPipelineStages*/ 7];
icomplex correlation_1ST[/*numberOfPipelineStages*/ 7];

// frequency_sync_slidsum
void computeStage1(const int bufferToggle, const int bufferToggle_pre, int *correlation_1ST_store_index, int *freq1_i, int *freq1_q, int *freq2_i, int *freq2_q, int correlation_1ST_store_real[], int correlation_1ST_store_imag[],
				   int *burst_found_pulse_64d_index, int burst_found_pulse_64d[]);
int burst_found_out[/*numberOfPipelineStages*/ 7];
int burst_found_pulse_out[/*numberOfPipelineStages*/ 7];
icomplex freq_est_phase_out[/*numberOfPipelineStages*/ 7]; 
int freq_est_norm_out[/*numberOfPipelineStages*/ 7]; 
int freq_est_norm_max_out[/*numberOfPipelineStages*/ 7];

// arctan
// Phase calculation via arctan + Conversion from alpha into angle in radians:
void computeStage2(const int bufferToggle, int *act_angle);
int angle[/*numberOfPipelineStages*/ 7];

// cordic_turn
// Frequency Offset correction via cordic algorithm
void computeStage3(const int bufferToggle);
icomplex cordic_out[/*numberOfPipelineStages*/ 7];

// fine_time_sync
void computeStage4(const int bufferToggle, const int bufferToggle_pre, int *downsampling_flag, int *maximum_found, int data_store_real[], int data_store_imag[], int *data_store_index, 
				   int data_quant_real[], int data_quant_imag[], int *data_quant_index, int *FTS_count, int *maximum, int *maximum_new, int *fine_time_est_int, int *fine_time_est_new, int *difference_in_fine_time_est, int *maximum_found_main);
icomplex data_out_FT[/*numberOfPipelineStages*/ 7];
int maximum_found_main_array[/*numberOfPipelineStages*/ 7];
shared int *maximum_found_main = maximum_found_main_array;

// frequency_sync_slidsum
int burst_found_pulse_for_FT[/*numberOfPipelineStages*/ 7]; 

// fft64
void fft64Stage5(const int bufferToggle, const int s, const int fifo_len_div2_5, const float fifo_stage5_i_reg, const float fifo_stage5_q_reg, float *bf2_n_stage5_i, float *bf2_n_stage5_q, int *nsample_5, 
				float *fifo_i_tmp_5, float *fifo_q_tmp_5, float *bf2_fifo_stage5_i, float *bf2_fifo_stage5_q, float fifo_i_array_5[], float fifo_q_array_5[]);
void fft64Stage4(const int s4, const int s5, const int fifo_len_div2_4, const float bf2_n_stage5_i, const float bf2_n_stage5_q, const float fifo_stage4_i_reg, const float fifo_stage4_q_reg, float *bf2_n_stage4_i, float *bf2_n_stage4_q,
				 float *fifo_i_tmp_4, float *fifo_q_tmp_4, float *bf2_fifo_stage4_i, float *bf2_fifo_stage4_q, int *nsample_4, float fifo_i_array_4[], float fifo_q_array_4[]);
void fft64Stage3(const int s3, const int fifo_len_div2_3, const float fifo_stage3_i_reg, const float fifo_stage3_q_reg, const float mult_stage43_i, const float mult_stage43_q, float *bf2_n_stage3_i, float *bf2_n_stage3_q,
				 float *fifo_i_tmp_3, float *fifo_q_tmp_3, float *bf2_fifo_stage3_i, float *bf2_fifo_stage3_q, int *nsample_3, float fifo_i_array_3[], float fifo_q_array_3[]);
void fft64Stage2(const int s2, const int s3, const int fifo_len_div2_2, const float bf2_n_stage3_i, const float bf2_n_stage3_q, const float fifo_stage2_i_reg, const float fifo_stage2_q_reg,
				 float *bf2_n_stage2_i, float *bf2_n_stage2_q, int *nsample_2, float *bf2_fifo_stage2_i, float *bf2_fifo_stage2_q, float fifo_i_array_2[], float fifo_q_array_2[]);
void fft64Stage1(const int s1, const int fifo_len_div2_1, const float fifo_stage1_i_reg, const float fifo_stage1_q_reg, const float mult_stage21_i, const float mult_stage21_q,
				 float *bf2_n_stage1_i, float *bf2_n_stage1_q, int *nsample_1, float *bf2_fifo_stage1_i, float *bf2_fifo_stage1_q, float fifo_i_array_1[], float fifo_q_array_1[]);
void fft64Stage0(const int s0, const int s1, const float bf2_n_stage1_i, const float bf2_n_stage1_q, const float fifo_stage0_i_reg, const float fifo_stage0_q_reg,
				 float *bf2_n_stage0_i, float *bf2_n_stage0_q, float *bf2_fifo_stage0_i, float *bf2_fifo_stage0_q);

float re_out_array[/*numberOfPipelineStages*/ 7];
float im_out_array[/*numberOfPipelineStages*/ 7];
shared float *re_out = re_out_array;
shared float *im_out = im_out_array;

float array_re_array[64 /*buffer_len*/];
float array_im_array[64 /*buffer_len*/];
shared float *array_re = array_re_array;
shared float *array_im = array_im_array;

float *floatFirst(float **lhs, float **rhs) {
	return *lhs;
}

float real_out_demux_array[64 /*buffer_len*/];
float imag_out_demux_array[64 /*buffer_len*/];
shared float *real_out_demux = real_out_demux_array combine with floatFirst;
shared float *imag_out_demux = imag_out_demux_array combine with floatFirst;

int *intFirst(int **lhs, int **rhs) {
	return *lhs;
}

int input_CHE_real_array[104];
int input_CHE_imag_array[104];
shared int *input_CHE_real = input_CHE_real_array combine with intFirst;
shared int *input_CHE_imag = input_CHE_imag_array combine with intFirst;

int data_remove_GI_reorder_real_array[52];
int data_remove_GI_reorder_imag_array[52];
shared int *data_remove_GI_reorder_real = data_remove_GI_reorder_real_array combine with intFirst;
shared int *data_remove_GI_reorder_imag = data_remove_GI_reorder_imag_array combine with intFirst;

int output_CHE_real_array[52];
int output_CHE_imag_array[52];
shared int *output_CHE_real = output_CHE_real_array combine with intFirst;
shared int *output_CHE_imag = output_CHE_imag_array combine with intFirst;

int output_CHC_real_array[52];
int output_CHC_imag_array[52];
shared int *output_CHC_real = output_CHC_real_array combine with intFirst;
shared int *output_CHC_imag = output_CHC_imag_array combine with intFirst;

shared int counter = 0;
shared int CHE_flag = 0;
int condition3;

thread stage0(void);
thread stage1(void);
thread stage2(void);
thread stage3(void);
thread stage4(void);
thread stage5(void);
thread stage6(void);

thread demux0(void);
thread demux1(void);
thread demux2(void);
thread demux3(void);

thread removeReorder0(void);
thread removeReorder1(void);

thread inputChe0(void);
thread inputChe1(void);
thread inputChe2(void);
thread inputChe3(void);

thread outputChe0(void);
thread outputChe1(void);
thread outputChe2(void);
thread outputChe3(void);

thread outputChc0(void);
thread outputChc1(void);
thread outputChc2(void);
thread outputChc3(void);

int main(int argc, char **argv) {
	// Signal processing part:
	par(stage0, stage1, stage2, stage3, stage4, stage5, stage6);
}

thread stage0(void) {
	// "static" variable declaration
	int data_store_real_0[32*2/*oversampling_factor*/];
	int data_store_imag_0[32*2/*oversampling_factor*/];
	int i;
	for (i = 0; i < 32*oversampling_factor; i++) #64#64 {
		data_store_real_0[i] = 0;
		data_store_imag_0[i] = 0;
	}

	int bufferToggle = 0;
	int k;
	for (k = 0; k < input_size; ++k) #7#7 {
		// READ in input data for synchronization:
		icomplex freq_sync_correl_2STS_input;
		freq_sync_correl_2STS_input.re = inputData[k].re;
		freq_sync_correl_2STS_input.im = inputData[k].im;

		computeStage0(bufferToggle, freq_sync_correl_2STS_input, data_store_real_0, data_store_imag_0);

		pause;
		
		bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	}
}

// freq_sync_correl_2STS
void computeStage0(const int bufferToggle, const icomplex freq_sync_correl_2STS_input, int data_store_real_0[], int data_store_imag_0[]) {
	int data_in_i1 = freq_sync_correl_2STS_input.re / 4; // Divide input data by 4.
	int data_in_q1 = freq_sync_correl_2STS_input.im / 4;

	int data_in_idel1 = data_store_real_0[32*oversampling_factor-1] / 4;
	int data_in_qdel1 = data_store_imag_0[32*oversampling_factor-1] / 4;

	int correlation_1ST_i_1 = data_in_i1 * data_in_idel1;
	int correlation_1ST_i_2 = data_in_q1 * data_in_qdel1;
	correlation_1ST[bufferToggle].re = correlation_1ST_i_1 + correlation_1ST_i_2;

	int correlation_1ST_q_1 = data_in_q1 * data_in_idel1;
	int correlation_1ST_q_2 = data_in_i1 * data_in_qdel1;
	correlation_1ST[bufferToggle].im = correlation_1ST_q_1 - correlation_1ST_q_2;

	// output data = input data delayed by 20 samples to compensate delay of frequency_sync    
	freq_sync_correl_2STS_output[bufferToggle].re = data_store_real_0[19];
	freq_sync_correl_2STS_output[bufferToggle].im = data_store_imag_0[19];

	// Shift register for sliding summation:
	int i;
	for (i = (32*oversampling_factor-1); i > 0; i--) #63#63 {
		data_store_real_0[i] = data_store_real_0[i-1];
		data_store_imag_0[i] = data_store_imag_0[i-1];
	}

	data_store_real_0[0] = freq_sync_correl_2STS_input.re;
	data_store_imag_0[0] = freq_sync_correl_2STS_input.im; 
}

thread stage1(void) {
	// "static" variable declaration
	int freq2_i = 0;
	int freq2_q = 0;
	int freq1_i = 0;
	int freq1_q = 0;
	
	int correlation_1ST_store_real[256 /*correl_sum_len*/]; 
	int correlation_1ST_store_imag[256 /*correl_sum_len*/]; 
	int correlation_1ST_store_index;
	int burst_found_pulse_64d[64]; // For 32-cycle delay (2 times oversampled)
	int burst_found_pulse_64d_index;

	int bufferToggle = 0;
	int bufferToggle_pre = /*numberOfPipelineStages*/ 7 - 1;
	
	pause;
	
	// Initialisation
	int i;
	for (i = 0; i < (correl_sum_len); i++) #256#256 {
		correlation_1ST_store_real[i] = 0;
		correlation_1ST_store_imag[i] = 0;
	}
	correlation_1ST_store_index = 0;
	
	freq2_i = 0;
	freq2_q = 0;
	freq1_i = 0;
	freq1_q = 0;
			
	for (i = 0; i < /*numberOfPipelineStages*/ 7; i++) #7#7 {
		burst_found_out[i] = 0;
		freq_est_norm_out[i] = 0;
		freq_est_norm_max_out[i] = 0;

		freq_est_phase_out[i].re = 0;
		freq_est_phase_out[i].im = 0;
		burst_found_pulse_out[i] = 0;
	}

	for(i = 0; i < 64; i++) #64#64 {
		burst_found_pulse_64d[i] = 0;
	}
	burst_found_pulse_64d_index = 0;
	burst_found_pulse_for_FT[bufferToggle] = burst_found_pulse_64d[burst_found_pulse_64d_index];
	pause;
	bufferToggle_pre = bufferToggle;
	bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	
	int k;
	for (k = 0; k < input_size - 1; ++k) #7#7 {
		computeStage1(bufferToggle, bufferToggle_pre, &correlation_1ST_store_index, &freq1_i, &freq1_q, &freq2_i, &freq2_q, correlation_1ST_store_real, correlation_1ST_store_imag, &burst_found_pulse_64d_index, burst_found_pulse_64d);

		pause;
		
		bufferToggle_pre = bufferToggle;
		bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	}
}

// frequency_sync_slidsum
// Sliding Window autocorrelation for burst detection
// Sliding summation is done over remaining 8 short training symbols (1st two short training symbols are used for delay of auto-correlation
void computeStage1(const int bufferToggle, const int bufferToggle_pre, int *correlation_1ST_store_index, int *freq1_i, int *freq1_q, int *freq2_i, int *freq2_q, int correlation_1ST_store_real[], int correlation_1ST_store_imag[],
				   int *burst_found_pulse_64d_index, int burst_found_pulse_64d[]) {
	// Calculate auto-correlation sum for burst detection sliding summation of the single correlation values from last 256 samples
	// 8 STS-sub-sequences * (16 data bins per STS-sub-sequence) * 2 (oversampling-factor) = 256 = correl_sum_len 
	int temp1_i = correlation_1ST[bufferToggle].re - correlation_1ST_store_real[*correlation_1ST_store_index];
	*freq1_i += temp1_i;
	int temp1_q = correlation_1ST[bufferToggle].im - correlation_1ST_store_imag[*correlation_1ST_store_index];
	*freq1_q += temp1_q; 

	// Calculate auto-correlation sum for freq. offset estimation sliding summation of the single correlation values from last 256 samples
	int temp2_i = correlation_1ST_store_real[(*correlation_1ST_store_index - FreqEstStartSlSum - 1) & 255] - correlation_1ST_store_real[(*correlation_1ST_store_index - FreqEstStopSlSum - 1) & 255];
	*freq2_i += temp2_i;
	int temp2_q = correlation_1ST_store_imag[(*correlation_1ST_store_index - FreqEstStartSlSum - 1) & 255] - correlation_1ST_store_imag[(*correlation_1ST_store_index - FreqEstStopSlSum - 1) & 255];
	*freq2_q += temp2_q;  

	// Shift register for sliding summation:
	correlation_1ST_store_real[*correlation_1ST_store_index] = correlation_1ST[bufferToggle].re;
	correlation_1ST_store_imag[*correlation_1ST_store_index] = correlation_1ST[bufferToggle].im;
	*correlation_1ST_store_index = ((*correlation_1ST_store_index + 1) & 255);

	// Norm of auto-correlation of burst detection
	int freq1_i_tmp = *freq1_i / 8192;
	int freq1_q_tmp = *freq1_q / 8192;
	freq_est_norm_out[bufferToggle] = (freq1_i_tmp*freq1_i_tmp) + (freq1_q_tmp*freq1_q_tmp);

	// Find start point, when looking for max. in auto-correlation (magn)
	burst_found_out[bufferToggle] = burst_found_out[bufferToggle_pre];
	freq_est_norm_max_out[bufferToggle] = freq_est_norm_max_out[bufferToggle_pre];
	
	if (freq_est_norm_out[bufferToggle] > burst_threshold && burst_found_out[bufferToggle] == 0) {
		burst_found_out[bufferToggle] = 1;
		freq_est_norm_max_out[bufferToggle] = freq_est_norm_out[bufferToggle];
	}
	
	freq_est_phase_out[bufferToggle].re = freq_est_phase_out[bufferToggle_pre].re;
	freq_est_phase_out[bufferToggle].im = freq_est_phase_out[bufferToggle_pre].im;
	burst_found_pulse_out[bufferToggle] = burst_found_pulse_out[bufferToggle_pre];

	if (burst_found_out[bufferToggle] == 1) {
		// Start now looking for new max in freq_est_norm
		if (freq_est_norm_out[bufferToggle] > freq_est_norm_max_out[bufferToggle]) {
			freq_est_norm_max_out[bufferToggle] = freq_est_norm_out[bufferToggle];
			freq_est_phase_out[bufferToggle].re = *freq2_i >> 5;
			freq_est_phase_out[bufferToggle].im = *freq2_q >> 5;
			burst_found_pulse_out[bufferToggle] = 0;
		} else {
			burst_found_pulse_out[bufferToggle] = 1;
		}    
	} else {
		burst_found_pulse_out[bufferToggle] = 0;
	}

	// shift register for delay chain
	burst_found_pulse_64d[*burst_found_pulse_64d_index] = burst_found_pulse_out[bufferToggle];
	*burst_found_pulse_64d_index = (*burst_found_pulse_64d_index + 1) & 63;

	burst_found_pulse_for_FT[bufferToggle] = burst_found_pulse_64d[*burst_found_pulse_64d_index];
}

thread stage2(void) {
	// "static" variable declaration
	int act_angle;

	int bufferToggle = 0;
		
	pause;
	pause;
	
	// Initialisation
	act_angle = 0;
	int a;
	for (a = 0; a < /*numberOfPipelineStages*/ 7; a++) #7#7 {
		angle[a] = 0;
	}
	pause;
	bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
		
	int k;
	for (k = 0; k < input_size - 1; ++k) #7#7 {
		computeStage2(bufferToggle, &act_angle);

		pause;

		bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	}
}

// arctan
// Angle calculation of I/Q-Datapairs using the arctan and
// calculates radians per sample from radians per Long Training Symbol.
void computeStage2(const int bufferToggle, int *act_angle) { 
	// Init:
	unsigned int ExactAngle    = UINTMAX - 1048575;	// UINTMAX - (unsigned int) (pow(2.0, 32 - max_angle_width_c) - 1);
	unsigned int ExactInternal = 4294963200u; // ((unsigned int) pow(2.0, max_iq_width_c) - 1) * 2^(32-max_iq_width_c);

	unsigned int LSB_Ang    = 1048576; // 2^(32 - max_angle_width_c);
	unsigned int LSB_Int    = 4096; // 2^(32 - max_iq_width_c);
	unsigned int LSB_OutAng = 2097152; // 2^(32 - coriq0_alpha_width_c);

	/* INPUT PATTERN */
	long xin = freq_est_phase_out[bufferToggle].re;
	long yin = freq_est_phase_out[bufferToggle].im;

	/* CALCULATION */
	xin += (xin == -131072);	// (xin == -pow(2, coriq0_in_width_c-1));
	yin += (yin == -131072);	//(yin == -pow(2, coriq0_in_width_c-1));

	long x_i_temp0 = xin * 4096; // (xin * 2^(30 - coriq0_in_width_c));
	long x_i_temp1 = yin * 4096; // (yin * 2^(30 - coriq0_in_width_c));
	if (x_i_temp0 < 0) {
		x_i_temp0 = -x_i_temp0;
	}
	if (x_i_temp1 < 0) {
		x_i_temp1 = -x_i_temp1;
	}
	signed int x_i = x_i_temp0 + x_i_temp1;	// abs(xin * 2^(30 - coriq0_in_width_c)) + abs(yin * 2^(30 - coriq0_in_width_c));

	long y_i_temp0 = yin * 4096; // (yin * 2^(30 - coriq0_in_width_c));
	long y_i_temp1 = xin * 4096; // (xin * 2^(30 - coriq0_in_width_c));
	if (y_i_temp0 < 0) {
		y_i_temp0 = -y_i_temp0;
	}
	if (y_i_temp1 < 0) {
		y_i_temp1 = -y_i_temp1;
	}
	signed int y_i = y_i_temp0 - y_i_temp1;	// abs(yin * 2^(30 - coriq0_in_width_c)) - abs(xin * 2^(30 - coriq0_in_width_c));

	signed int z_i = 536870912;// ((int) pow(2.0, max_angle_width_c-3)) * 2^(32 - max_angle_width_c);

	/* ***** Computation of Cordic iterations.*/
	signed int i;
	signed int x_i_1, y_i_1, z_i_1;
	for (i = 1; i < cordic_steps_c; i++) #10#10 {
		if (y_i > 0) {
		//	x_i_1 = x_i + (((y_i >> (i+i/2)) & ExactInternal)   + ((y_i >> (i+i/2-1)) & LSB_Int));
		//	y_i_1 = y_i - (((x_i >> (i-i/2)) & ExactInternal)   + ((x_i >> (i-i/2-1)) & LSB_Int));
		//	z_i_1 = z_i + (((arctanTable[i] >> 2) & ExactAngle) + ((arctanTable[i] >> 1) & LSB_Ang));

			x_i_1 = x_i + (((y_i / arctan_divisor_y0[i-1]) & ExactInternal) + ((y_i / arctan_divisor_y1[i-1]) & LSB_Int));
			y_i_1 = y_i - (((x_i / arctan_divisor_x0[i-1]) & ExactInternal) + ((x_i / arctan_divisor_x1[i-1]) & LSB_Int));
			z_i_1 = z_i + (((arctanTable[i] / 4) & ExactAngle) + ((arctanTable[i] / 2) & LSB_Ang));
		} else {
		//	x_i_1 = x_i - (((y_i >> (i+i/2)) & ExactInternal)   + ((y_i >> (i+i/2-1)) & LSB_Int));
		//	y_i_1 = y_i + (((x_i >> (i-i/2)) & ExactInternal)   + ((x_i >> (i-i/2-1)) & LSB_Int));
		//	z_i_1 = z_i - (((arctanTable[i] >> 2) & ExactAngle) + ((arctanTable[i] >> 1) & LSB_Ang));

			x_i_1 = x_i - (((y_i / arctan_divisor_y0[i-1]) & ExactInternal) + ((y_i / arctan_divisor_y1[i-1]) & LSB_Int));
			y_i_1 = y_i + (((x_i / arctan_divisor_x0[i-1]) & ExactInternal) + ((x_i / arctan_divisor_x1[i-1]) & LSB_Int));
			z_i_1 = z_i - (((arctanTable[i] / 4) & ExactAngle) + ((arctanTable[i] / 2) & LSB_Ang));
		}
		x_i = x_i_1 & ExactInternal;
		y_i = y_i_1 & ExactInternal;
		z_i = z_i_1 & ExactAngle;

		if (i/2 != i*((float)0.5)) {
			y_i = y_i << 1;
		}
	}

	long angle_temp = (z_i + ((z_i * 2) & LSB_OutAng)) / 2097152; // (32 - coriq0_alpha_width_c);
	
	if (xin >= 0 && yin < 0) {
		angle_temp = -(angle_temp);
	} else if (xin < 0 && yin >= 0) {
	//	angle_temp = (INTMAX >> (32 - coriq0_alpha_width_c)) + 1 - angle_temp;
		angle_temp = (INTMAX /2097152) + 1 - angle_temp;
	} else if (xin < 0 && yin < 0) {
	//	angle_temp = angle_temp - (INTMAX >> (32-coriq0_alpha_width_c)) - 1;
		angle_temp = angle_temp - (INTMAX / 2097152) - 1;
	} else if (xin == 0 && yin == 0) {
		angle_temp = -1;
	}
 		
	if (angle_temp == 1024) {	// pow(2, coriq0_alpha_width_c-1)
		angle_temp = -angle_temp;
	}

	/* OUTPUT PATTER */
	int alpha_out_latency[5];	// alpha_out_latency[(cordic_steps_c/inter_reg_steps_c)+2];
	int alpha_out;
	if (Latency_on == 0) {
		alpha_out = (int)(angle_temp);
	} else {
		alpha_out = (int)(alpha_out_latency[0]);
	}

	int rad_tmp = -alpha_out;
	if (burst_found_pulse_out[bufferToggle] == 0) {
		*act_angle = 0;
	} 
	*act_angle += rad_tmp;

	if (*act_angle < -65536){
		*act_angle = 131072 + *act_angle;
	} else if (*act_angle > 65535){
		*act_angle = -131072 + *act_angle;
	}

	angle[bufferToggle] = *act_angle / 64;

	for (i = 1; i < (cordic_steps_c/inter_reg_steps_c) + 2; i++) #4#4 {
		alpha_out_latency[i-1] = alpha_out_latency[i];
	}

	if (cordic_steps_c % inter_reg_steps_c == 0) {
		alpha_out_latency[3] = angle[bufferToggle];	// alpha_out_latency[(cordic_steps_c/inter_reg_steps_c)]
	} else {
		alpha_out_latency[4] = angle[bufferToggle];	// alpha_out_latency[(cordic_steps_c/inter_reg_steps_c) + 1]
	}
}

thread stage3(void) {
	int bufferToggle = 0;

	pause;
	pause;
	pause;
	
	// Initialisation 
	pause; 
	bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	
	int k;
	for (k = 0; k < input_size - 1; ++k) #7#7 {
		computeStage3(bufferToggle);
		
		pause;

		bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	}
}

// cordic_turn
// Cordic (derotation) algorithm
void computeStage3(const int bufferToggle) {
	// INPUT PATTERN 
	long x_in_reg = (long)(freq_sync_correl_2STS_output[bufferToggle].re * 1);	// (long)(xin * pow(2.0, (double) InLen_frac_bits));
	long y_in_reg = (long)(freq_sync_correl_2STS_output[bufferToggle].im * 1);	// (long)(yin * pow(2.0, (double) InLen_frac_bits));
	long angle_in_reg = (long)(angle[bufferToggle]);

	// CALCULATION
	int msb_reg = (int)(angle_in_reg / 256 /*(AngLen - 3)*/);
	msb_reg &= 7;

	long z_reg;
	if(((angle_in_reg / 256 /*(AngLen - 3)*/) & 1) == 1) {
		z_reg = -1;
	} else {
		z_reg = 0;
	}

	z_reg = z_reg * 512 /*(AngLen - 2)*/ | (angle_in_reg & ((long) (512 /*pow(2.0, (double) (AngLen - 2) )*/) - 1));
	z_reg = z_reg * 32; // (IntAngLen - AngLen);

	long x_temp = x_in_reg * 4; // (IntXYLen - InLen);
	long y_temp = y_in_reg * 4; // (IntXYLen - InLen);

	// --------------------------------------------------------------------- 
	// -- Evaluate first three MSB's of input angle and do a pre-rotation)   
	// --------------------------------------------------------------------- 
	long x_reg, y_reg;
	if (msb_reg == 0 || msb_reg == 7) {
		// angle in [-1/4 Pi; 1/4 Pi] 
		x_reg = x_temp;
		y_reg = y_temp;
	} else if (msb_reg == 5 || msb_reg == 6) {
		// angle in [-3/4 Pi;-1/4 Pi] 
		x_reg = y_temp;
		y_reg = -x_temp;
	} else if (msb_reg == 3 || msb_reg == 4) {
		// angle in [ 3/4 Pi; PI],[-Pi;-3/4 Pi]
		x_reg = -x_temp;
		y_reg = -y_temp;
	} else {
		// angle in [ 1/4 Pi; 3/4 Pi]
		x_reg = -y_temp;
		y_reg = x_temp;
	}

	// -------------------------------------------------------------------
	// --  Cordic - Algorithm                                             
	// -------------------------------------------------------------------
	int i;
	for(i = 1; i < Stages; i++) #11#11 {
		if(z_reg < 0){
			x_temp = x_reg + (y_reg / cordic_turn_divisor0[i]) + ((y_reg / cordic_turn_divisor0[i-1]) & 1);
			y_temp = y_reg - (x_reg / cordic_turn_divisor0[i]) - ((x_reg / cordic_turn_divisor0[i-1]) & 1);
		//	z_reg  = z_reg + (arc_tan_array_c[i-1] >> (34 - IntAngLen)) + ((arc_tan_array_c[i-1] >> (33 - IntAngLen)) & 1);
			z_reg  = z_reg + (arc_tan_array_c[i-1] / 262144) + ((arc_tan_array_c[i-1] / 131072) & 1);
		} else {
			x_temp = x_reg - (y_reg / cordic_turn_divisor0[i]) - ((y_reg / cordic_turn_divisor0[i-1]) & 1);
			y_temp = y_reg + (x_reg / cordic_turn_divisor0[i]) + ((x_reg / cordic_turn_divisor0[i-1]) & 1);
		//	z_reg  = z_reg - (arc_tan_array_c[i-1] >> (34 - IntAngLen)) - ((arc_tan_array_c[i-1] >> (33 - IntAngLen)) & 1);
			z_reg  = z_reg - (arc_tan_array_c[i-1] / 262144) - ((arc_tan_array_c[i-1] / 131072) & 1);
		}
		x_reg = x_temp;
		y_reg = y_temp;
	}

	// OUTPUT PATTER
	long res_x_latency[6];	// res_x_latency[(Stages/IntRegStages)+2];
	long res_y_latency[6];	// res_y_latency[(Stages/IntRegStages)+2];
	float res_x;
	float res_y;
	if (Latency_on == 0) {
		res_x = (float) (x_reg / 4 /*(IntXYLen - OutLen + 2)*/) / (float)1; // pow(2.0, (double) InLen_frac_bits);
		res_y = (float) (y_reg / 4 /*(IntXYLen - OutLen + 2)*/) / (float)1; // pow(2.0, (double) InLen_frac_bits);
	} else {
		res_x = (float) (res_x_latency[0] / 4 /*(IntXYLen - OutLen + 2)*/) / (float)1; // pow(2.0, (double) InLen_frac_bits);
		res_y = (float) (res_y_latency[0] / 4 /*(IntXYLen - OutLen + 2)*/) / (float)1; // pow(2.0, (double) InLen_frac_bits);
	}

	int res_out_x = (int)(res_x);
	int res_out_y = (int)(res_y);

	// Output MUX:
	// If FS_on == true  => frequency corrected data muxed to the output
	// If FS_on == false => cordic input data is only bypassed to the output without any correction
	if (FS_on == 1) {
		cordic_out[bufferToggle].re = (res_out_x * fs_out_scale)/16; // >> 4;
		cordic_out[bufferToggle].im = (res_out_y * fs_out_scale)/16; // >> 4;
	} else {
		cordic_out[bufferToggle].re = freq_sync_correl_2STS_output[bufferToggle].re;
		cordic_out[bufferToggle].im = freq_sync_correl_2STS_output[bufferToggle].im;
	}
		
	for (i = 1; i < (Stages/IntRegStages) + 2; i++) #5#5 {
		res_x_latency[i-1] = res_x_latency[i];
		res_y_latency[i-1] = res_y_latency[i];
	}
	
	if (Stages % IntRegStages == 0) {
		res_x_latency[4] = x_reg;	// res_x_latency[(Stages/IntRegStages)]
		res_y_latency[4] = y_reg;	// res_y_latency[(Stages/IntRegStages)]
	} else {
		res_x_latency[5] = x_reg;	// res_x_latency[(Stages/IntRegStages) + 1]
		res_y_latency[5] = y_reg;	// res_y_latency[(Stages/IntRegStages) + 1]
	}
}


thread stage4(void) {
	// "static" variable declaration
	int data_store_real[64 /*buffer_depth*/];
	int data_store_imag[64 /*buffer_depth*/];
	int data_store_index = 0;
	int data_quant_real[64];
	int data_quant_imag[64];
	int data_quant_index = 0;
	
	int fine_time_est_int = 0;
	int fine_time_est_new = 0;
	int FTS_count = 0;
	int difference_in_fine_time_est;
	int maximum;
	int maximum_new;
	int maximum_found;
	int downsampling_flag = 1;
	int i;
	for (i = 0; i < buffer_depth; i++) #37#37 {
		data_store_real[i] = (float)0.0;
		data_store_imag[i] = (float)0.0;
		data_quant_real[i] = (float)0.0;
		data_quant_imag[i] = (float)0.0;
	}

	int bufferToggle = 0;
	int bufferToggle_pre = /*numberOfPipelineStages*/ 7 - 1;

	pause;
	pause;
	pause;
	pause;
	
	// Initialisation
	maximum_found_main[bufferToggle] = maximum_found_main[bufferToggle_pre];
	data_out_FT[bufferToggle].re = data_out_FT[bufferToggle_pre].re;
	data_out_FT[bufferToggle].im = data_out_FT[bufferToggle_pre].im;
	pause;
	bufferToggle_pre = bufferToggle;
	bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	
	int k;
	for (k = 0; k < input_size - 1; ++k) #7#7 {
		computeStage4(bufferToggle, bufferToggle_pre, &downsampling_flag, &maximum_found, data_store_real, data_store_imag, &data_store_index, data_quant_real, data_quant_imag, &data_quant_index, &FTS_count, &maximum, &maximum_new, &fine_time_est_int, &fine_time_est_new, &difference_in_fine_time_est, maximum_found_main);

		pause;
		
		bufferToggle_pre = bufferToggle;
		bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	}
}

// fine_time_sync
// Fine time synchronization using crosscorrelation
// Fine time estimation: Finds exact start of Long TS1 (after Long GI)
void computeStage4(const int bufferToggle, const int bufferToggle_pre, int *downsampling_flag, int *maximum_found, int data_store_real[], int data_store_imag[], int *data_store_index, 
				   int data_quant_real[], int data_quant_imag[], int *data_quant_index, int *FTS_count, int *maximum, int *maximum_new, int *fine_time_est_int, int *fine_time_est_new, int *difference_in_fine_time_est,
				   int *maximum_found_main) {
	maximum_found_main[bufferToggle] = maximum_found_main[bufferToggle_pre];
	data_out_FT[bufferToggle].re = data_out_FT[bufferToggle_pre].re;
	data_out_FT[bufferToggle].im = data_out_FT[bufferToggle_pre].im;
	
	// 2-times Downsampling of input data ("data_in_real/imag" and of    
	if (*downsampling_flag == 0) {
		// delay data by 32+RxTimingOffset samples (after LongGI, start of LTS1)
		if (*maximum_found == 1) {
			data_out_FT[bufferToggle].re = (int)(data_store_real[*data_store_index]);
			data_out_FT[bufferToggle].im = (int)(data_store_imag[*data_store_index]);
			maximum_found_main[bufferToggle] = 1;
		} else {
			data_out_FT[bufferToggle].re = 0; 
			data_out_FT[bufferToggle].im = 0;
			maximum_found_main[bufferToggle] = 0;
		}
		
		data_store_real[*data_store_index] = cordic_out[bufferToggle].re;
		data_store_imag[*data_store_index] = cordic_out[bufferToggle].im;
		*data_store_index = (*data_store_index + 1) % buffer_depth;
	
		int data_in_sign_re;
		if (cordic_out[bufferToggle].re > 0) {
			data_in_sign_re = 1;
		} else if (cordic_out[bufferToggle].re < 0) {
			data_in_sign_re = -1;
		} else {
			data_in_sign_re = 0;
		}

		int data_in_sign_im;
		if (cordic_out[bufferToggle].im > 0) {
			data_in_sign_im = 1;
		} else if (cordic_out[bufferToggle].im < 0) {
			data_in_sign_im = -1;
		} else {
			data_in_sign_im = 0;
		}

		data_quant_real[*data_quant_index]= data_in_sign_re;
		data_quant_imag[*data_quant_index]= data_in_sign_im;
		*data_quant_index= (*data_quant_index + 1) & 63;

		int j;
		int time_corr_long_re = 0;
		int time_corr_long_im = 0;
		for(j = 0; j < 64; j++) #64#64 {
			int time_corr_long_re_1 = (int)(data_quant_real[(*data_quant_index + j) & 63] * data_quant_trs_real[j]);
			int time_corr_long_re_2 = (int)(data_quant_imag[(*data_quant_index + j) & 63] * data_quant_trs_imag[j]);
			time_corr_long_re += time_corr_long_re_1 + time_corr_long_re_2;
		
			int time_corr_long_im_1 = (int)(data_quant_imag[(*data_quant_index + j) & 63] * data_quant_trs_real[j]);
			int time_corr_long_im_2 = (int)(data_quant_real[(*data_quant_index + j) & 63] * data_quant_trs_imag[j]);
			time_corr_long_im += time_corr_long_im_1 - time_corr_long_im_2;
		}
	
		int time_corr_long_re_temp = time_corr_long_re;
		if (time_corr_long_re_temp < 0) {
			time_corr_long_re_temp = -time_corr_long_re_temp;
		}
		time_corr_long_re_temp = (time_corr_long_re_temp >> 2);

		int time_corr_long_im_temp = time_corr_long_im;
		if (time_corr_long_im_temp < 0) {
			time_corr_long_im_temp = -time_corr_long_im_temp;
		}
		time_corr_long_im_temp = time_corr_long_im_temp >>2;
			
		int time_corr_long_norm = time_corr_long_re_temp*time_corr_long_re_temp + time_corr_long_im_temp*time_corr_long_im_temp;	// ((abs(time_corr_long_re)>>2) * (abs(time_corr_long_re)>>2) + (abs(time_corr_long_im)>>2)*(abs(time_corr_long_im)>>2));

		if (burst_found_pulse_for_FT[bufferToggle] == 0) {
			*FTS_count = 0;
			*maximum = time_corr_long_thresh;
			*fine_time_est_int = 0;
			*maximum_found = 0; 
		} else {
			if (*FTS_count < Searchwin_length) {

				// Storing the two maximum LTS peak values.
				if (time_corr_long_norm >= *maximum) {
					*maximum_new = time_corr_long_norm;
			
					// store maximum estimation value index
					*fine_time_est_new = *FTS_count;
			
					// This variable looks for the distance between the two maximas:
					*difference_in_fine_time_est =* fine_time_est_new - *fine_time_est_int;

					if ((*difference_in_fine_time_est < 60 || *difference_in_fine_time_est > 68) || *maximum_found == 0) {    
						*fine_time_est_int = *fine_time_est_new;
						*maximum_found = 1;
					}
				}
		
				*FTS_count = *FTS_count + 1;
			}
		} 
		*downsampling_flag = 1;
	} else {
		*downsampling_flag = 0;
	}
}

thread stage5(void) {
	// "static variables
	int cnt_16 = 0;
	int cnt_64 = 0;
	int cnt_128 = 0;

	int downsampling_flag = 0;
	int mk_test = 0;
	int GI_Flag = 0;
	
	//  bf2 & FIFO stage5
	float bf2_fifo_stage5_i= (float)0.0;
	float bf2_fifo_stage5_q= (float)0.0;
	float fifo_stage5_i_reg= (float)0.0;
	float fifo_stage5_q_reg= (float)0.0;
	float bf2_n_stage5_i= (float)0.0;
	float bf2_n_stage5_q= (float)0.0;
  
	//  bf2 & FIFO stage4
	float bf2_fifo_stage4_i= (float)0.0;
	float bf2_fifo_stage4_q= (float)0.0;
	float fifo_stage4_i_reg= (float)0.0;
	float fifo_stage4_q_reg= (float)0.0;
	float bf2_n_stage4_i= (float)0.0;
	float bf2_n_stage4_q= (float)0.0;

	//  bf2 & FIFO stage3
	float bf2_fifo_stage3_i= (float)0.0;
	float bf2_fifo_stage3_q= (float)0.0;
	float fifo_stage3_i_reg= (float)0.0;
	float fifo_stage3_q_reg= (float)0.0;
	float bf2_n_stage3_i= (float)0.0;
	float bf2_n_stage3_q= (float)0.0;

	//  bf2 & FIFO stage2
	float bf2_fifo_stage2_i= (float)0.0;
	float bf2_fifo_stage2_q= (float)0.0;
	float fifo_stage2_i_reg= (float)0.0;
	float fifo_stage2_q_reg= (float)0.0;
	float bf2_n_stage2_i= (float)0.0;
	float bf2_n_stage2_q= (float)0.0;

	//  bf2 & FIFO stage1
	float bf2_fifo_stage1_i= (float)0.0;
	float bf2_fifo_stage1_q= (float)0.0;
	float fifo_stage1_i_reg= (float)0.0;
	float fifo_stage1_q_reg= (float)0.0;
	float bf2_n_stage1_i= (float)0.0;
	float bf2_n_stage1_q= (float)0.0;

	//  bf2 & FIFO stage0
	float bf2_fifo_stage0_i= (float)0.0;
	float bf2_fifo_stage0_q= (float)0.0;
	float fifo_stage0_i_reg= (float)0.0;
	float fifo_stage0_q_reg= (float)0.0;
	float bf2_n_stage0_i= (float)0.0;
	float bf2_n_stage0_q= (float)0.0;

	int cnt_index = 0;
	int multiple_streams_index = 0;

	int fifo_len_div2_1 = 1;
	int nsample_1 = 0;
	float fifo_i_array_1[3];
	float fifo_q_array_1[3];
	int a;
	for (a = 0; a < 3; a++) #3#3 {
		fifo_i_array_1[a] = (float)0.0;
		fifo_q_array_1[a] = (float)0.0;
	}

	int fifo_len_div2_4 = 15;
	int nsample_4 = 0;
	float fifo_i_array_4[31];
	float fifo_q_array_4[31];
	for (a = 0; a < 31; a++) #31#31 {
		fifo_i_array_4[a]= (float)0.0;
		fifo_q_array_4[a]= (float)0.0;
	}
	float fifo_i_tmp_4 = (float)0.0;
	float fifo_q_tmp_4 = (float)0.0;

	int fifo_len_div2_5 = 31;
	int nsample_5 = 0;
	float fifo_i_array_5[63];
	float fifo_q_array_5[63];
	for (a = 0; a < 63; a++) #63#63 {
		fifo_i_array_5[a] = (float)0.0;
		fifo_q_array_5[a] = (float)0.0;
	}
	float fifo_i_tmp_5 = (float)0.0;
	float fifo_q_tmp_5 = (float)0.0;

	int fifo_len_div2_2 = 3;
	int nsample_2 = 0;
	float fifo_i_array_2[7];
	float fifo_q_array_2[7];
	for (a = 0; a < 7; a++) #7#7 {
		fifo_i_array_2[a] = (float)0.0;
		fifo_q_array_2[a] = (float)0.0;
	}
	
	int fifo_len_div2_3 = 7;
	int nsample_3 = 0;
	float fifo_i_array_3[15];
	float fifo_q_array_3[15];
	for (a = 0; a < 15; a++) #15#15 {
		fifo_i_array_3[a] = (float)0.0;
		fifo_q_array_3[a] = (float)0.0;
	}
	float fifo_i_tmp_3;
	float fifo_q_tmp_3;
	
	// Nothing
	int bufferToggle = 0;

	pause;
	pause;
	pause;
	pause;
	pause;

	int k;
	for (k = 0; k < input_size; ++k) #7#7 {
		// downsampling 2:1
		if (downsampling_flag == 0) {
			if (maximum_found_main[bufferToggle] == 1) {
				// Remove Guard Interval (or better here: Mark guard interval data with a Flag. GI_Flag = '1' = > GI-Data...)
				if (mk_test == 0) {
					cnt_128 = 0;
					cnt_64 = 0;
					cnt_16 = 0;
					GI_Flag = 0;
				} else {
					// For LTS1 and LTS2:
					if (cnt_128 < 127) {
						cnt_128++;
						GI_Flag = 0;
					} else {
						// For GI:
						if ((cnt_16 < 16) && (cnt_64 == 0)) {
							GI_Flag = 1;
							cnt_16++;
						} else {
							// For data:
							if (cnt_64 < 63) {
								GI_Flag = 0;
								cnt_64++;
							} else {
								cnt_64 = 0;
								cnt_16 = 0;
							}
						}
					}
				}

				// FIXME
				// Only "real" data, which is related to GI_Flag = 0 is processed further:
				if (GI_Flag == 0) {
					mk_test = 1;
					// fft64
					{
						re_out[bufferToggle] = bf2_n_stage0_i;
						im_out[bufferToggle] = bf2_n_stage0_q;
					  
						int s[6];
						s[0] = (cnt_index % 2 > 0);
						s[1] = (cnt_index % 4 > 1);
						s[2] = (cnt_index % 8 > 3);
						s[3] = (cnt_index % 16 > 7);
						s[4] = (cnt_index % 32 > 15);
						s[5] = (cnt_index % 64 > 31);
				
						// stage5, bf2i, fifo=32
						fft64Stage5(bufferToggle, s[5], fifo_len_div2_5, fifo_stage5_i_reg, fifo_stage5_q_reg, &bf2_n_stage5_i, &bf2_n_stage5_q, &nsample_5, &fifo_i_tmp_5, &fifo_q_tmp_5, &bf2_fifo_stage5_i, &bf2_fifo_stage5_q, fifo_i_array_5, fifo_q_array_5);

						fifo_stage5_i_reg = bf2_fifo_stage5_i;
						fifo_stage5_q_reg = bf2_fifo_stage5_q;
				
						// stage4, bf2ii
						fft64Stage4(s[4], s[5], fifo_len_div2_4, bf2_n_stage5_i, bf2_n_stage5_q, fifo_stage4_i_reg, fifo_stage4_q_reg, &bf2_n_stage4_i, &bf2_n_stage4_q, &fifo_i_tmp_4, &fifo_q_tmp_4, &bf2_fifo_stage4_i, &bf2_fifo_stage4_q, &nsample_4, fifo_i_array_4, fifo_q_array_4);

						fifo_stage4_i_reg = bf2_fifo_stage4_i;
						fifo_stage4_q_reg = bf2_fifo_stage4_q;
					  
						// multiplier stage 4-3
						float mult_stage43_i, mult_stage43_q;
						int twiddle43_ptr = multiple_streams_index % 64;
						{
							int twiddle_ptr_tmp;
							if (twiddle43_ptr < twiddle43_size) {
								twiddle_ptr_tmp = twiddle43_ptr;
							} else {
								twiddle_ptr_tmp = 0;
							}

							float calc1_re = bf2_n_stage4_i*twiddle43_re[twiddle_ptr_tmp];
							float calc2_re = bf2_n_stage4_q*twiddle43_im[twiddle_ptr_tmp];

							float calc1_im = bf2_n_stage4_i*twiddle43_im[twiddle_ptr_tmp];
							float calc2_im = bf2_n_stage4_q*twiddle43_re[twiddle_ptr_tmp];

							mult_stage43_i = calc1_re - calc2_re;
							mult_stage43_q = calc1_im + calc2_im;
						}

						// stage3, bf2i
						fft64Stage3(s[3], fifo_len_div2_3, fifo_stage3_i_reg, fifo_stage3_q_reg, mult_stage43_i, mult_stage43_q, &bf2_n_stage3_i, &bf2_n_stage3_q, &fifo_i_tmp_3, &fifo_q_tmp_3, &bf2_fifo_stage3_i, &bf2_fifo_stage3_q, &nsample_3, fifo_i_array_3, fifo_q_array_3);

						fifo_stage3_i_reg = bf2_fifo_stage3_i;
						fifo_stage3_q_reg = bf2_fifo_stage3_q;

						// stage2, bf2ii
						fft64Stage2(s[2], s[3], fifo_len_div2_2, bf2_n_stage3_i, bf2_n_stage3_q, fifo_stage2_i_reg, fifo_stage2_q_reg, &bf2_n_stage2_i, &bf2_n_stage2_q, &nsample_2, &bf2_fifo_stage2_i, &bf2_fifo_stage2_q, fifo_i_array_2, fifo_q_array_2);

						fifo_stage2_i_reg = bf2_fifo_stage2_i;
						fifo_stage2_q_reg = bf2_fifo_stage2_q;

						// multiplier stage 2-1
						float mult_stage21_i, mult_stage21_q;
						int twiddle21_ptr = multiple_streams_index % 16;
						{
							int twiddle_ptr_tmp;
							if (twiddle21_ptr < twiddle21_size) {
								twiddle_ptr_tmp = twiddle21_ptr;
							} else {
								twiddle_ptr_tmp = 0;
							}
				
							float calc1_re = bf2_n_stage2_i*twiddle21_re[twiddle_ptr_tmp];
							float calc2_re = bf2_n_stage2_q*twiddle21_im[twiddle_ptr_tmp];

							float calc1_im = bf2_n_stage2_i*twiddle21_im[twiddle_ptr_tmp];
							float calc2_im = bf2_n_stage2_q*twiddle21_re[twiddle_ptr_tmp];

							mult_stage21_i = calc1_re - calc2_re;
							mult_stage21_q = calc1_im + calc2_im;
						}
				
						// stage1, bf2i
						fft64Stage1(s[1], fifo_len_div2_1, fifo_stage1_i_reg, fifo_stage1_q_reg, mult_stage21_i, mult_stage21_q, &bf2_n_stage1_i, &bf2_n_stage1_q, &nsample_1, &bf2_fifo_stage1_i, &bf2_fifo_stage1_q, fifo_i_array_1, fifo_q_array_1);

						fifo_stage1_i_reg = bf2_fifo_stage1_i;
						fifo_stage1_q_reg = bf2_fifo_stage1_q;

						// stage0, bf2ii
						fft64Stage0(s[0], s[1], bf2_n_stage1_i, bf2_n_stage1_q, fifo_stage0_i_reg, fifo_stage0_q_reg, &bf2_n_stage0_i, &bf2_n_stage0_q, &bf2_fifo_stage0_i, &bf2_fifo_stage0_q);

						fifo_stage0_i_reg = bf2_fifo_stage0_i;
						fifo_stage0_q_reg = bf2_fifo_stage0_q;
			
						if (multiple_streams_index < 63) {
							multiple_streams_index++;
						} else {
							multiple_streams_index = 0;
						}

						if(cnt_index < 63) {
							cnt_index++;
						} else {
							cnt_index = 0;
						}
					}
				}
			}
			
			downsampling_flag = downsampling_flag = 1;
		} else {
			downsampling_flag = downsampling_flag = 0;
		}
		
		pause;
	
		bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	}
}

// stage5, bf2i, fifo=32
void fft64Stage5(const int bufferToggle, const int s5, const int fifo_len_div2_5, const float fifo_stage5_i_reg, const float fifo_stage5_q_reg, float *bf2_n_stage5_i, float *bf2_n_stage5_q, int *nsample_5, 
				float *fifo_i_tmp_5, float *fifo_q_tmp_5, float *bf2_fifo_stage5_i, float *bf2_fifo_stage5_q, float fifo_i_array_5[], float fifo_q_array_5[]) {
	float bf2_ndiv2_stage5_i;
	float bf2_ndiv2_stage5_q;
	float data_out_FT_re = (float)data_out_FT[bufferToggle].re;
	float data_out_FT_im = (float)data_out_FT[bufferToggle].im;

	if (s5 == 1) {
		*bf2_n_stage5_i = fifo_stage5_i_reg + data_out_FT_re;
		*bf2_n_stage5_q = fifo_stage5_q_reg + data_out_FT_im;
		bf2_ndiv2_stage5_i = fifo_stage5_i_reg - data_out_FT_re;
		bf2_ndiv2_stage5_q = fifo_stage5_q_reg - data_out_FT_im;
	} else {
		bf2_ndiv2_stage5_i = data_out_FT_re;
		bf2_ndiv2_stage5_q = data_out_FT_im;
		*bf2_n_stage5_i = fifo_stage5_i_reg;
		*bf2_n_stage5_q = fifo_stage5_q_reg;
	}
	{
		*bf2_fifo_stage5_i = *fifo_i_tmp_5;
		*bf2_fifo_stage5_q = *fifo_q_tmp_5;
	  
		int nsample_r;
		if (*nsample_5 < 1) {
			nsample_r = 1;
		} else {
			if (*nsample_5 > fifo_len_div2_5 - 2) {
				nsample_r = 0;
			} else {
				nsample_r = *nsample_5 + 1;
			}
		}

		*fifo_i_tmp_5 = fifo_i_array_5[nsample_r];
		*fifo_q_tmp_5 = fifo_q_array_5[nsample_r];
	  
		fifo_i_array_5[*nsample_5] = bf2_ndiv2_stage5_i;
		fifo_q_array_5[*nsample_5] = bf2_ndiv2_stage5_q;
	  
		if (*nsample_5 < fifo_len_div2_5-1) {
			*nsample_5 = *nsample_5 + 1;
		} else {
			*nsample_5 = 0;
		}
	}
}

// stage4, bf2ii
void fft64Stage4(const int s4, const int s5, const int fifo_len_div2_4, const float bf2_n_stage5_i, const float bf2_n_stage5_q, const float fifo_stage4_i_reg, const float fifo_stage4_q_reg, float *bf2_n_stage4_i, float *bf2_n_stage4_q,
				 float *fifo_i_tmp_4, float *fifo_q_tmp_4, float *bf2_fifo_stage4_i, float *bf2_fifo_stage4_q, int *nsample_4, float fifo_i_array_4[], float fifo_q_array_4[]) {
	float bf2_ndiv2_stage4_i;
	float bf2_ndiv2_stage4_q;

	if (s4 == 0) { 
		// shifting
		bf2_ndiv2_stage4_i = bf2_n_stage5_i;
		bf2_ndiv2_stage4_q = bf2_n_stage5_q;
		*bf2_n_stage4_i = fifo_stage4_i_reg;
		*bf2_n_stage4_q = fifo_stage4_q_reg;
	} else {
		// caculating
		float tmp2_real, tmp2_imag;
		if (s5 == 0) {
			// swap
			tmp2_real = bf2_n_stage5_q;
			tmp2_imag = -bf2_n_stage5_i;
		} else { 
			// no swap
			tmp2_real = bf2_n_stage5_i;
			tmp2_imag = bf2_n_stage5_q;
		}
		
		*bf2_n_stage4_i = fifo_stage4_i_reg + tmp2_real;
		*bf2_n_stage4_q = fifo_stage4_q_reg + tmp2_imag;
		bf2_ndiv2_stage4_i = fifo_stage4_i_reg - tmp2_real;
		bf2_ndiv2_stage4_q = fifo_stage4_q_reg - tmp2_imag;
	}
	{
		*bf2_fifo_stage4_i = *fifo_i_tmp_4;
		*bf2_fifo_stage4_q = *fifo_q_tmp_4;
	
		int nsample_r;
		if (*nsample_4 < 1) {
			nsample_r = 1;
		} else {
			if (*nsample_4 > fifo_len_div2_4 - 2) {
				nsample_r = 0;
			} else {
				nsample_r = *nsample_4 + 1;
			}
		}

		*fifo_i_tmp_4 = fifo_i_array_4[nsample_r];
		*fifo_q_tmp_4 = fifo_q_array_4[nsample_r];

		fifo_i_array_4[*nsample_4] = bf2_ndiv2_stage4_i;
		fifo_q_array_4[*nsample_4] = bf2_ndiv2_stage4_q;

		if (*nsample_4 < fifo_len_div2_4 - 1) {
			*nsample_4 = *nsample_4 + 1;
		} else {
			*nsample_4 = 0;
		}
	}
}

// stage3, bf2i
void fft64Stage3(const int s3, const int fifo_len_div2_3, const float fifo_stage3_i_reg, const float fifo_stage3_q_reg, const float mult_stage43_i, const float mult_stage43_q, float *bf2_n_stage3_i, float *bf2_n_stage3_q,
				 float *fifo_i_tmp_3, float *fifo_q_tmp_3, float *bf2_fifo_stage3_i, float *bf2_fifo_stage3_q, int *nsample_3, float fifo_i_array_3[], float fifo_q_array_3[]) {
	float bf2_ndiv2_stage3_i;
	float bf2_ndiv2_stage3_q;

	if (s3 == 1) {
		*bf2_n_stage3_i = fifo_stage3_i_reg + mult_stage43_i;
		*bf2_n_stage3_q = fifo_stage3_q_reg + mult_stage43_q;
		bf2_ndiv2_stage3_i = fifo_stage3_i_reg - mult_stage43_i;
		bf2_ndiv2_stage3_q = fifo_stage3_q_reg - mult_stage43_q;
	} else {

		bf2_ndiv2_stage3_i = mult_stage43_i;
		bf2_ndiv2_stage3_q = mult_stage43_q;
		*bf2_n_stage3_i = fifo_stage3_i_reg;
		*bf2_n_stage3_q = fifo_stage3_q_reg;
	}
	{
		*bf2_fifo_stage3_i = *fifo_i_tmp_3;
		*bf2_fifo_stage3_q = *fifo_q_tmp_3;
	  
		int nsample_r;
		if (*nsample_3 < 1) {
			nsample_r = 1;
		} else {
			if (*nsample_3 > fifo_len_div2_3 - 2) {
				nsample_r = 0;
			} else {
				nsample_r = *nsample_3 + 1;
			}
		}

		*fifo_i_tmp_3 = fifo_i_array_3[nsample_r];
		*fifo_q_tmp_3 = fifo_q_array_3[nsample_r];

		fifo_i_array_3[*nsample_3] = bf2_ndiv2_stage3_i;
		fifo_q_array_3[*nsample_3] = bf2_ndiv2_stage3_q;
	  	
		if (*nsample_3 < fifo_len_div2_3 - 1) {
			*nsample_3 = *nsample_3 + 1;
		} else {
			*nsample_3 = 0;
		}
	}
}

// stage2, bf2ii
void fft64Stage2(const int s2, const int s3, const int fifo_len_div2_2, const float bf2_n_stage3_i, const float bf2_n_stage3_q, const float fifo_stage2_i_reg, const float fifo_stage2_q_reg,
				 float *bf2_n_stage2_i, float *bf2_n_stage2_q, int *nsample_2, float *bf2_fifo_stage2_i, float *bf2_fifo_stage2_q, float fifo_i_array_2[], float fifo_q_array_2[]) {
	float bf2_ndiv2_stage2_i;
	float bf2_ndiv2_stage2_q;
	if (s2 == 0) { 
		// shifting
		bf2_ndiv2_stage2_i = bf2_n_stage3_i;
		bf2_ndiv2_stage2_q = bf2_n_stage3_q;
		*bf2_n_stage2_i = fifo_stage2_i_reg;
		*bf2_n_stage2_q = fifo_stage2_q_reg;
	} else {
		// caculating
		float tmp2_real, tmp2_imag;
		if (s3 == 0) {
			// swap
			tmp2_real = bf2_n_stage3_q;
			tmp2_imag = -bf2_n_stage3_i;
		} else { 
			// no swap
			tmp2_real = bf2_n_stage3_i;
			tmp2_imag = bf2_n_stage3_q;
		}
		
		*bf2_n_stage2_i = fifo_stage2_i_reg + tmp2_real;
		*bf2_n_stage2_q = fifo_stage2_q_reg + tmp2_imag;
		bf2_ndiv2_stage2_i = fifo_stage2_i_reg - tmp2_real;
		bf2_ndiv2_stage2_q = fifo_stage2_q_reg - tmp2_imag;
	}
	{
		*bf2_fifo_stage2_i = fifo_i_array_2[*nsample_2];
		*bf2_fifo_stage2_q = fifo_q_array_2[*nsample_2];

		fifo_i_array_2[*nsample_2] = bf2_ndiv2_stage2_i;
		fifo_q_array_2[*nsample_2] = bf2_ndiv2_stage2_q;

		if (*nsample_2 < fifo_len_div2_2 - 1) {
			*nsample_2 = *nsample_2 + 1;
		} else {
			*nsample_2 = 0;
		}
	}
}

// stage1, bf2i
void fft64Stage1(const int s1, const int fifo_len_div2_1, const float fifo_stage1_i_reg, const float fifo_stage1_q_reg, const float mult_stage21_i, const float mult_stage21_q,
				 float *bf2_n_stage1_i, float *bf2_n_stage1_q, int *nsample_1, float *bf2_fifo_stage1_i, float *bf2_fifo_stage1_q, float fifo_i_array_1[], float fifo_q_array_1[]) {
	float bf2_ndiv2_stage1_i;
	float bf2_ndiv2_stage1_q;
	if (s1 == 1) {
		*bf2_n_stage1_i = fifo_stage1_i_reg + mult_stage21_i;
		*bf2_n_stage1_q = fifo_stage1_q_reg + mult_stage21_q;
		bf2_ndiv2_stage1_i = fifo_stage1_i_reg - mult_stage21_i;
		bf2_ndiv2_stage1_q = fifo_stage1_q_reg - mult_stage21_q;
	} else {

		bf2_ndiv2_stage1_i = mult_stage21_i;
		bf2_ndiv2_stage1_q = mult_stage21_q;
		*bf2_n_stage1_i = fifo_stage1_i_reg;
		*bf2_n_stage1_q = fifo_stage1_q_reg;
	}
	{
		*bf2_fifo_stage1_i = fifo_i_array_1[*nsample_1];
		*bf2_fifo_stage1_q = fifo_q_array_1[*nsample_1];

		fifo_i_array_1[*nsample_1] = bf2_ndiv2_stage1_i;
		fifo_q_array_1[*nsample_1] = bf2_ndiv2_stage1_q;
	
		if (*nsample_1 < fifo_len_div2_1 - 1) {
			*nsample_1 = *nsample_1 + 1;
		} else {
			*nsample_1 = 0;
		}
	}
}

// stage0, bf2ii
void fft64Stage0(const int s0, const int s1, const float bf2_n_stage1_i, const float bf2_n_stage1_q, const float fifo_stage0_i_reg, const float fifo_stage0_q_reg,
				 float *bf2_n_stage0_i, float *bf2_n_stage0_q, float *bf2_fifo_stage0_i, float *bf2_fifo_stage0_q) {
	float bf2_ndiv2_stage0_i;
	float bf2_ndiv2_stage0_q;
	if (s0 == 0) { 
		// shifting
		bf2_ndiv2_stage0_i = bf2_n_stage1_i;
		bf2_ndiv2_stage0_q = bf2_n_stage1_q;
		*bf2_n_stage0_i = fifo_stage0_i_reg;
		*bf2_n_stage0_q = fifo_stage0_q_reg;
	} else {
		// caculating
		float tmp2_real, tmp2_imag;
		if (s1 == 0) {
			// swap
			tmp2_real = bf2_n_stage1_q;
			tmp2_imag = -bf2_n_stage1_i;
		} else { 
			// no swap
			tmp2_real = bf2_n_stage1_i;
			tmp2_imag = bf2_n_stage1_q;
		}
		
		*bf2_n_stage0_i = fifo_stage0_i_reg + tmp2_real;
		*bf2_n_stage0_q = fifo_stage0_q_reg + tmp2_imag;
		bf2_ndiv2_stage0_i = fifo_stage0_i_reg - tmp2_real;
		bf2_ndiv2_stage0_q = fifo_stage0_q_reg - tmp2_imag;
	}
	{
		*bf2_fifo_stage0_i = bf2_ndiv2_stage0_i;
		*bf2_fifo_stage0_q = bf2_ndiv2_stage0_q;
	}
}

thread stage6(void) {
	// "static" variables
	int cnt_16 = 0;
	int cnt_64 = 0;
	int cnt_128 = 0;
	
	int inv_int = 0;
	int mux_cnt = 0;
	int a;
	for (a = 0; a < buffer_len; a++) #64#64 {
		array_re[a] = (float)0.0;
		array_im[a] = (float)0.0;
	}

	int downsampling_flag = 0;
	int mk_test = 0;
	int GI_Flag = 0;
	int i = 0;
	
	// Nothing
	int bufferToggle = 0;

	pause;
	pause;
	pause;
	pause;
	pause;
	pause;

	int k;
	for (k = 0; k < input_size; ++k) #7#7 {
		// downsampling 2:1
		if (downsampling_flag == 0) {
			if (maximum_found_main[bufferToggle] == 1) {
				// Remove Guard Interval (or better here: Mark guard interval data with a Flag. GI_Flag = '1' = > GI-Data...)
				if (mk_test == 0) {
					cnt_128 = 0;
					cnt_64 = 0;
					cnt_16 = 0;
					GI_Flag = 0;
				} else {
					// For LTS1 and LTS2:
					if (cnt_128 < 127) {
						cnt_128++;
						GI_Flag = 0;
					} else {
						// For GI:
						if ((cnt_16 < 16) && (cnt_64 == 0)) {
							GI_Flag = 1;
							cnt_16++;
						} else {
							// For data:
							if (cnt_64 < 63) {
								GI_Flag = 0;
								cnt_64++;
							} else {
								cnt_64 = 0;
								cnt_16 = 0;
							}
						}
					}
				}
				
				// FIXME
				// Only "real" data, which is related to GI_Flag = 0 is processed further:
				if (GI_Flag == 0) {
					mk_test = 1;
					
					// mstream_demux
					// Demultiplexing of the data-stream for multi-stream mode and reordering of FFT output to get linear output.
					{
						int index_int = inv_int + mux_cnt;
						array_re[index_int] = re_out[bufferToggle];
						array_im[index_int] = im_out[bufferToggle];

						/*
						int m_int = 64 >> 1;	// 32
						if (inv_int < 63) {
							while (m_int >= 2 && inv_int >= m_int) #5#5 {
								inv_int -= m_int;
								m_int >>= 1;
							}
							inv_int += m_int;
						} else {
							inv_int = 0;
						}
						*/

						int m_int = 64 >> 1;	// 32
						int condition3 = inv_int - 63;
						condition3 = condition3 < 0;

						int condition0 = m_int - 1;
						condition0 = condition0 > 0;
						int condition1 = inv_int - m_int + 1;
						condition1 = condition1 > 0;
						int condition2 = (condition0 + condition1) == 2;
						condition2 = condition2 * condition3;
				
						while (condition2) #5#5 {
							inv_int -= m_int;
							m_int = m_int / 2; 
					
							condition0 = m_int - 1;
							condition0 = condition0 > 0;
							condition1 = inv_int - m_int + 1;
							condition1 = condition1 > 0;
							condition2 = (condition0 + condition1) == 2;
							condition2 = condition2 * condition3;
						}
						inv_int = (inv_int + m_int) * condition3;
					}
				
					par(demux0, demux1, demux2, demux3);

					// scale_reorder_removeGB
					// Scale FFT output data, reorder data and remove the guard band (12 subcarriers):
					// For 802.11a the data order has to be reordered again according to the standard: 
					// Also 12 data values of the guard band have to be removed => Only 52 data values out of 64 data values are processed further.
					par(removeReorder0, removeReorder1);
					par(inputChe0, inputChe1, inputChe2, inputChe3);

					// channel_estimation
					// Channel estimation (CHE):
					/*
					This model performs the 802.11a channel estimation in the frequency domain.
					Incoming LTS parts are first averaged and then multiplied by the frequency domain LTS values.

					It is assumed, that only when burst_start_found is '1' and a valid LTS is found,
					data is applied to the input of the channel estimation module for further signal processing.
					*/
					/* Initial 104 samples corresponds to lts part (2 Long Training Symbols)
					   Calculate average of the 2 LTS */
					// Least square estimation = Received sequence * Known_sequence(BPSK)
					par(outputChe0, outputChe1, outputChe2, outputChe3);

					// channel_correction
					// Channel correction (CHC):
					/*
					This model performs the 802.11a channel CORRECTION in the frequency domain.
					Conjugate complex multiplication of CHE-output with payload-data.
					*/
					par(outputChc0, outputChc1, outputChc2, outputChc3);
						
					if (counter < 63) {
						counter++;
					} else {
						counter = 0;

						// incrementing CHE_flag
						if (CHE_flag < 5) {
							CHE_flag++;
						}
					}
				}
			}
			
			downsampling_flag = 1;
		} else {
			downsampling_flag = 0;
		}

		pause;
		
		bufferToggle = (bufferToggle + 1) % /*numberOfPipelineStages*/ 7;
	}
}

thread demux0(void) {
	int i;
	for (i = 0; i < 16; i++) #16#16 {
		if (counter < 63) {
			real_out_demux[i] = array_re[i];
			imag_out_demux[i] = array_im[i];
		}
	}
}

thread demux1(void) {
	int i;
	for (i = 16; i < 32; i++) #16#16 {
		if (counter < 63) {
			real_out_demux[i] = array_re[i];
			imag_out_demux[i] = array_im[i];
		}
	}
}

thread demux2(void) {
	int i;
	for (i = 32; i < 48; i++) #16#16 {
		if (counter < 63) {
			real_out_demux[i] = array_re[i];
			imag_out_demux[i] = array_im[i];
		}
	}
}

thread demux3(void) {
	int i;
	for (i = 48; i < 64; i++) #16#16 {
		if (counter < 63) {
			real_out_demux[i] = array_re[i];
			imag_out_demux[i] = array_im[i];
		}
	}
}

thread removeReorder0(void) {
	float FFT_output_scale = ((float)11.0)/((float)8.0);
	int j;
	for (j = 0; j < 13; j++) #13#13 {
		if (counter < 63) {
			data_remove_GI_reorder_real[j+26] = (int)(FFT_output_scale * real_out_demux[j+1]);
			data_remove_GI_reorder_imag[j+26] = (int)(FFT_output_scale * imag_out_demux[j+1]);
			data_remove_GI_reorder_real[j] = (int)(FFT_output_scale * real_out_demux[j+38]);
			data_remove_GI_reorder_imag[j] = (int)(FFT_output_scale * imag_out_demux[j+38]);
		}
	}
}

thread removeReorder1(void) {
	float FFT_output_scale = ((float)11.0)/((float)8.0);
	int j;
	for (j = 13; j < 26; j++) #13#13 {
		if (counter < 63) {
			data_remove_GI_reorder_real[j+26] = (int)(FFT_output_scale * real_out_demux[j+1]);
			data_remove_GI_reorder_imag[j+26] = (int)(FFT_output_scale * imag_out_demux[j+1]);
			data_remove_GI_reorder_real[j] = (int)(FFT_output_scale * real_out_demux[j+38]);
			data_remove_GI_reorder_imag[j] = (int)(FFT_output_scale * imag_out_demux[j+38]);
		}
	}
}

thread inputChe0(void) {
	int j;
	for (j = 0; j < 13; j++) #13#13 {
		if (counter < 63) {
			if (CHE_flag == 1) {
				input_CHE_real[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_real[j]);
				input_CHE_imag[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_imag[j]);
			}
			if (CHE_flag == 2) {
				input_CHE_real[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_real[j]);
				input_CHE_imag[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_imag[j]);
			}
		}
	}
}

thread inputChe1(void) {
	int j;
	for (j = 13; j < 26; j++) #13#13 {
		if (counter < 63) {
			if (CHE_flag == 1) {
				input_CHE_real[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_real[j]);
				input_CHE_imag[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_imag[j]);
			}
			if (CHE_flag == 2) {
				input_CHE_real[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_real[j]);
				input_CHE_imag[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_imag[j]);
			}
		}
	}
}

thread inputChe2(void) {
	int j;
	for (j = 26; j < 39; j++) #13#13 {
		if (counter < 63) {
			if (CHE_flag == 1) {
				input_CHE_real[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_real[j]);
				input_CHE_imag[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_imag[j]);
			}
			if (CHE_flag == 2) {
				input_CHE_real[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_real[j]);
				input_CHE_imag[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_imag[j]);
			}
		}
	}
}

thread inputChe3(void) {
	int j;
	for (j = 39; j < 52; j++) #13#13 {
		if (counter < 63) {
			if (CHE_flag == 1) {
				input_CHE_real[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_real[j]);
				input_CHE_imag[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_imag[j]);
			}
			if (CHE_flag == 2) {
				input_CHE_real[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_real[j]);
				input_CHE_imag[j+((CHE_flag-1)*52)] = (data_remove_GI_reorder_imag[j]);
			}
		}
	}
}

thread outputChe0(void) {
	int i;
	for (i = 0; i < 13; i++) #13#13 {
		if (counter < 63) {
			output_CHE_real[i] = ((input_CHE_real[i] + input_CHE_real[i+52])/2 * long_pattern[i]);
			output_CHE_imag[i] = ((input_CHE_imag[i] + input_CHE_imag[i+52])/2 * long_pattern[i]);
		}
	}
}

thread outputChe1(void) {
	int i;
	for (i = 13; i < 26; i++) #13#13 {
		if (counter < 63) {
			output_CHE_real[i] = ((input_CHE_real[i] + input_CHE_real[i+52])/2 * long_pattern[i]);
			output_CHE_imag[i] = ((input_CHE_imag[i] + input_CHE_imag[i+52])/2 * long_pattern[i]);
		}
	}
}

thread outputChe2(void) {
	int i;
	for (i = 26; i < 39; i++) #13#13 {
		if (counter < 63) {
			output_CHE_real[i] = ((input_CHE_real[i] + input_CHE_real[i+52])/2 * long_pattern[i]);
			output_CHE_imag[i] = ((input_CHE_imag[i] + input_CHE_imag[i+52])/2 * long_pattern[i]);
		}
	}
}

thread outputChe3(void) {
	int i;
	for (i = 39; i < 52; i++) #13#13 {
		if (counter < 63) {
			output_CHE_real[i] = ((input_CHE_real[i] + input_CHE_real[i+52])/2 * long_pattern[i]);
			output_CHE_imag[i] = ((input_CHE_imag[i] + input_CHE_imag[i+52])/2 * long_pattern[i]);
		}
	}
}

thread outputChc0(void) {
	int *output_CHC_real_ptr, *output_CHC_imag_ptr;
	output_CHC_real_ptr = output_CHC_real;
	output_CHC_imag_ptr = output_CHC_imag;
	
	int i;
	for (i = 0; i < 13; i++) #13#13 {
		if (counter < 63) {
			long int mult_CHC_I = data_remove_GI_reorder_real[i] * output_CHE_real[i] + data_remove_GI_reorder_imag[i] * output_CHE_imag[i];
			long int mult_CHC_Q = -data_remove_GI_reorder_real[i] * output_CHE_imag[i] + data_remove_GI_reorder_imag[i] * output_CHE_real[i];
			output_CHC_real_ptr[i] = (mult_CHC_I / 1024);
			output_CHC_imag_ptr[i] = (mult_CHC_Q / 1024);
		}
	}
}

thread outputChc1(void) {
	int *output_CHC_real_ptr, *output_CHC_imag_ptr;
	output_CHC_real_ptr = output_CHC_real;
	output_CHC_imag_ptr = output_CHC_imag;
	
	int i;
	for (i = 13; i < 26; i++) #13#13 {
		if (counter < 63) {
			long int mult_CHC_I = data_remove_GI_reorder_real[i] * output_CHE_real[i] + data_remove_GI_reorder_imag[i] * output_CHE_imag[i];
			long int mult_CHC_Q = -data_remove_GI_reorder_real[i] * output_CHE_imag[i] + data_remove_GI_reorder_imag[i] * output_CHE_real[i];
			output_CHC_real_ptr[i] = (mult_CHC_I / 1024);
			output_CHC_imag_ptr[i] = (mult_CHC_Q / 1024);
		}
	}
}

thread outputChc2(void) {
	int *output_CHC_real_ptr, *output_CHC_imag_ptr;
	output_CHC_real_ptr = output_CHC_real;
	output_CHC_imag_ptr = output_CHC_imag;
	
	int i;
	for (i = 26; i < 39; i++) #13#13 { 
		if (counter < 63) {
			long int mult_CHC_I = data_remove_GI_reorder_real[i] * output_CHE_real[i] + data_remove_GI_reorder_imag[i] * output_CHE_imag[i];
			long int mult_CHC_Q = -data_remove_GI_reorder_real[i] * output_CHE_imag[i] + data_remove_GI_reorder_imag[i] * output_CHE_real[i];
			output_CHC_real_ptr[i] = (mult_CHC_I / 1024);
			output_CHC_imag_ptr[i] = (mult_CHC_Q / 1024);
		}
	}
}

thread outputChc3(void) {
	int *output_CHC_real_ptr, *output_CHC_imag_ptr;
	output_CHC_real_ptr = output_CHC_real;
	output_CHC_imag_ptr = output_CHC_imag;
	
	int i;
	for (i = 39; i < 52; i++) #13#13 { 
		if (counter < 63) {
			long int mult_CHC_I = data_remove_GI_reorder_real[i] * output_CHE_real[i] + data_remove_GI_reorder_imag[i] * output_CHE_imag[i];
			long int mult_CHC_Q = -data_remove_GI_reorder_real[i] * output_CHE_imag[i] + data_remove_GI_reorder_imag[i] * output_CHE_real[i];
			output_CHC_real_ptr[i] = (mult_CHC_I / 1024);
			output_CHC_imag_ptr[i] = (mult_CHC_Q / 1024);
		}
	}
}

