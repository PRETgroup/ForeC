# 1 "1D_CFD.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "1D_CFD.c"
/*==============================================================

| Hardware architecture specific declarations:

| Cores, mutex and input/output information.

*=============================================================*/
# 5 "1D_CFD.c"
// Xilinx Microblaze
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Driver parameters

*

*******************************************************************/
# 18 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver MPMC */


/* Definitions for peripheral DDR_SDRAM */
# 42 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/


/* Definitions for peripheral DDR_SDRAM */
# 82 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral DDR_SDRAM */
# 105 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver GPIO */


/* Definitions for peripheral AUDIO */







/* Definitions for peripheral DIP_SWITCHES_8BIT */







/* Definitions for peripheral LEDS_4BIT */







/* Definitions for peripheral LEDS_POSITIONS */







/* Definitions for peripheral PUSH_BUTTONS_POSITION */







/******************************************************************/


/* Definitions for peripheral SRAM */



/******************************************************************/

/* Definitions for peripheral SRAM */



/******************************************************************/

/* Canonical definitions for peripheral SRAM */






/******************************************************************/


/* Definitions for peripheral DLMB_CNTLR_0 */




/* Definitions for peripheral ILMB_CNTLR_0 */




/* Definitions for peripheral MB_PLB_BRAM_CNTLR */




/******************************************************************/

/* Definitions for driver UARTLITE */


/* Definitions for peripheral MDM_0 */
# 205 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral MDM_0 */
# 218 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for bus frequencies */


/******************************************************************/

/* Canonical definitions for bus frequencies */

/******************************************************************/




/******************************************************************/


/* Definitions for peripheral MICROBLAZE_0 */
# 433 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 635 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 7 "1D_CFD.c" 2

// Xilinx Microblaze Processor Version Register
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2006 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE.
//
// $Id: pvr.h,v 1.1.2.1 2009/09/24 23:37:37 haibing Exp $
////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************/
/**
*
* @file pvr.h
*
* This header file contains defines for structures used by the microblaze 
* PVR routines
*
******************************************************************************/




# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 60 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/***************************** Include Files *********************************/


/************************** Constant Definitions *****************************/
# 77 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/** Xilinx NULL, TRUE and FALSE legacy support. Deprecated. */
# 86 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/* the following constants and declarations are for unit test purposes and are
 * designed to be used in test applications.
 */






extern unsigned int XAssertStatus;
extern void XAssert(char *, int);

/**************************** Type Definitions *******************************/

/** @name Legacy types
 * Deprecated legacy types.
 * @{
 */
typedef unsigned char Xuint8; /**< unsigned 8-bit */
typedef char Xint8; /**< signed 8-bit */
typedef unsigned short Xuint16; /**< unsigned 16-bit */
typedef short Xint16; /**< signed 16-bit */
typedef unsigned long Xuint32; /**< unsigned 32-bit */
typedef long Xint32; /**< signed 32-bit */
typedef float Xfloat32; /**< 32-bit floating point */
typedef double Xfloat64; /**< 64-bit double precision FP */
typedef unsigned long Xboolean; /**< boolean (XTRUE or XFALSE) */

typedef struct
{
 Xuint32 Upper;
 Xuint32 Lower;
} Xuint64;

/** @name New types
 * New simple types.
 * @{
 */


typedef Xuint32 u32;
typedef Xuint16 u16;
typedef Xuint8 u8;





/*@}*/

/**
 * This data type defines an interrupt handler for a device.
 * The argument points to the instance of the component
 */
typedef void (*XInterruptHandler) (void *InstancePtr);

/**
 * This data type defines an exception handler for a processor.
 * The argument points to the instance of the component
 */
typedef void (*XExceptionHandler) (void *InstancePtr);

/**
 * This data type defines a callback to be invoked when an
 * assert occurs. The callback is invoked only when asserts are enabled
 */
typedef void (*XAssertCallback) (char *FilenamePtr, int LineNumber);

/***************** Macros (Inline Functions) Definitions *********************/

/*****************************************************************************/
/**
* Return the most significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The upper 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/


/*****************************************************************************/
/**
* Return the least significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The lower 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/





/*****************************************************************************/
/**
* This assert macro is to be used for functions that do not return anything
* (void). This in conjunction with the XWaitInAssert boolean can be used to
* accomodate tests so that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to
*           false, the assert occurs.
*
* @return   Returns void unless the XWaitInAssert variable is true, in which
*           case no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 214 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/*****************************************************************************/
/**
* This assert macro is to be used for functions that do return a value. This in
* conjunction with the XWaitInAssert boolean can be used to accomodate tests so
* that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to false,
*           the assert occurs.
*
* @return   Returns 0 unless the XWaitInAssert variable is true, in which case
*           no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 243 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do not
* return anything (void). Use for instances where an assert should always
* occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/







/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do return
* a value. Use for instances where an assert should always occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/
# 289 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/************************** Function Prototypes ******************************/

void XAssertSetCallback(XAssertCallback Routine);
void XNullHandler(void *NullParameter);
# 34 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Driver parameters

*

*******************************************************************/
# 18 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver MPMC */


/* Definitions for peripheral DDR_SDRAM */
# 42 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/


/* Definitions for peripheral DDR_SDRAM */
# 82 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral DDR_SDRAM */
# 105 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver GPIO */


/* Definitions for peripheral AUDIO */







/* Definitions for peripheral DIP_SWITCHES_8BIT */







/* Definitions for peripheral LEDS_4BIT */







/* Definitions for peripheral LEDS_POSITIONS */







/* Definitions for peripheral PUSH_BUTTONS_POSITION */







/******************************************************************/


/* Definitions for peripheral SRAM */



/******************************************************************/

/* Definitions for peripheral SRAM */



/******************************************************************/

/* Canonical definitions for peripheral SRAM */






/******************************************************************/


/* Definitions for peripheral DLMB_CNTLR_0 */




/* Definitions for peripheral ILMB_CNTLR_0 */




/* Definitions for peripheral MB_PLB_BRAM_CNTLR */




/******************************************************************/

/* Definitions for driver UARTLITE */


/* Definitions for peripheral MDM_0 */
# 205 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral MDM_0 */
# 218 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for bus frequencies */


/******************************************************************/

/* Canonical definitions for bus frequencies */

/******************************************************************/




/******************************************************************/


/* Definitions for peripheral MICROBLAZE_0 */
# 433 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 635 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 35 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE. 
// 
// File   : mb_interface.h
// Date   : 2002, March 20.
// Company: Xilinx
// Group  : Emerging Software Technologies
//
// Summary:
// Header file for mb_interface
//
// $Id: mb_interface.h,v 1.1.2.1 2009/09/24 23:37:36 haibing Exp $
//
////////////////////////////////////////////////////////////////////////////////




# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 33 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 2





extern void microblaze_enable_interrupts(void); /* Enable Interrupts */
extern void microblaze_disable_interrupts(void); /* Disable Interrupts */
extern void microblaze_enable_icache(void); /* Enable Instruction Cache */
extern void microblaze_disable_icache(void); /* Disable Instruction Cache */
extern void microblaze_enable_dcache(void); /* Enable Instruction Cache */
extern void microblaze_disable_dcache(void); /* Disable Instruction Cache */
extern void microblaze_enable_exceptions(void); /* Enable hardware exceptions */
extern void microblaze_disable_exceptions(void); /* Disable hardware exceptions */
extern void microblaze_register_handler(XInterruptHandler Handler, void *DataPtr); /* Register top level interrupt handler */
extern void microblaze_register_exception_handler(Xuint8 ExceptionId, XExceptionHandler Handler, void *DataPtr); /* Register exception handler */

extern void microblaze_invalidate_icache(); /* Invalidate the entire icache */
extern void microblaze_invalidate_dcache(); /* Invalidate the entire dcache */
extern void microblaze_flush_dcache(); /* Flush the whole dcache */
extern void microblaze_invalidate_icache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the icache */
extern void microblaze_invalidate_dcache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the dcache */
extern void microblaze_flush_dcache_range(unsigned int cacheaddr, unsigned int len); /* Flush a part of the dcache */

/* Deprecated */
extern void microblaze_update_icache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_icache_range (int , int ) __attribute__((deprecated));
extern void microblaze_update_dcache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_dcache_range (int , int ) __attribute__((deprecated));

/* necessary for pre-processor */



/* FSL Access Macros */

/* Blocking Data Read and Write to FSL no. id */



/* Non-blocking Data Read and Write to FSL no. id */



/* Blocking Control Read and Write to FSL no. id */



/* Non-blocking Control Read and Write to FSL no. id */



/* Polling versions of FSL access macros. This makes the FSL access interruptible */
# 104 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h"
/* FSL valid and error check macros. */




/* Pseudo assembler instructions */
# 257 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h"
/* Deprecated MicroBlaze FSL macros */
# 36 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/bspconfig.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Configurations for Standalone BSP

*

*******************************************************************/
# 37 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2






/* Defs */
typedef struct pvr_s {



  unsigned int pvr[1];

} pvr_t;




/* Basic PVR mask */
# 67 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h"
/* User 2 PVR mask */


/* Configuration PVR masks */
# 96 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h"
/* Debug and exception PVR masks */






/* ICache config PVR masks */







/* DCache config PVR masks */







/* ICache base address PVR mask */


/* ICache high address PVR mask */


/* DCache base address PVR mask */


/* DCache high address PVR mask */


/* Target family PVR mask */


/* MSR Reset value PVR mask */


/* MMU value PVR mask */



/* PVR access macros */
# 206 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h"
/* Protos */
int microblaze_get_pvr (pvr_t *pvr);
# 10 "1D_CFD.c" 2

// Hardware counter connected via a direct FSL bus.
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 1
/*****************************************************************************

* Filename:          C:\Xilinx\12.1\MyProcessorIPLib\drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h

* Version:           1.00.a

* Description:       counter_dfsl (Counter DFSL) Driver Header File

* Date:              Fri Jul 02 14:27:25 2010 (by Create and Import Peripheral Wizard)

*****************************************************************************/
# 11 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 1



# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 5 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE. 
// 
// File   : mb_interface.h
// Date   : 2002, March 20.
// Company: Xilinx
// Group  : Emerging Software Technologies
//
// Summary:
// Header file for mb_interface
//
// $Id: mb_interface.h,v 1.1.2.1 2009/09/24 23:37:36 haibing Exp $
//
////////////////////////////////////////////////////////////////////////////////
# 6 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 2





/* Extended FSL macros. These now replace all of the previous FSL macros */
# 12 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 2


typedef struct {
 int current; // Current counter value measured.
 int last; // Last value of the counter.
 int difference; // Difference between the current and last values.
 int min; // Minimum counter value.
 int avg; // Average counter value.
 int max; // Maximum counter value.
 long int total; // Cumulative value of all differences.
 int iterations; // Number of times values are added to the total.
} Counter;


// Initialise the current and last counter values.
# 40 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
// Start the counter with the specified value.




// Stop the counter and read the current value.



// Read the current counter value.
// Subtract 3 cycles for put and addk instruction.




// Calculate the difference between the current and last
// counter values.



// Accumulate the counter difference.




// Calculate the average differences.



// Update the maximum counter difference.





// Update the minimum counter difference.
# 13 "1D_CFD.c" 2
Counter counter;

// ForeC hardware mutex
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/forec_mutex_v1_00_a/src/forec_mutex.h" 1
/*****************************************************************************

* Filename:          C:\Xilinx\12.1\MyProcessorIPLib\drivers/forec_mutex_v1_00_a/src/forec_mutex.h

* Version:           1.00.a

* Description:       forec_mutex (ForeC Mutex) Driver Header File

* Date:              Fri Jul 02 14:27:25 2010 (by Create and Import Peripheral Wizard)

*****************************************************************************/
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 1
# 13 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/forec_mutex_v1_00_a/src/forec_mutex.h" 2


// Set the bit at the given position in the bit array.



// Resets all bits to 1. Only works on core0.



// Clear the bit at the given position in the bit array.



// Read the entire bit array.
# 17 "1D_CFD.c" 2






/*==============================================================

| ForeC type definitions:

| Defines the types of storage elements specific to ForeC.

*=============================================================*/
# 27 "1D_CFD.c"
// Status values.
typedef enum {
 // PAR
 FOREC_PAR_OFF, // 0
 FOREC_PAR_ON, // 1

 // Core
 FOREC_CORE_REACTING, // 2
 FOREC_CORE_REACTED, // 3
 FOREC_CORE_TERMINATED, // 4

 // Shared variables
 FOREC_SHARED_UNMODIFIED, // 5
 FOREC_SHARED_MODIFIED, // 6
 FOREC_SHARED_WAS_MODIFIED // 7
} Status;

// Store child thread information.
typedef struct _Thread {
 void *programCounter;
 struct _Thread *nextThread;
 struct _Thread *prevThread;
} Thread;

// Store parent thread information
typedef struct {
 void *programCounter;
 unsigned short int parStatus;
 short int parId;
} Parent;

// Keep track of child threads executing on
// a processor core.
typedef struct {
 unsigned short int sync;
 unsigned short int activeThreads;
 unsigned short int status;
 int reactionCounter;
} Core;

// Global variable for counting the number of global reactions.
volatile long int globalReactions = 0;

// Shared control variables for par(...)s -------------------------
// Thread main with par(...)s
volatile Parent mainParParent;
volatile Core mainParCore0;
volatile int mainParReactionCounter;


/*==============================================================

| Original global declarations:

| Global declarations in the original program code.

*=============================================================*/
# 81 "1D_CFD.c"
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 1 3
/*
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)stdio.h	5.3 (Berkeley) 3/15/86
 */

/*
 * NB: to fit things in six character monocase externals, the
 * stdio code uses the prefix `__s' for stdio objects, typically
 * followed by a three-character attempt at a mnemonic.
 */




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* Some ANSI environments are "broken" in the sense that __STDC__ cannot be
   relied upon to have it's intended meaning.  Therefore we must use our own
   concoction: _HAVE_STDC.  Always use _HAVE_STDC instead of __STDC__ in newlib
   sources!

   To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/newlib.h" 1 3
/* newlib.h.  Generated automatically by configure.  */




/* EL/IX level */
/* #undef _ELIX_LEVEL */

/* Newlib version */


/* long long type support in IO functions like printf/scanf enabled */


/* long double type support in IO functions like printf/scanf enabled */
/* #undef _WANT_IO_LONG_DOUBLE */

/* Positional argument support in printf functions enabled.  */
/* #undef _WANT_IO_POS_ARGS */

/* Multibyte supported */
/* #undef _MB_CAPABLE */

/* MB_LEN_MAX */


/* ICONV enabled */
/* #undef _ICONV_ENABLED */

/* Enable ICONV external CCS files loading capabilities */
/* #undef _ICONV_ENABLE_EXTERNAL_CCS */

/*
 * Iconv encodings enabled ("to" direction)
 */
/* #undef _ICONV_TO_ENCODING_BIG5 */
/* #undef _ICONV_TO_ENCODING_CP775 */
/* #undef _ICONV_TO_ENCODING_CP850 */
/* #undef _ICONV_TO_ENCODING_CP852 */
/* #undef _ICONV_TO_ENCODING_CP855 */
/* #undef _ICONV_TO_ENCODING_CP866 */
/* #undef _ICONV_TO_ENCODING_EUC_JP */
/* #undef _ICONV_TO_ENCODING_EUC_TW */
/* #undef _ICONV_TO_ENCODING_EUC_KR */
/* #undef _ICONV_TO_ENCODING_ISO_8859_1 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_10 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_11 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_13 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_14 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_15 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_2 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_3 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_4 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_5 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_6 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_7 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_8 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_9 */
/* #undef _ICONV_TO_ENCODING_ISO_IR_111 */
/* #undef _ICONV_TO_ENCODING_KOI8_R */
/* #undef _ICONV_TO_ENCODING_KOI8_RU */
/* #undef _ICONV_TO_ENCODING_KOI8_U */
/* #undef _ICONV_TO_ENCODING_KOI8_UNI */
/* #undef _ICONV_TO_ENCODING_UCS_2 */
/* #undef _ICONV_TO_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_2BE */
/* #undef _ICONV_TO_ENCODING_UCS_2LE */
/* #undef _ICONV_TO_ENCODING_UCS_4 */
/* #undef _ICONV_TO_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_4BE */
/* #undef _ICONV_TO_ENCODING_UCS_4LE */
/* #undef _ICONV_TO_ENCODING_US_ASCII */
/* #undef _ICONV_TO_ENCODING_UTF_16 */
/* #undef _ICONV_TO_ENCODING_UTF_16BE */
/* #undef _ICONV_TO_ENCODING_UTF_16LE */
/* #undef _ICONV_TO_ENCODING_UTF_8 */
/* #undef _ICONV_TO_ENCODING_WIN_1250 */
/* #undef _ICONV_TO_ENCODING_WIN_1251 */
/* #undef _ICONV_TO_ENCODING_WIN_1252 */
/* #undef _ICONV_TO_ENCODING_WIN_1253 */
/* #undef _ICONV_TO_ENCODING_WIN_1254 */
/* #undef _ICONV_TO_ENCODING_WIN_1255 */
/* #undef _ICONV_TO_ENCODING_WIN_1256 */
/* #undef _ICONV_TO_ENCODING_WIN_1257 */
/* #undef _ICONV_TO_ENCODING_WIN_1258 */

/*
 * Iconv encodings enabled ("from" direction)
 */
/* #undef _ICONV_FROM_ENCODING_BIG5 */
/* #undef _ICONV_FROM_ENCODING_CP775 */
/* #undef _ICONV_FROM_ENCODING_CP850 */
/* #undef _ICONV_FROM_ENCODING_CP852 */
/* #undef _ICONV_FROM_ENCODING_CP855 */
/* #undef _ICONV_FROM_ENCODING_CP866 */
/* #undef _ICONV_FROM_ENCODING_EUC_JP */
/* #undef _ICONV_FROM_ENCODING_EUC_TW */
/* #undef _ICONV_FROM_ENCODING_EUC_KR */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_1 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_10 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_11 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_13 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_14 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_15 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_2 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_3 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_4 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_5 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_6 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_7 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_8 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_9 */
/* #undef _ICONV_FROM_ENCODING_ISO_IR_111 */
/* #undef _ICONV_FROM_ENCODING_KOI8_R */
/* #undef _ICONV_FROM_ENCODING_KOI8_RU */
/* #undef _ICONV_FROM_ENCODING_KOI8_U */
/* #undef _ICONV_FROM_ENCODING_KOI8_UNI */
/* #undef _ICONV_FROM_ENCODING_UCS_2 */
/* #undef _ICONV_FROM_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_2BE */
/* #undef _ICONV_FROM_ENCODING_UCS_2LE */
/* #undef _ICONV_FROM_ENCODING_UCS_4 */
/* #undef _ICONV_FROM_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_4BE */
/* #undef _ICONV_FROM_ENCODING_UCS_4LE */
/* #undef _ICONV_FROM_ENCODING_US_ASCII */
/* #undef _ICONV_FROM_ENCODING_UTF_16 */
/* #undef _ICONV_FROM_ENCODING_UTF_16BE */
/* #undef _ICONV_FROM_ENCODING_UTF_16LE */
/* #undef _ICONV_FROM_ENCODING_UTF_8 */
/* #undef _ICONV_FROM_ENCODING_WIN_1250 */
/* #undef _ICONV_FROM_ENCODING_WIN_1251 */
/* #undef _ICONV_FROM_ENCODING_WIN_1252 */
/* #undef _ICONV_FROM_ENCODING_WIN_1253 */
/* #undef _ICONV_FROM_ENCODING_WIN_1254 */
/* #undef _ICONV_FROM_ENCODING_WIN_1255 */
/* #undef _ICONV_FROM_ENCODING_WIN_1256 */
/* #undef _ICONV_FROM_ENCODING_WIN_1257 */
/* #undef _ICONV_FROM_ENCODING_WIN_1258 */

/* Define if the linker supports .preinit_array/.init_array/.fini_array
 * sections.  */


/* True if atexit() may dynamically allocate space for cleanup
   functions.  */
/* #undef  _ATEXIT_DYNAMIC_ALLOC */

/* Define if the compiler supports aliasing an array to an address.  */
/* #undef  _HAVE_ARRAY_ALIASING */
# 16 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 2 3
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 1 3



# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/ieeefp.h" 1 3



/* This file can define macros to choose variations of the IEEE float
   format:

   _FLT_LARGEST_EXPONENT_IS_NORMAL

	Defined if the float format uses the largest exponent for finite
	numbers rather than NaN and infinity representations.  Such a
	format cannot represent NaNs or infinities at all, but it's FLT_MAX
	is twice the IEEE value.

   _FLT_NO_DENORMALS

	Defined if the float format does not support IEEE denormals.  Every
	float with a zero exponent is taken to be a zero representation.
 
   ??? At the moment, there are no equivalent macros above for doubles and
   the macros are not fully supported by --enable-newlib-hw-fp.

   __IEEE_BIG_ENDIAN

        Defined if the float format is big endian.  This is mutually exclusive
        with __IEEE_LITTLE_ENDIAN.

   __IEEE_LITTLE_ENDIAN
 
        Defined if the float format is little endian.  This is mutually exclusive
        with __IEEE_BIG_ENDIAN.

   Note that one of __IEEE_BIG_ENDIAN or __IEEE_LITTLE_ENDIAN must be specified for a
   platform or error will occur.

   __IEEE_BYTES_LITTLE_ENDIAN

        This flag is used in conjunction with __IEEE_BIG_ENDIAN to describe a situation 
	whereby multiple words of an IEEE floating point are in big endian order, but the
	words themselves are little endian with respect to the bytes.

   _DOUBLE_IS_32_BITS 

        This is used on platforms that support double by using the 32-bit IEEE
        float type.

   _FLOAT_ARG

        This represents what type a float arg is passed as.  It is used when the type is
        not promoted to double.
	
*/
# 156 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/ieeefp.h" 3
/* necv70 was __IEEE_LITTLE_ENDIAN. */
# 5 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 2 3

/* exceptions first */







/* 16 bit integer machines */
# 87 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 3
/* For the PowerPC eabi, force the _impure_ptr to be in .sdata */
# 125 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 3
/* Configure small REENT structure for Xilinx PPC and MB platforms */







/* This block should be kept in sync with GCC's limits.h.  The point
   of having these definitions here is to not include limits.h, which
   would pollute the user namespace, while still using types of the
   the correct widths when deciding how to define __int32_t and
   __int64_t.  */
# 158 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 3
/* End of block that should be kept in sync with GCC's limits.h.  */
# 187 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 3
/* Define return type of read/write routines.  In POSIX, the return type
   for read()/write() is "ssize_t" but legacy newlib code has been using
   "int" for some time.  If not specified, "int" is defaulted.  */
# 17 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 2 3

/* First try to figure out whether we really are in an ANSI C environment.  */
/* FIXME: This probably needs some work.  Perhaps sys/config.h can be
   prevailed upon to give us a clue.  */
# 70 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 3
/* Support gcc's __attribute__ facility.  */







/*  ISO C++.  */
# 30 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 2 3




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 52 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
# 97 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 122 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 167 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 214 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 240 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 360 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
# 395 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* A null pointer constant.  */
# 35 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 2 3


# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stdarg.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */
# 39 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stdarg.h" 3 4
/* Define __gnuc_va_list.  */



typedef __builtin_va_list __gnuc_va_list;


/* Define the standard macros for the user,
   if this invocation was from the user program.  */
# 38 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 2 3

/*
 * <sys/reent.h> defines __FILE, _fpos_t.
 * They must be defined there because struct _reent needs them (and we don't
 * want reent.h to include this file.
 */

# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 1 3
/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */







# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* Some ANSI environments are "broken" in the sense that __STDC__ cannot be
   relied upon to have it's intended meaning.  Therefore we must use our own
   concoction: _HAVE_STDC.  Always use _HAVE_STDC instead of __STDC__ in newlib
   sources!

   To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
# 14 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 2 3
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/_types.h" 1 3
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  This file lives in the `sys' directory so targets can provide
   their own if desired (or they can put target dependant conditionals here).
*/




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/lock.h" 1 3



/* dummy lock routines for single-threaded aps */

typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 13 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/_types.h" 2 3

typedef long _off_t;
__extension__ typedef long long _off64_t;


typedef int _ssize_t;





# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 52 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
# 97 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 122 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 167 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 240 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 355 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
typedef unsigned int wint_t;




/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
# 395 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* A null pointer constant.  */
# 25 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/_types.h" 2 3

/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value; /* Value so far.  */
} _mbstate_t;

typedef _LOCK_RECURSIVE_T _flock_t;

/* Iconv descriptor type */
typedef void *_iconv_t;
# 15 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/*
 * If _REENT_SMALL is defined, we make struct _reent as small as possible,
 * by having nearly everything possible allocated at first use.
 */

struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};

/* needed by reentrant structure */
struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};

/*
 * atexit() support.
 */



struct _on_exit_args {
 void * _fnargs[32 /* must be at least 32 to guarantee ANSI conformance */]; /* user fn args */
 void * _dso_handle[32 /* must be at least 32 to guarantee ANSI conformance */];
 /* Bitmask is set if user function takes arguments.  */
 __ULong _fntypes; /* type of exit routine -
				   Must have at least _ATEXIT_SIZE bits */
 /* Bitmask is set if function was registered via __cxa_atexit.  */
 __ULong _is_cxa;
};


struct _atexit {
 struct _atexit *_next; /* next in list */
 int _ind; /* next index in this table */
 void (*_fns[32 /* must be at least 32 to guarantee ANSI conformance */])(void); /* the table itself */
        struct _on_exit_args * _on_exit_args_ptr;
};
# 96 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/*
 * Stdio buffers.
 *
 * This and __FILE are defined here because we need them for struct _reent,
 * but we don't want stdio.h included when stdlib.h is.
 */

struct __sbuf {
 unsigned char *_base;
 int _size;
};

/*
 * We need fpos_t for the following, but it doesn't have a leading "_",
 * so we use _fpos_t instead.
 */

typedef long _fpos_t; /* XXX must match off_t in <sys/types.h> */
    /* (and must be `long' for now) */





/*
 * Stdio state variables.
 *
 * The following always hold:
 *
 *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
 *		_lbfsize is -_bf._size, else _lbfsize is 0
 *	if _flags&__SRD, _w is 0
 *	if _flags&__SWR, _r is 0
 *
 * This ensures that the getc and putc macros (or inline functions) never
 * try to write or read from a file that is in `read' or `write' mode.
 * (Moreover, they can, and do, automatically switch from read mode to
 * write mode, and back, on "r+" and "w+" files.)
 *
 * _lbfsize is used only to make the inline line-buffered output stream
 * code as compact as possible.
 *
 * _ub, _up, and _ur are used when ungetc() pushes back more characters
 * than fit in the current _bf, or when ungetc() pushes back a character
 * that does not match the previous one in _bf.  When this happens,
 * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
 * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
 */


/*
 * struct __sFILE_fake is the start of a struct __sFILE, with only the
 * minimal fields allocated.  In __sinit() we really allocate the 3
 * standard streams, etc., and point away from this fake.
 */
struct __sFILE_fake {
  unsigned char *_p; /* current position in (some) buffer */
  int _r; /* read space left for getc() */
  int _w; /* write space left for putc() */
  short _flags; /* flags, below; this FILE is free if 0 */
  short _file; /* fileno, if Unix descriptor, else -1 */
  struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */
  int _lbfsize; /* 0 or -_bf._size, for inline putc */

  struct _reent *_data;
};
/* CHECK_STD_INIT() comes from stdio/local.h; be sure to include that.  */





struct __sFILE {
  unsigned char *_p; /* current position in (some) buffer */
  int _r; /* read space left for getc() */
  int _w; /* write space left for putc() */
  short _flags; /* flags, below; this FILE is free if 0 */
  short _file; /* fileno, if Unix descriptor, else -1 */
  struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */
  int _lbfsize; /* 0 or -_bf._size, for inline putc */


  struct _reent *_data;


  /* operations */
  void * _cookie; /* cookie passed to io functions */

  int (*_read) (void * _cookie, char *_buf, int _n);
  int (*_write) (void * _cookie, const char *_buf, int _n);

  _fpos_t (*_seek) (void * _cookie, _fpos_t _offset, int _whence);
  int (*_close) (void * _cookie);

  /* separate buffer for long sequences of ungetc() */
  struct __sbuf _ub; /* ungetc buffer */
  unsigned char *_up; /* saved _p when _p is doing ungetc data */
  int _ur; /* saved _r when _r is counting ungetc data */

  /* tricks to meet minimum requirements even when malloc() fails */
  unsigned char _ubuf[3]; /* guarantee an ungetc() buffer */
  unsigned char _nbuf[1]; /* guarantee a getc() buffer */

  /* separate buffer for fgetline() when line crosses buffer boundary */
  struct __sbuf _lb; /* buffer for fgetline() */

  /* Unix stdio files get aligned to block boundaries on fseek() */
  int _blksize; /* stat.st_blksize (may be != _bf._size) */
  int _offset; /* current lseek offset */






  _flock_t _lock; /* for thread-safety locking */

};
# 261 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
typedef struct __sFILE __FILE;


struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};

/*
 * rand48 family support
 *
 * Copyright (c) 1993 Martin Birgmeier
 * All rights reserved.
 *
 * You may redistribute unmodified or modified versions of this source
 * code provided that the above copyright notice and this and the
 * following conditions are retained.
 *
 * This software is provided ``as is'', and comes with no warranties
 * of any kind. I shall in no event be liable for anything that happens
 * to anyone/anything when using this software.
 */







struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;

  /* Put this in here as well, for good luck.  */
  __extension__ unsigned long long _rand_next;

};

/* How big the some arrays are.  */




/*
 * struct _reent
 *
 * This structure contains *all* globals needed by the library.
 * It's raison d'etre is to facilitate threads by making all library routines
 * reentrant.  IE: All state information is contained here.
 */



struct _mprec
{
  /* used by mprec routines */
  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;
};


struct _misc_reent
{
  /* miscellaneous reentrant data */
  char *_strtok_last;
  _mbstate_t _mblen_state;
  _mbstate_t _wctomb_state;
  _mbstate_t _mbtowc_state;
  char _l64a_buf[8];
  int _getdate_err;
  _mbstate_t _mbrlen_state;
  _mbstate_t _mbrtowc_state;
  _mbstate_t _mbsrtowcs_state;
  _mbstate_t _wcrtomb_state;
  _mbstate_t _wcsrtombs_state;
};

/* This version of _reent is layed our with "int"s in pairs, to help
 * ports with 16-bit int's but 32-bit pointers, align nicely.  */
struct _reent
{

  /* FILE is a big struct and may change over time.  To try to achieve binary
     compatibility with future versions, put stdin,stdout,stderr here.
     These are pointers into member __sf defined below.  */
  __FILE *_stdin, *_stdout, *_stderr; /* XXX */

  int _errno; /* local copy of errno */

  int _inc; /* used by tmpnam */

  char *_emergency;

  int __sdidinit; /* 1 means stdio has been init'd */

  int _current_category; /* used by setlocale */
  const char *_current_locale;

  struct _mprec *_mp;

  void (*__cleanup) (struct _reent *);

  int _gamma_signgam;

  /* used by some fp conversion routines */
  int _cvtlen; /* should be size_t */
  char *_cvtbuf;

  struct _rand48 *_r48;
  struct __tm *_localtime_buf;
  char *_asctime_buf;

  /* signal info */
  void (**(_sig_func))(int);

  /* atexit stuff */
  struct _atexit *_atexit;
  struct _atexit _atexit0;

  struct _glue __sglue; /* root of glue chain */
  __FILE *__sf; /* file descriptors */
  struct _misc_reent *_misc; /* strtok, multibyte states */
  char *_signal_buf; /* strsignal */
};

extern const struct __sFILE_fake __sf_fake_stdin;
extern const struct __sFILE_fake __sf_fake_stdout;
extern const struct __sFILE_fake __sf_fake_stderr;
# 454 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/* Only built the assert() calls if we are built with debugging.  */






/* Generic _REENT check macro.  */
# 479 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/* Handle the dynamically allocated rand48 structure. */
# 784 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/*
 * All references to struct _reent are via this pointer.
 * Internally, newlib routines that need to reference it should use _REENT.
 */





extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);

/* #define _REENT_ONLY define this to get only reentrant routines */
# 46 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 2 3
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 1 3
/* unified sys/types.h: 
   start with sef's sysvi386 version.
   merge go32 version -- a few ifdefs.
   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:

   typedef int gid_t;
   typedef int uid_t;
   typedef int dev_t;
   typedef int ino_t;
   typedef int mode_t;
   typedef int caddr_t;

   however, these aren't "reasonable" values, the sysvi386 ones make far 
   more sense, and should work sufficiently well (in particular, h8300 
   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
 */



# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* Some ANSI environments are "broken" in the sense that __STDC__ cannot be
   relied upon to have it's intended meaning.  Therefore we must use our own
   concoction: _HAVE_STDC.  Always use _HAVE_STDC instead of __STDC__ in newlib
   sources!

   To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
# 21 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 2 3




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/_types.h" 1 3
/*
 *  $Id: _types.h,v 1.2 2005/03/22 18:12:29 cgf Exp $
 */
# 12 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/_types.h" 3
/*
 * Guess on types by examining *_MIN / *_MAX defines.
 */





/* Fall back to POSIX versions from <limits.h> */

# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/limits.h" 1 3 4



/* Number of bits in a `char'.  */



/* Maximum length of a multibyte character.  */




/* Minimum and maximum values a `signed char' can hold.  */





/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */







/* Minimum and maximum values a `char' can hold.  */
# 44 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/limits.h" 3 4
/* Minimum and maximum values a `signed short int' can hold.  */





/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */







/* Minimum and maximum values a `signed int' can hold.  */





/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */



/* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  */





/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
# 92 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/limits.h" 3 4
/* Minimum and maximum values a `signed long long int' can hold.  */





/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
# 23 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/_types.h" 2 3



typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;


/* POSIX mandates LLONG_MAX in <limits.h> */
# 26 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 2 3
# 61 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 3
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/_types.h" 1 3
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  This file lives in the `sys' directory so targets can provide
   their own if desired (or they can put target dependant conditionals here).
*/
# 62 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 2 3







# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */





/* snaroff@next.com says the NeXT needs this.  */

/* Irix 5.1 needs this.  */




/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
# 97 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 122 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 152 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 162 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */




/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 240 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 281 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */
# 308 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
# 326 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
typedef int wchar_t;
# 360 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
# 395 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* A null pointer constant.  */
# 413 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Offset of member MEMBER in a struct of type TYPE. */
# 70 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 2 3
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/types.h" 1 3



/*
 *  The following section is RTEMS specific and is needed to more
 *  closely match the types defined in the BSD machine/types.h.
 *  This is needed to let the RTEMS/BSD TCP/IP stack compile.
 */
# 19 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/types.h" 3
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 71 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 2 3

/* To ensure the stat struct's layout doesn't change when sizeof(int), etc.
   changes, we assume sizeof short and long never change and have all types
   used to define struct stat use them and not int where possible.
   Where not possible, _ST_INTxx are used.  It would be preferable to not have
   such assumptions, but until the extra fluff is necessary, it's avoided.
   No 64 bit targets use stat yet.  What to do about them is postponed
   until necessary.  */
# 91 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 3
/* also defined in mingw/gmon.h and in w32api/winsock[2].h */
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;



typedef unsigned short ushort; /* System V compatibility */
typedef unsigned int uint; /* System V compatibility */



typedef unsigned long /* clock() */ clock_t;




typedef long /* time() */ time_t;


/* Time Value Specification Structures, P1003.1b-1993, p. 261 */

struct timespec {
  time_t tv_sec; /* Seconds */
  long tv_nsec; /* Nanoseconds */
};

struct itimerspec {
  struct timespec it_interval; /* Timer period */
  struct timespec it_value; /* Timer expiration */
};


typedef long daddr_t;
typedef char * caddr_t;
# 135 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 3
typedef unsigned short ino_t;
# 157 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 3
/*
 * All these should be machine specific - right now they are all broken.
 * However, for all of Cygnus' embedded targets, we want them to all be
 * the same.  Otherwise things like sizeof (struct stat) might depend on
 * how the file was compiled (e.g. -mint16 vs -mint32, etc.).
 */






typedef short dev_t;




typedef long off_t;

typedef unsigned short uid_t;
typedef unsigned short gid_t;





typedef int pid_t;



typedef long key_t;

typedef _ssize_t ssize_t;
# 203 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 3
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;

/* We don't define fd_set and friends if we are compiling POSIX
   source, or if we have included (or may include as indicated
   by __USE_W32_SOCKETS) the W32api winsock[2].h header which
   defines Windows versions of them.   Note that a program which
   includes the W32api winsock[2].h header must know what it is doing;
   it must not call the cygwin32 select function.
*/



/*
 * Select uses bit masks of file descriptors in longs.
 * These macros manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here
 * should be >= NOFILE (param.h).
 */




typedef long fd_mask;





/* We use a macro for fd_set so that including Sockets.h afterwards
   can work.  */
typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8 /* number of bits in a byte */) /* bits per mask */)-1))/((sizeof (fd_mask) * 8 /* number of bits in a byte */) /* bits per mask */))];
} _types_fd_set;
# 261 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 3
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef long useconds_t;

# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/features.h" 1 3
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2000.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id: features.h,v 1.7 2005/10/18 18:39:46 corinna Exp $
 */
# 28 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/features.h" 3
/* RTEMS adheres to POSIX -- 1003.1b with some features from annexes.  */
# 273 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/types.h" 2 3


/* Cygwin will probably never have full posix compliance due to little things
 * like an inability to set the stackaddress. Cygwin is also using void *  
 * pointers rather than structs to ensure maximum binary compatability with
 * previous releases.
 * This means that we don't use the types defined here, but rather in
 * <cygwin/types.h>
 */
# 47 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 2 3



typedef __FILE FILE;
# 59 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 3
typedef _fpos_t fpos_t;





# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/stdio.h" 1 3




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 1 3
/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */
# 6 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/stdio.h" 2 3

/* Internal locking macros, used to protect stdio functions.  In the
   general case, expand to nothing. Use __SSTR flag in FILE _flags to
   detect if FILE is private to sprintf/sscanf class of functions; if
   set then do nothing as lock is not initialised. */
# 66 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 2 3





 /* RD and WR are never simultaneously asserted */
# 87 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 3
/*
 * The following three definitions are for ANSI C, which took them
 * from System V, which stupidly took internal interface macros and
 * made them official arguments to setvbuf(), without renaming them.
 * Hence, these ugly _IOxxx names are *supposed* to appear in user code.
 *
 * Although these happen to match their counterparts above, the
 * implementation does not rely on that (so these could be renumbered).
 */
# 160 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 3
/*
 * Functions defined in ANSI C standard.
 */







FILE * tmpfile (void);
char * tmpnam (char *);
int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *, const char *, FILE *);
void setbuf (FILE *, char *);
int setvbuf (FILE *, char *, int, size_t);
int fprintf (FILE *, const char *, ...);
int fscanf (FILE *, const char *, ...);
int printf (const char *, ...);
int scanf (const char *, ...);
int sscanf (const char *, const char *, ...);
int vfprintf (FILE *, const char *, __gnuc_va_list);
int vprintf (const char *, __gnuc_va_list);
int vsprintf (char *, const char *, __gnuc_va_list);
int fgetc (FILE *);
char * fgets (char *, int, FILE *);
int fputc (int, FILE *);
int fputs (const char *, FILE *);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *, size_t _size, size_t _n, FILE *);
size_t fwrite (const void * , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *, fpos_t *);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *_name, const char *_type);
int sprintf (char *, const char *, ...);
int remove (const char *);
int rename (const char *, const char *);

void xil_printf (const char*, ...);
void putnum (unsigned int );
void print (char* );





int fseeko (FILE *, off_t, int);
off_t ftello ( FILE *);


int asiprintf (char **, const char *, ...);
int asprintf (char **, const char *, ...);
int dprintf (int, const char *, ...);
int fcloseall (void);
int fiprintf (FILE *, const char *, ...);
int iprintf (const char *, ...);
int siprintf (char *, const char *, ...);
int snprintf (char *, size_t, const char *, ...);
int sniprintf (char *, size_t, const char *, ...);
char * tempnam (const char *, const char *);
int vasiprintf (char **, const char *, __gnuc_va_list);
int vasprintf (char **, const char *, __gnuc_va_list);
int vdprintf (int, const char *, __gnuc_va_list);
int vsniprintf (char *, size_t, const char *, __gnuc_va_list);
int vsnprintf (char *, size_t, const char *, __gnuc_va_list);
int vfiprintf (FILE *, const char *, __gnuc_va_list);
int vfiscanf (FILE *, const char *, __gnuc_va_list);
int vfscanf (FILE *, const char *, __gnuc_va_list);
int viprintf (const char *, __gnuc_va_list);
int viscanf (const char *, __gnuc_va_list);
int vscanf (const char *, __gnuc_va_list);
int vsiscanf (const char *, const char *, __gnuc_va_list);
int vsscanf (const char *, const char *, __gnuc_va_list);



/*
 * Routines in POSIX 1003.1.
 */



FILE * fdopen (int, const char *);

int fileno (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE * popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);


/*
 * Recursive versions of the above.
 */

int _asiprintf_r (struct _reent *, char **, const char *, ...);
int _asprintf_r (struct _reent *, char **, const char *, ...);
int _dprintf_r (struct _reent *, int, const char *, ...);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
FILE * _fopen_r (struct _reent *, const char *, const char *);
int _fclose_r (struct _reent *, FILE *);
int _fiscanf_r (struct _reent *, FILE *, const char *, ...);
int _fscanf_r (struct _reent *, FILE *, const char *, ...);
int _fseek_r (struct _reent *, FILE *, long, int);
long _ftell_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...);
int _iscanf_r (struct _reent *, const char *, ...);
int _mkstemp_r (struct _reent *, char *);
char * _mktemp_r (struct _reent *, char *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *, ...);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new);

int _scanf_r (struct _reent *, const char *, ...);
int _siprintf_r (struct _reent *, char *, const char *, ...);
int _siscanf_r (struct _reent *, const char *, const char *, ...);
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...);
int _snprintf_r (struct _reent *, char *, size_t, const char *, ...);
int _sprintf_r (struct _reent *, char *, const char *, ...);
int _sscanf_r (struct _reent *, const char *, const char *, ...);
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list);
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list);
int _vdprintf_r (struct _reent *, int, const char *, __gnuc_va_list);
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list);
int _vfprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list);
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list);
int _vprintf_r (struct _reent *, const char *, __gnuc_va_list);
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list);
int _vsprintf_r (struct _reent *, char *, const char *, __gnuc_va_list);
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list);
int _vsnprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list);
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list);
int _vfscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list);
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list);
int _vscanf_r (struct _reent *, const char *, __gnuc_va_list);
int _vsscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list);
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list);

ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 363 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 3
/*
 * Routines internal to the implementation.
 */

int __srget (FILE *);
int __swbuf (int, FILE *);

/*
 * Stdio function-access interface.
 */


FILE *funopen (const void * _cookie, int (*readfn)(void * _cookie, char *_buf, int _n), int (*writefn)(void * _cookie, const char *_buf, int _n), fpos_t (*seekfn)(void * _cookie, fpos_t _off, int _whence), int (*closefn)(void * _cookie));
# 385 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 3
/*
 * The __sfoo macros are here so that we can 
 * define function versions in the C library.
 */
# 419 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 3
/*
 * This has been tuned to generate reasonable code on the vax using pcc
 */
# 466 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 3
/* fast always-buffered version, true iff error */
# 476 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdio.h" 3

# 82 "1D_CFD.c" 2
# 1 "sqrtf.h" 1
// Use the MicroBlaze FPU to compute the square root of a 
// floating point number.
const float sqrtf(const float argument) {
 float result;
 asm volatile ("fsqrt %0, %1;" : "=r" (result) : "r" (argument)) ;
 return result;
}
# 83 "1D_CFD.c" 2

/* input */ float pressureSensor__global_0_0;
/* input */ float pumpSensor__global_0_0;
/* output */ float fuelInjector__global_0_0;

typedef enum {
 PipeSegment = 0,
 Cap,
 ImposedPressure,
 ImposedFlowRate,
 PipeT,
 Valve
} ElementType__global_0_0;

typedef struct _ComputationElement__global_0_0 {
 int id;
 ElementType__global_0_0 type;
 int mechanicalId;
 int leftId;
 int rightId;
 int topId;
 float pressure;
 float flowRate;
 float newPressure;
 float newFlowRate;
 float flowRateLeft;
 float flowRateRight;
 float flowRateTop;
 float newFlowRateLeft;
 float newFlowRateRight;
 float newFlowRateTop;
} ComputationElement__global_0_0;

static const int numberOfComputationElements__global_0_0 = 8;
ComputationElement__global_0_0 pipeNetwork__global_0_0[8] = {{.id = 0, .type = ImposedFlowRate, .mechanicalId = 0, .leftId = -1, .rightId = 1, .topId = -1, .pressure = 0.0f, .flowRate = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .flowRateLeft = 0.0f, .flowRateRight = 0.0f, .flowRateTop = 0.0f, .newFlowRateLeft = 0.0f, .newFlowRateRight = 0.0f, .newFlowRateTop = 0.0f}, {.id = 1, .type = PipeSegment, .mechanicalId = -1, .leftId = 0, .rightId = 2, .topId = -1, .pressure = 0.0f, .flowRate = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .flowRateLeft = 0.0f, .flowRateRight = 0.0f, .flowRateTop = 0.0f, .newFlowRateLeft = 0.0f, .newFlowRateRight = 0.0f, .newFlowRateTop = 0.0f}, {.id = 2, .type = PipeSegment, .mechanicalId = -1, .leftId = 1, .rightId = 3, .topId = -1, .pressure = 0.0f, .flowRate = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .flowRateLeft = 0.0f, .flowRateRight = 0.0f, .flowRateTop = 0.0f, .newFlowRateLeft = 0.0f, .newFlowRateRight = 0.0f, .newFlowRateTop = 0.0f}, {.id = 3, .type = PipeT, .mechanicalId = -1, .leftId = 2, .rightId = 4, .topId = 6, .pressure = 0.0f, .flowRate = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .flowRateLeft = 0.0f, .flowRateRight = 0.0f, .flowRateTop = 0.0f, .newFlowRateLeft = 0.0f, .newFlowRateRight = 0.0f, .newFlowRateTop = 0.0f}, {.id = 4, .type = PipeSegment, .mechanicalId = -1, .leftId = 3, .rightId = 5, .topId = -1, .pressure = 0.0f, .flowRate = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .flowRateLeft = 0.0f, .flowRateRight = 0.0f, .flowRateTop = 0.0f, .newFlowRateLeft = 0.0f, .newFlowRateRight = 0.0f, .newFlowRateTop = 0.0f}, {.id = 5, .type = Valve, .mechanicalId = 1, .leftId = 4, .rightId = -1, .topId = -1, .pressure = 0.0f, .flowRate = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .flowRateLeft = 0.0f, .flowRateRight = 0.0f, .flowRateTop = 0.0f, .newFlowRateLeft = 0.0f, .newFlowRateRight = 0.0f, .newFlowRateTop = 0.0f}, {.id = 6, .type = PipeSegment, .mechanicalId = -1, .leftId = 3, .rightId = 7, .topId = -1, .pressure = 0.0f, .flowRate = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .flowRateLeft = 0.0f, .flowRateRight = 0.0f, .flowRateTop = 0.0f, .newFlowRateLeft = 0.0f, .newFlowRateRight = 0.0f, .newFlowRateTop = 0.0f}, {.id = 7, .type = Cap, .mechanicalId = 1, .leftId = 6, .rightId = -1, .topId = -1, .pressure = 0.0f, .flowRate = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .flowRateLeft = 0.0f, .flowRateRight = 0.0f, .flowRateTop = 0.0f, .newFlowRateLeft = 0.0f, .newFlowRateRight = 0.0f, .newFlowRateTop = 0.0f}};

typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfPipeSegments__global_0_0;
Shared_numberOfPipeSegments__global_0_0 numberOfPipeSegments__global_0_0 = {.value = 4, .status = FOREC_SHARED_UNMODIFIED};

int pipeSegmentIds_array__global_0_0[4] = {1, 2, 4, 6};

typedef struct {
 /* shared */ int *value;
 unsigned short int status;
} Shared_pipeSegmentIds__global_0_0;
Shared_pipeSegmentIds__global_0_0 pipeSegmentIds__global_0_0 = {.value = pipeSegmentIds_array__global_0_0, .status = FOREC_SHARED_UNMODIFIED};
typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfCaps__global_0_0;
Shared_numberOfCaps__global_0_0 numberOfCaps__global_0_0 = {.value = 1, .status = FOREC_SHARED_UNMODIFIED};

int capIds_array__global_0_0[1] = {7};

typedef struct {
 /* shared */ int *value;
 unsigned short int status;
} Shared_capIds__global_0_0;
Shared_capIds__global_0_0 capIds__global_0_0 = {.value = capIds_array__global_0_0, .status = FOREC_SHARED_UNMODIFIED};
typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfImposedPressures__global_0_0;
Shared_numberOfImposedPressures__global_0_0 numberOfImposedPressures__global_0_0 = {.value = 0, .status = FOREC_SHARED_UNMODIFIED};

int imposedPressureIds_array__global_0_0[0];

typedef struct {
 /* shared */ int *value;
 unsigned short int status;
} Shared_imposedPressureIds__global_0_0;
Shared_imposedPressureIds__global_0_0 imposedPressureIds__global_0_0 = {.value = imposedPressureIds_array__global_0_0, .status = FOREC_SHARED_UNMODIFIED};
typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfImposedFlowRates__global_0_0;
Shared_numberOfImposedFlowRates__global_0_0 numberOfImposedFlowRates__global_0_0 = {.value = 1, .status = FOREC_SHARED_UNMODIFIED};

int imposedFlowRateIds_array__global_0_0[1] = {0};

typedef struct {
 /* shared */ int *value;
 unsigned short int status;
} Shared_imposedFlowRateIds__global_0_0;
Shared_imposedFlowRateIds__global_0_0 imposedFlowRateIds__global_0_0 = {.value = imposedFlowRateIds_array__global_0_0, .status = FOREC_SHARED_UNMODIFIED};
typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfPipeTs__global_0_0;
Shared_numberOfPipeTs__global_0_0 numberOfPipeTs__global_0_0 = {.value = 1, .status = FOREC_SHARED_UNMODIFIED};

int pipeTIds_array__global_0_0[1] = {3};

typedef struct {
 /* shared */ int *value;
 unsigned short int status;
} Shared_pipeTIds__global_0_0;
Shared_pipeTIds__global_0_0 pipeTIds__global_0_0 = {.value = pipeTIds_array__global_0_0, .status = FOREC_SHARED_UNMODIFIED};
typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfValves__global_0_0;
Shared_numberOfValves__global_0_0 numberOfValves__global_0_0 = {.value = 1, .status = FOREC_SHARED_UNMODIFIED};

int valveIds_array__global_0_0[1] = {5};

typedef struct {
 /* shared */ int *value;
 unsigned short int status;
} Shared_valveIds__global_0_0;
Shared_valveIds__global_0_0 valveIds__global_0_0 = {.value = valveIds_array__global_0_0, .status = FOREC_SHARED_UNMODIFIED};

typedef struct _FluidProperties__global_0_0 {
 float p;
 float ap;
 float newP;
 float newAp;
} FluidProperties__global_0_0;

FluidProperties__global_0_0 fluidProperties__global_0_0 = {.p = 1000.0f, .ap = 1.2E+6, .newP = 0.0f, .newAp = 0.0f};

typedef enum {
 PressureSensor = 0,
 Pump,
 ValveM
} MechanicalType__global_0_0;

typedef struct _MechanicalCalculation__global_0_0 {
 int id;
 MechanicalType__global_0_0 type;
 float pressure;
 float flowRate;
 float valvePosition;
 float newPressure;
 float newFlowRate;
 float newValvePosition;
} MechanicalCalculation__global_0_0;

typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfMechanicalCalculations__global_0_0;
Shared_numberOfMechanicalCalculations__global_0_0 numberOfMechanicalCalculations__global_0_0 = {.value = 2, .status = FOREC_SHARED_UNMODIFIED};

MechanicalCalculation__global_0_0 mechanicalCalculations__global_0_0[2] = {{.id = 0, .type = Pump, .pressure = 0.0f, .flowRate = 0.0f, .valvePosition = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .newValvePosition = 0.0f}, {.id = 1, .type = ValveM, .pressure = 0.0f, .flowRate = 0.0f, .valvePosition = 0.0f, .newPressure = 0.0f, .newFlowRate = 0.0f, .newValvePosition = 0.0f}};

typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfMechanicalPressureSensors__global_0_0;
Shared_numberOfMechanicalPressureSensors__global_0_0 numberOfMechanicalPressureSensors__global_0_0 = {.value = 0, .status = FOREC_SHARED_UNMODIFIED};

int mechanicalPressureSensorIds_array__global_0_0[0];

typedef struct {
 /* shared */ int *value;
 unsigned short int status;
} Shared_mechanicalPressureSensorIds__global_0_0;
Shared_mechanicalPressureSensorIds__global_0_0 mechanicalPressureSensorIds__global_0_0 = {.value = mechanicalPressureSensorIds_array__global_0_0, .status = FOREC_SHARED_UNMODIFIED};
typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfMechanicalPumps__global_0_0;
Shared_numberOfMechanicalPumps__global_0_0 numberOfMechanicalPumps__global_0_0 = {.value = 1, .status = FOREC_SHARED_UNMODIFIED};

int mechanicalPumpIds_array__global_0_0[1] = {0};

typedef struct {
 /* shared */ int *value;
 unsigned short int status;
} Shared_mechanicalPumpIds__global_0_0;
Shared_mechanicalPumpIds__global_0_0 mechanicalPumpIds__global_0_0 = {.value = mechanicalPumpIds_array__global_0_0, .status = FOREC_SHARED_UNMODIFIED};
typedef struct {
 /* shared */ int value;
 unsigned short int status;
} Shared_numberOfMechanicalValves__global_0_0;
Shared_numberOfMechanicalValves__global_0_0 numberOfMechanicalValves__global_0_0 = {.value = 1, .status = FOREC_SHARED_UNMODIFIED};

int mechanicalValveIds_array__global_0_0[1] = {1};

typedef struct {
 /* shared */ int *value;
 unsigned short int status;
} Shared_mechanicalValveIds__global_0_0;
Shared_mechanicalValveIds__global_0_0 mechanicalValveIds__global_0_0 = {.value = mechanicalValveIds_array__global_0_0, .status = FOREC_SHARED_UNMODIFIED};

int valveIndex__global_0_0 = 0;

void computePipeSegment(const int id, const float p, const float ap);
void computeCap(const int id, const float p, const float ap);
void computeImposedPressure(const int id, const float p, const float ap);
void computeImposedFlowRate(const int id, const float p, const float ap);
void computePipeT(const int id, const float p, const float ap);
void computeValve(const int id, const float p, const float ap);
void computeMechanicalPressureSensorCalculations(const int id);
void computeMechanicalPumpCalculations(const int id);
void computeMechanicalValveCalculations(const int id);
void computeGlobalCalculations(void);
const float interpolate(const float center, const float edge, const float slope);
const float absFloat(const float number);
void applyComputationElementNonPipeT(const int id);
void applyComputationElementPipeT(const int id);
void applyMechanicalCalculations(const int id);
void applyGlobalCalculations(void);

// thread computeNewValues__thread(void);
// thread applyNewValues__thread(void);

// Locally declared shared variables -------------------------------

// Global versions of local copies of shared variables -------------
// applyNewValues
Shared_numberOfPipeSegments__global_0_0 numberOfPipeSegments__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_pipeSegmentIds__global_0_0 pipeSegmentIds__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfCaps__global_0_0 numberOfCaps__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_capIds__global_0_0 capIds__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfImposedPressures__global_0_0 numberOfImposedPressures__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_imposedPressureIds__global_0_0 imposedPressureIds__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfImposedFlowRates__global_0_0 numberOfImposedFlowRates__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_imposedFlowRateIds__global_0_0 imposedFlowRateIds__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfPipeTs__global_0_0 numberOfPipeTs__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_pipeTIds__global_0_0 pipeTIds__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfValves__global_0_0 numberOfValves__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_valveIds__global_0_0 valveIds__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfMechanicalPressureSensors__global_0_0 numberOfMechanicalPressureSensors__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfMechanicalPumps__global_0_0 numberOfMechanicalPumps__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_mechanicalPumpIds__global_0_0 mechanicalPumpIds__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfMechanicalValves__global_0_0 numberOfMechanicalValves__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_mechanicalValveIds__global_0_0 mechanicalValveIds__global_0_0_copy_applyNewValues = {.status = FOREC_SHARED_UNMODIFIED};
// computeNewValues
Shared_numberOfPipeSegments__global_0_0 numberOfPipeSegments__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_pipeSegmentIds__global_0_0 pipeSegmentIds__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfCaps__global_0_0 numberOfCaps__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_capIds__global_0_0 capIds__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfImposedPressures__global_0_0 numberOfImposedPressures__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_imposedPressureIds__global_0_0 imposedPressureIds__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfImposedFlowRates__global_0_0 numberOfImposedFlowRates__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_imposedFlowRateIds__global_0_0 imposedFlowRateIds__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfPipeTs__global_0_0 numberOfPipeTs__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_pipeTIds__global_0_0 pipeTIds__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfValves__global_0_0 numberOfValves__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_valveIds__global_0_0 valveIds__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfMechanicalPressureSensors__global_0_0 numberOfMechanicalPressureSensors__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfMechanicalPumps__global_0_0 numberOfMechanicalPumps__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_mechanicalPumpIds__global_0_0 mechanicalPumpIds__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_numberOfMechanicalValves__global_0_0 numberOfMechanicalValves__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
Shared_mechanicalValveIds__global_0_0 mechanicalValveIds__global_0_0_copy_computeNewValues = {.status = FOREC_SHARED_UNMODIFIED};
// main

// forec:scheduler:boot:start
int main(int argc__main_0_0, char ** argv__main_0_0) {

/*==============================================================

| Multicore startup:

| Platform dependent code.  Core identifies itself and

| executes its corresponding start up code.

*=============================================================*/
# 343 "1D_CFD.c"
 // Initialise ForeC specific values ----------------------------
 // Thread main with par(...)s
 mainParParent.parStatus = FOREC_PAR_OFF;
 mainParCore0.sync = 1;
 mainParCore0.status = FOREC_CORE_REACTING;
 mainParReactionCounter = 0;


 // ForeC mutex -------------------------------------------------
 unsigned int forec_mutex_value;
 asm volatile ("put\t%0,rfsl" "1" :: "d" (0));

 // Variables for par()s ----------------------------------------
 // par0
 Thread computeNewValues__thread;
 Thread mainReactionStartMaster0;
 Thread mainReactionEndMaster0;

 // par1
 Thread applyNewValues__thread;
 // Thread mainReactionStartMaster0;
 // Thread mainReactionEndMaster0;


 // Synchronise execution of cores ------------------------------
 // pvr = Processor Version Register
 unsigned int pvr0;
 asm volatile ("mfs\t%0,rpvr" "0" "\n\t" : "=d" (pvr0));
 pvr0 &= 0x000000FF;

 switch (pvr0) {
  case (0):
   goto mainParCore0;

  default:
   // "Lock-up" unused cores.
   while(1);
 }
// forec:scheduler:boot:end

/*==============================================================

| Core specific instructions:

| Contains par, abort and synchronisation handlers.

*=============================================================*/
# 388 "1D_CFD.c"
 // forec:thread:main:start
 /*--------------------------------------------------------------

	| Master core: core0

	| ForeC program's main() function:

	| Original main() function code with ForeC constructs

	| translated into C code.

	*-------------------------------------------------------------*/
# 396 "1D_CFD.c"
 // Thread local declarations -----------------------------------
 // No declarations.
mainParCore0: {
 // forec:scheduler:counter:start
 // Initialise and start counting the elapsed cycles for each reaction.
 counter.current = 0; counter.last = 0; counter.difference = 0; counter.min = 2147483647; counter.avg = 0; counter.max = 0; counter.total = 0; counter.iterations = 0;
 counter.last = counter.current; asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
 // forec:scheduler:counter:end

 // Initialise the local copies of shared variables.
 //--------------------------------------------------------------

 while (1) {
  // par0(computeNewValues__thread);
  // Set the par(...) information.
  mainParParent.parId = 0;
  mainParParent.parStatus = FOREC_PAR_ON;

  // Link the threads and handlers together.
  mainReactionStartMaster0.programCounter = &&mainReactionStartMaster0;
  computeNewValues__thread.programCounter = &&computeNewValues__thread;
  mainReactionStartMaster0.nextThread = &computeNewValues__thread;
  computeNewValues__thread.prevThread = &mainReactionStartMaster0;
  mainReactionEndMaster0.programCounter = &&mainReactionEndMaster0;
  computeNewValues__thread.nextThread = &mainReactionEndMaster0;
  mainReactionEndMaster0.prevThread = &computeNewValues__thread;

  // Link the last and first threads/handlers together.
  mainReactionEndMaster0.nextThread = &mainReactionStartMaster0;
  mainReactionStartMaster0.prevThread = &mainReactionEndMaster0;

  // Set the join address.
  mainParParent.programCounter = &&par0JoinAddress_mainParCore0;

  // Set the core information.
  mainParCore0.activeThreads = 1;
  mainParCore0.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  // forec:statement:par:par0:start
  goto computeNewValues__thread;
  par0JoinAddress_mainParCore0:;
  // forec:statement:par:par0:end

  // par1(applyNewValues__thread);
  // Set the par(...) information.
  mainParParent.parId = 1;
  mainParParent.parStatus = FOREC_PAR_ON;

  // Link the threads and handlers together.
  mainReactionStartMaster0.programCounter = &&mainReactionStartMaster0;
  applyNewValues__thread.programCounter = &&applyNewValues__thread;
  mainReactionStartMaster0.nextThread = &applyNewValues__thread;
  applyNewValues__thread.prevThread = &mainReactionStartMaster0;
  mainReactionEndMaster0.programCounter = &&mainReactionEndMaster0;
  applyNewValues__thread.nextThread = &mainReactionEndMaster0;
  mainReactionEndMaster0.prevThread = &applyNewValues__thread;

  // Link the last and first threads/handlers together.
  mainReactionEndMaster0.nextThread = &mainReactionStartMaster0;
  mainReactionStartMaster0.prevThread = &mainReactionEndMaster0;

  // Set the join address.
  mainParParent.programCounter = &&par1JoinAddress_mainParCore0;

  // Set the core information.
  mainParCore0.activeThreads = 1;
  mainParCore0.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  // forec:statement:par:par1:start
  goto applyNewValues__thread;
  par1JoinAddress_mainParCore0:;
  // forec:statement:par:par1:end

  // pause;
  // forec:statement:pause:pause0:start
  // forec:statement:pause:pause0:end

  // forec:scheduler:counter:start
  // Stop counting the elapsed cycles for the current reaction.
  asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
  asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
  counter.difference = counter.current - counter.last;
  if (counter.max < counter.difference) { counter.max = counter.difference; };
  if (counter.min > counter.difference) { counter.min = counter.difference; };
  counter.total += counter.difference; counter.iterations++;
  counter.avg = counter.total/counter.iterations;
  xil_printf("%d Reaction time: %ld cycles, Min: %d, Avg: %d, Max: %d\r\n", globalReactions, counter.difference, counter.min, counter.avg, counter.max);
  // Restart the counting of elapsed cycles for the next reaction.
  counter.current = 0; counter.last = 0;
  counter.last = counter.current; asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
  // forec:scheduler:counter:end


  // forec:scheduler:iterationEnd:while_0:start
  // Synchronise end of iteration
  mainParParent.parId = -2;
  mainParParent.parStatus = FOREC_PAR_ON;
  mainParParent.programCounter = &&while_0_endAddress;
  goto mainParHandlerMaster0;
  while_0_endAddress:;
  // forec:scheduler:iterationEnd:while_0:end
  asm volatile ("nop");
 }

 //--------------------------------------------------------------
 // Write the defined shared variables back to their global copy.

 // forec:scheduler:threadRemove:main:start

 // forec:scheduler:counter:start
 // Stop counting the elapsed cycles for the current reaction.
 asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
 asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
 counter.difference = counter.current - counter.last;
 if (counter.max < counter.difference) { counter.max = counter.difference; };
 if (counter.min > counter.difference) { counter.min = counter.difference; };
 counter.total += counter.difference; counter.iterations++;
 counter.avg = counter.total/counter.iterations;
 xil_printf("%ld Reaction time: %d cycles, Min: %d, Avg: %d, Max: %d\r\n", globalReactions, counter.difference, counter.min, counter.avg, counter.max);
 xil_printf("Total time: %d cycles\r\n", counter.total);
 xil_printf("Program termination\r\n");
 // forec:scheduler:counter:end

 asm volatile (".long 0x80000001\r\n");
 return 0;
 // forec:scheduler:threadRemove:main:end
} // mainParCore0
 // forec:thread:main:end

// forec:scheduler:parHandler:main:master:0:start
mainParHandlerMaster0: {
 if (mainParParent.parId == -2) {
  // Iteration
  // Wait for other cores to complete their reaction.

  mainParParent.parStatus = FOREC_PAR_OFF;
  mainParParent.parId = -1;

  // Set slave cores' status to reacting.

  // Increment the reaction counter for synchronisation.
  mainParReactionCounter++;

  // Return to thread main.
  goto *mainParParent.programCounter;
 }

 // Control should not reach here.
 goto mainParHandlerMaster0;
}
// forec:scheduler:parHandler:main:master:0:end


 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:master:0:start
 //-- main:
mainReactionStartMaster0: {
 // Go to the next thread.
 goto *mainReactionStartMaster0.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:master:0:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:master:0:start
 //-- main:
mainReactionEndMaster0: {
 // Determine if the core can still react or not.
 if (mainParCore0.activeThreads) {
  mainParCore0.status = FOREC_CORE_REACTED;
 } else {
  mainParCore0.status = FOREC_CORE_TERMINATED;
 }

 // Wait for other cores to complete their reaction.

 // Reset the mutex.
 asm volatile ("put\t%0,rfsl" "1" :: "d" (0));

 // Return back to the parent thread if all the cores have terminated.
 if (1 && mainParCore0.status == FOREC_CORE_TERMINATED) {
  mainParParent.parStatus = FOREC_PAR_OFF;
  mainParParent.parId = -1;

  // Set slave cores' status to reacting

  // Increment the reaction counter for synchronization.
  mainParReactionCounter++;

  goto *mainParParent.programCounter;
 }

 // Set slave cores' status to reacting

 // forec:scheduler:counter:start
 // Stop counting the elapsed cycles for the current reaction.
 asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
 asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
 counter.difference = counter.current - counter.last;
 if (counter.max < counter.difference) { counter.max = counter.difference; };
 if (counter.min > counter.difference) { counter.min = counter.difference; };
 counter.total += counter.difference; counter.iterations++;
 counter.avg = counter.total/counter.iterations;
 xil_printf("%d Reaction time: %ld cycles, Min: %d, Avg: %d, Max: %d\r\n", globalReactions, counter.difference, counter.min, counter.avg, counter.max);
 // Restart counting of the elapsed cycles for the next reaction.
 counter.current = 0; counter.last = 0;
 counter.last = counter.current; asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
 // forec:scheduler:counter:end

 // Increment the reaction counter for synchronization.
 mainParReactionCounter++;

 // Go to the next thread.
 goto *mainReactionEndMaster0.nextThread -> programCounter;
}
 // forec:scheduler:reactionEnd:main:master:0:end



 // Abort check handlers ----------------------------------------




/*==============================================================

| ForeC threads:

| Threads code translated into C code.

*=============================================================*/
# 630 "1D_CFD.c"
 // forec:thread:applyNewValues:start
 /*--------------------------------------------------------------

	| Thread applyNewValues

	*-------------------------------------------------------------*/
# 635 "1D_CFD.c"
 // Thread local declarations -----------------------------------
 Shared_numberOfPipeSegments__global_0_0 numberOfPipeSegments__global_0_0_copy_applyNewValues_local;
 Shared_pipeSegmentIds__global_0_0 pipeSegmentIds__global_0_0_copy_applyNewValues_local;
 Shared_numberOfCaps__global_0_0 numberOfCaps__global_0_0_copy_applyNewValues_local;
 Shared_capIds__global_0_0 capIds__global_0_0_copy_applyNewValues_local;
 Shared_numberOfImposedPressures__global_0_0 numberOfImposedPressures__global_0_0_copy_applyNewValues_local;
 Shared_imposedPressureIds__global_0_0 imposedPressureIds__global_0_0_copy_applyNewValues_local;
 Shared_numberOfImposedFlowRates__global_0_0 numberOfImposedFlowRates__global_0_0_copy_applyNewValues_local;
 Shared_imposedFlowRateIds__global_0_0 imposedFlowRateIds__global_0_0_copy_applyNewValues_local;
 Shared_numberOfPipeTs__global_0_0 numberOfPipeTs__global_0_0_copy_applyNewValues_local;
 Shared_pipeTIds__global_0_0 pipeTIds__global_0_0_copy_applyNewValues_local;
 Shared_numberOfValves__global_0_0 numberOfValves__global_0_0_copy_applyNewValues_local;
 Shared_valveIds__global_0_0 valveIds__global_0_0_copy_applyNewValues_local;
 Shared_numberOfMechanicalPressureSensors__global_0_0 numberOfMechanicalPressureSensors__global_0_0_copy_applyNewValues_local;
 Shared_numberOfMechanicalPumps__global_0_0 numberOfMechanicalPumps__global_0_0_copy_applyNewValues_local;
 Shared_mechanicalPumpIds__global_0_0 mechanicalPumpIds__global_0_0_copy_applyNewValues_local;
 Shared_numberOfMechanicalValves__global_0_0 numberOfMechanicalValves__global_0_0_copy_applyNewValues_local;
 Shared_mechanicalValveIds__global_0_0 mechanicalValveIds__global_0_0_copy_applyNewValues_local;
 int i__applyNewValues_0_0;

 // Thread body -------------------------------------------------
 applyNewValues__thread: {
  // Initialise the local copies of shared variables.
  numberOfPipeSegments__global_0_0_copy_applyNewValues_local.value = numberOfPipeSegments__global_0_0.value;
  numberOfPipeSegments__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  pipeSegmentIds__global_0_0_copy_applyNewValues_local.value = pipeSegmentIds__global_0_0.value;
  pipeSegmentIds__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfCaps__global_0_0_copy_applyNewValues_local.value = numberOfCaps__global_0_0.value;
  numberOfCaps__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  capIds__global_0_0_copy_applyNewValues_local.value = capIds__global_0_0.value;
  capIds__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfImposedPressures__global_0_0_copy_applyNewValues_local.value = numberOfImposedPressures__global_0_0.value;
  numberOfImposedPressures__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  imposedPressureIds__global_0_0_copy_applyNewValues_local.value = imposedPressureIds__global_0_0.value;
  imposedPressureIds__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfImposedFlowRates__global_0_0_copy_applyNewValues_local.value = numberOfImposedFlowRates__global_0_0.value;
  numberOfImposedFlowRates__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  imposedFlowRateIds__global_0_0_copy_applyNewValues_local.value = imposedFlowRateIds__global_0_0.value;
  imposedFlowRateIds__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfPipeTs__global_0_0_copy_applyNewValues_local.value = numberOfPipeTs__global_0_0.value;
  numberOfPipeTs__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  pipeTIds__global_0_0_copy_applyNewValues_local.value = pipeTIds__global_0_0.value;
  pipeTIds__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfValves__global_0_0_copy_applyNewValues_local.value = numberOfValves__global_0_0.value;
  numberOfValves__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  valveIds__global_0_0_copy_applyNewValues_local.value = valveIds__global_0_0.value;
  valveIds__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfMechanicalPressureSensors__global_0_0_copy_applyNewValues_local.value = numberOfMechanicalPressureSensors__global_0_0.value;
  numberOfMechanicalPressureSensors__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfMechanicalPumps__global_0_0_copy_applyNewValues_local.value = numberOfMechanicalPumps__global_0_0.value;
  numberOfMechanicalPumps__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  mechanicalPumpIds__global_0_0_copy_applyNewValues_local.value = mechanicalPumpIds__global_0_0.value;
  mechanicalPumpIds__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfMechanicalValves__global_0_0_copy_applyNewValues_local.value = numberOfMechanicalValves__global_0_0.value;
  numberOfMechanicalValves__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  mechanicalValveIds__global_0_0_copy_applyNewValues_local.value = mechanicalValveIds__global_0_0.value;
  mechanicalValveIds__global_0_0_copy_applyNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  //--------------------------------------------------------------

  for (i__applyNewValues_0_0 = 0; i__applyNewValues_0_0 < numberOfPipeSegments__global_0_0_copy_applyNewValues_local.value; ++i__applyNewValues_0_0) {
   applyComputationElementNonPipeT(pipeSegmentIds__global_0_0_copy_applyNewValues_local.value[i__applyNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_10:bound:4:4
  }
  for (i__applyNewValues_0_0 = 0; i__applyNewValues_0_0 < numberOfCaps__global_0_0_copy_applyNewValues_local.value; ++i__applyNewValues_0_0) {
   applyComputationElementNonPipeT(capIds__global_0_0_copy_applyNewValues_local.value[i__applyNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_11:bound:1:1
  }
  for (i__applyNewValues_0_0 = 0; i__applyNewValues_0_0 < numberOfImposedPressures__global_0_0_copy_applyNewValues_local.value; ++i__applyNewValues_0_0) {
   applyComputationElementNonPipeT(imposedPressureIds__global_0_0_copy_applyNewValues_local.value[i__applyNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_12:bound:0:0
  }
  for (i__applyNewValues_0_0 = 0; i__applyNewValues_0_0 < numberOfImposedFlowRates__global_0_0_copy_applyNewValues_local.value; ++i__applyNewValues_0_0) {
   applyComputationElementNonPipeT(imposedFlowRateIds__global_0_0_copy_applyNewValues_local.value[i__applyNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_13:bound:1:1
  }
  for (i__applyNewValues_0_0 = 0; i__applyNewValues_0_0 < numberOfPipeTs__global_0_0_copy_applyNewValues_local.value; ++i__applyNewValues_0_0) {
   applyComputationElementPipeT(pipeTIds__global_0_0_copy_applyNewValues_local.value[i__applyNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_14:bound:1:1
  }
  for (i__applyNewValues_0_0 = 0; i__applyNewValues_0_0 < numberOfValves__global_0_0_copy_applyNewValues_local.value; ++i__applyNewValues_0_0) {
   applyComputationElementNonPipeT(valveIds__global_0_0_copy_applyNewValues_local.value[i__applyNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_15:bound:1:1
  }
  for (i__applyNewValues_0_0 = 0; i__applyNewValues_0_0 < numberOfMechanicalPressureSensors__global_0_0_copy_applyNewValues_local.value; ++i__applyNewValues_0_0) {
   applyMechanicalCalculations(mechanicalPumpIds__global_0_0_copy_applyNewValues_local.value[i__applyNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_16:bound:0:0
  }
  for (i__applyNewValues_0_0 = 0; i__applyNewValues_0_0 < numberOfMechanicalPumps__global_0_0_copy_applyNewValues_local.value; ++i__applyNewValues_0_0) {
   applyMechanicalCalculations(mechanicalPumpIds__global_0_0_copy_applyNewValues_local.value[i__applyNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_17:bound:1:1
  }
  for (i__applyNewValues_0_0 = 0; i__applyNewValues_0_0 < numberOfMechanicalValves__global_0_0_copy_applyNewValues_local.value; ++i__applyNewValues_0_0) {
   applyMechanicalCalculations(mechanicalValveIds__global_0_0_copy_applyNewValues_local.value[i__applyNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_18:bound:1:1
  }
  applyGlobalCalculations();

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:applyNewValues:start

  // Delete thread from the linked list and core.
  mainParCore0.activeThreads--;
  applyNewValues__thread.nextThread -> prevThread = applyNewValues__thread.prevThread;
  applyNewValues__thread.prevThread -> nextThread = applyNewValues__thread.nextThread;
  goto *applyNewValues__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:applyNewValues:end
 } // applyNewValues__thread
 // forec:thread:applyNewValues:end

 // forec:thread:computeNewValues:start
 /*--------------------------------------------------------------

	| Thread computeNewValues

	*-------------------------------------------------------------*/
# 760 "1D_CFD.c"
 // Thread local declarations -----------------------------------
 Shared_numberOfPipeSegments__global_0_0 numberOfPipeSegments__global_0_0_copy_computeNewValues_local;
 Shared_pipeSegmentIds__global_0_0 pipeSegmentIds__global_0_0_copy_computeNewValues_local;
 Shared_numberOfCaps__global_0_0 numberOfCaps__global_0_0_copy_computeNewValues_local;
 Shared_capIds__global_0_0 capIds__global_0_0_copy_computeNewValues_local;
 Shared_numberOfImposedPressures__global_0_0 numberOfImposedPressures__global_0_0_copy_computeNewValues_local;
 Shared_imposedPressureIds__global_0_0 imposedPressureIds__global_0_0_copy_computeNewValues_local;
 Shared_numberOfImposedFlowRates__global_0_0 numberOfImposedFlowRates__global_0_0_copy_computeNewValues_local;
 Shared_imposedFlowRateIds__global_0_0 imposedFlowRateIds__global_0_0_copy_computeNewValues_local;
 Shared_numberOfPipeTs__global_0_0 numberOfPipeTs__global_0_0_copy_computeNewValues_local;
 Shared_pipeTIds__global_0_0 pipeTIds__global_0_0_copy_computeNewValues_local;
 Shared_numberOfValves__global_0_0 numberOfValves__global_0_0_copy_computeNewValues_local;
 Shared_valveIds__global_0_0 valveIds__global_0_0_copy_computeNewValues_local;
 Shared_numberOfMechanicalPressureSensors__global_0_0 numberOfMechanicalPressureSensors__global_0_0_copy_computeNewValues_local;
 Shared_numberOfMechanicalPumps__global_0_0 numberOfMechanicalPumps__global_0_0_copy_computeNewValues_local;
 Shared_mechanicalPumpIds__global_0_0 mechanicalPumpIds__global_0_0_copy_computeNewValues_local;
 Shared_numberOfMechanicalValves__global_0_0 numberOfMechanicalValves__global_0_0_copy_computeNewValues_local;
 Shared_mechanicalValveIds__global_0_0 mechanicalValveIds__global_0_0_copy_computeNewValues_local;
 float p__computeNewValues_0_0;
 float ap__computeNewValues_0_0;
 int i__computeNewValues_0_0;

 // Thread body -------------------------------------------------
 computeNewValues__thread: {
  // Initialise the local copies of shared variables.
  numberOfPipeSegments__global_0_0_copy_computeNewValues_local.value = numberOfPipeSegments__global_0_0.value;
  numberOfPipeSegments__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  pipeSegmentIds__global_0_0_copy_computeNewValues_local.value = pipeSegmentIds__global_0_0.value;
  pipeSegmentIds__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfCaps__global_0_0_copy_computeNewValues_local.value = numberOfCaps__global_0_0.value;
  numberOfCaps__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  capIds__global_0_0_copy_computeNewValues_local.value = capIds__global_0_0.value;
  capIds__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfImposedPressures__global_0_0_copy_computeNewValues_local.value = numberOfImposedPressures__global_0_0.value;
  numberOfImposedPressures__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  imposedPressureIds__global_0_0_copy_computeNewValues_local.value = imposedPressureIds__global_0_0.value;
  imposedPressureIds__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfImposedFlowRates__global_0_0_copy_computeNewValues_local.value = numberOfImposedFlowRates__global_0_0.value;
  numberOfImposedFlowRates__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  imposedFlowRateIds__global_0_0_copy_computeNewValues_local.value = imposedFlowRateIds__global_0_0.value;
  imposedFlowRateIds__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfPipeTs__global_0_0_copy_computeNewValues_local.value = numberOfPipeTs__global_0_0.value;
  numberOfPipeTs__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  pipeTIds__global_0_0_copy_computeNewValues_local.value = pipeTIds__global_0_0.value;
  pipeTIds__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfValves__global_0_0_copy_computeNewValues_local.value = numberOfValves__global_0_0.value;
  numberOfValves__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  valveIds__global_0_0_copy_computeNewValues_local.value = valveIds__global_0_0.value;
  valveIds__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfMechanicalPressureSensors__global_0_0_copy_computeNewValues_local.value = numberOfMechanicalPressureSensors__global_0_0.value;
  numberOfMechanicalPressureSensors__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfMechanicalPumps__global_0_0_copy_computeNewValues_local.value = numberOfMechanicalPumps__global_0_0.value;
  numberOfMechanicalPumps__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  mechanicalPumpIds__global_0_0_copy_computeNewValues_local.value = mechanicalPumpIds__global_0_0.value;
  mechanicalPumpIds__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  numberOfMechanicalValves__global_0_0_copy_computeNewValues_local.value = numberOfMechanicalValves__global_0_0.value;
  numberOfMechanicalValves__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  mechanicalValveIds__global_0_0_copy_computeNewValues_local.value = mechanicalValveIds__global_0_0.value;
  mechanicalValveIds__global_0_0_copy_computeNewValues_local.status = FOREC_SHARED_UNMODIFIED;
  //--------------------------------------------------------------

  p__computeNewValues_0_0 = fluidProperties__global_0_0.p;
  ap__computeNewValues_0_0 = fluidProperties__global_0_0.ap;
  for (i__computeNewValues_0_0 = 0; i__computeNewValues_0_0 < numberOfPipeSegments__global_0_0_copy_computeNewValues_local.value; ++i__computeNewValues_0_0) {
   computePipeSegment(pipeSegmentIds__global_0_0_copy_computeNewValues_local.value[i__computeNewValues_0_0], p__computeNewValues_0_0, ap__computeNewValues_0_0);
   asm volatile ("nop");
   // forec:iteration:for1_1:bound:4:4
  }
  for (i__computeNewValues_0_0 = 0; i__computeNewValues_0_0 < numberOfCaps__global_0_0_copy_computeNewValues_local.value; ++i__computeNewValues_0_0) {
   computeCap(capIds__global_0_0_copy_computeNewValues_local.value[i__computeNewValues_0_0], p__computeNewValues_0_0, ap__computeNewValues_0_0);
   asm volatile ("nop");
   // forec:iteration:for1_2:bound:1:1
  }
  for (i__computeNewValues_0_0 = 0; i__computeNewValues_0_0 < numberOfImposedPressures__global_0_0_copy_computeNewValues_local.value; ++i__computeNewValues_0_0) {
   computeImposedPressure(imposedPressureIds__global_0_0_copy_computeNewValues_local.value[i__computeNewValues_0_0], p__computeNewValues_0_0, ap__computeNewValues_0_0);
   asm volatile ("nop");
   // forec:iteration:for1_3:bound:0:0
  }
  for (i__computeNewValues_0_0 = 0; i__computeNewValues_0_0 < numberOfImposedFlowRates__global_0_0_copy_computeNewValues_local.value; ++i__computeNewValues_0_0) {
   computeImposedFlowRate(imposedFlowRateIds__global_0_0_copy_computeNewValues_local.value[i__computeNewValues_0_0], p__computeNewValues_0_0, ap__computeNewValues_0_0);
   asm volatile ("nop");
   // forec:iteration:for1_4:bound:1:1
  }
  for (i__computeNewValues_0_0 = 0; i__computeNewValues_0_0 < numberOfPipeTs__global_0_0_copy_computeNewValues_local.value; ++i__computeNewValues_0_0) {
   computePipeT(pipeTIds__global_0_0_copy_computeNewValues_local.value[i__computeNewValues_0_0], p__computeNewValues_0_0, ap__computeNewValues_0_0);
   asm volatile ("nop");
   // forec:iteration:for1_5:bound:1:1
  }
  for (i__computeNewValues_0_0 = 0; i__computeNewValues_0_0 < numberOfValves__global_0_0_copy_computeNewValues_local.value; ++i__computeNewValues_0_0) {
   computeValve(valveIds__global_0_0_copy_computeNewValues_local.value[i__computeNewValues_0_0], p__computeNewValues_0_0, ap__computeNewValues_0_0);
   asm volatile ("nop");
   // forec:iteration:for1_6:bound:1:1
  }
  for (i__computeNewValues_0_0 = 0; i__computeNewValues_0_0 < numberOfMechanicalPressureSensors__global_0_0_copy_computeNewValues_local.value; ++i__computeNewValues_0_0) {
   computeMechanicalPressureSensorCalculations(mechanicalPumpIds__global_0_0_copy_computeNewValues_local.value[i__computeNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_7:bound:0:0
  }
  for (i__computeNewValues_0_0 = 0; i__computeNewValues_0_0 < numberOfMechanicalPumps__global_0_0_copy_computeNewValues_local.value; ++i__computeNewValues_0_0) {
   computeMechanicalPumpCalculations(mechanicalPumpIds__global_0_0_copy_computeNewValues_local.value[i__computeNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_8:bound:1:1
  }
  for (i__computeNewValues_0_0 = 0; i__computeNewValues_0_0 < numberOfMechanicalValves__global_0_0_copy_computeNewValues_local.value; ++i__computeNewValues_0_0) {
   computeMechanicalValveCalculations(mechanicalValveIds__global_0_0_copy_computeNewValues_local.value[i__computeNewValues_0_0]);
   asm volatile ("nop");
   // forec:iteration:for1_9:bound:1:1
  }
  computeGlobalCalculations();
  valveIndex__global_0_0++;

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:computeNewValues:start

  // Delete thread from the linked list and core.
  mainParCore0.activeThreads--;
  computeNewValues__thread.nextThread -> prevThread = computeNewValues__thread.prevThread;
  computeNewValues__thread.prevThread -> nextThread = computeNewValues__thread.nextThread;
  goto *computeNewValues__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:computeNewValues:end
 } // computeNewValues__thread
 // forec:thread:computeNewValues:end


} // End of the main() function.

void computePipeSegment(const int id__computePipeSegment_0_0, const float p__computePipeSegment_0_0, const float ap__computePipeSegment_0_0) {
 const float theta__computePipeSegment_0_0 = 1.0f;
 const float A__computePipeSegment_0_0 = 1.0f;
 const float E__computePipeSegment_0_0 = p__computePipeSegment_0_0*1.0f;
 const float B__computePipeSegment_0_0 = ap__computePipeSegment_0_0/A__computePipeSegment_0_0;
 const float A2__computePipeSegment_0_0 = 1.0f;
 const float A3__computePipeSegment_0_0 = 1.0f;
 float pressureLeft__computePipeSegment_0_0;
 float flowRateLeft__computePipeSegment_0_0;
 const int leftId__computePipeSegment_0_0 = pipeNetwork__global_0_0[id__computePipeSegment_0_0].leftId;
 if (leftId__computePipeSegment_0_0 != -1) {
  pressureLeft__computePipeSegment_0_0 = pipeNetwork__global_0_0[leftId__computePipeSegment_0_0].pressure;
  flowRateLeft__computePipeSegment_0_0 = pipeNetwork__global_0_0[leftId__computePipeSegment_0_0].flowRate;
 } else {
  // ifElse0
  pressureLeft__computePipeSegment_0_0 = 0.0f;
  flowRateLeft__computePipeSegment_0_0 = 0.0f;
 }
 float pressureRight__computePipeSegment_0_0;
 float flowRateRight__computePipeSegment_0_0;
 const int rightId__computePipeSegment_0_0 = pipeNetwork__global_0_0[id__computePipeSegment_0_0].rightId;
 if (rightId__computePipeSegment_0_0 != -1) {
  pressureRight__computePipeSegment_0_0 = pipeNetwork__global_0_0[rightId__computePipeSegment_0_0].pressure;
  flowRateRight__computePipeSegment_0_0 = pipeNetwork__global_0_0[rightId__computePipeSegment_0_0].flowRate;
 } else {
  // ifElse1
  pressureRight__computePipeSegment_0_0 = 0.0f;
  flowRateRight__computePipeSegment_0_0 = 0.0f;
 }
 const float pressure__computePipeSegment_0_0 = pipeNetwork__global_0_0[id__computePipeSegment_0_0].pressure;
 const float flowRate__computePipeSegment_0_0 = pipeNetwork__global_0_0[id__computePipeSegment_0_0].flowRate;
 pressureLeft__computePipeSegment_0_0 = interpolate(pressure__computePipeSegment_0_0, pressureLeft__computePipeSegment_0_0, (ap__computePipeSegment_0_0*theta__computePipeSegment_0_0));
 flowRateLeft__computePipeSegment_0_0 = interpolate(flowRate__computePipeSegment_0_0, flowRateLeft__computePipeSegment_0_0, (ap__computePipeSegment_0_0*theta__computePipeSegment_0_0));
 pressureRight__computePipeSegment_0_0 = interpolate(pressure__computePipeSegment_0_0, pressureRight__computePipeSegment_0_0, (ap__computePipeSegment_0_0*theta__computePipeSegment_0_0));
 flowRateRight__computePipeSegment_0_0 = interpolate(flowRate__computePipeSegment_0_0, flowRateRight__computePipeSegment_0_0, (ap__computePipeSegment_0_0*theta__computePipeSegment_0_0));
 const float Cp__computePipeSegment_0_0 = pressureLeft__computePipeSegment_0_0 + flowRateLeft__computePipeSegment_0_0*(B__computePipeSegment_0_0 - E__computePipeSegment_0_0*absFloat(flowRateLeft__computePipeSegment_0_0));
 const float Cm__computePipeSegment_0_0 = pressureRight__computePipeSegment_0_0 - flowRateRight__computePipeSegment_0_0*(B__computePipeSegment_0_0 - E__computePipeSegment_0_0*absFloat(flowRateRight__computePipeSegment_0_0));
 const float newPressure__computePipeSegment_0_0 = (Cp__computePipeSegment_0_0 + Cm__computePipeSegment_0_0)/2.0f;
 pipeNetwork__global_0_0[id__computePipeSegment_0_0].newPressure = newPressure__computePipeSegment_0_0;
 pipeNetwork__global_0_0[id__computePipeSegment_0_0].newFlowRate = (newPressure__computePipeSegment_0_0 - Cm__computePipeSegment_0_0)/B__computePipeSegment_0_0;
}

void computeCap(const int id__computeCap_0_0, const float p__computeCap_0_0, const float ap__computeCap_0_0) {
 const float theta__computeCap_0_0 = 1.0f;
 const float A__computeCap_0_0 = 1.0f;
 const float E__computeCap_0_0 = p__computeCap_0_0*1.0f;
 const float B__computeCap_0_0 = ap__computeCap_0_0/A__computeCap_0_0;
 const float A2__computeCap_0_0 = 1.0f;
 const float A3__computeCap_0_0 = 1.0f;
 float pressureLeft__computeCap_0_0;
 float flowRateLeft__computeCap_0_0;
 const int leftId__computeCap_0_0 = pipeNetwork__global_0_0[id__computeCap_0_0].leftId;
 if (leftId__computeCap_0_0 != -1) {
  pressureLeft__computeCap_0_0 = pipeNetwork__global_0_0[leftId__computeCap_0_0].pressure;
  flowRateLeft__computeCap_0_0 = pipeNetwork__global_0_0[leftId__computeCap_0_0].flowRate;
 } else {
  // ifElse2
  pressureLeft__computeCap_0_0 = 0.0f;
  flowRateLeft__computeCap_0_0 = 0.0f;
 }
 const float pressure__computeCap_0_0 = pipeNetwork__global_0_0[id__computeCap_0_0].pressure;
 const float flowRate__computeCap_0_0 = pipeNetwork__global_0_0[id__computeCap_0_0].flowRate;
 pressureLeft__computeCap_0_0 = interpolate(pressure__computeCap_0_0, pressureLeft__computeCap_0_0, (ap__computeCap_0_0*theta__computeCap_0_0));
 flowRateLeft__computeCap_0_0 = interpolate(flowRate__computeCap_0_0, flowRateLeft__computeCap_0_0, (ap__computeCap_0_0*theta__computeCap_0_0));
 ;
 const float Cp__computeCap_0_0 = pressureLeft__computeCap_0_0 + flowRateLeft__computeCap_0_0*(B__computeCap_0_0 - E__computeCap_0_0*absFloat(flowRateLeft__computeCap_0_0));
 const float newFlowRate__computeCap_0_0 = 0.0f;
 pipeNetwork__global_0_0[id__computeCap_0_0].newFlowRate = newFlowRate__computeCap_0_0;
 pipeNetwork__global_0_0[id__computeCap_0_0].newPressure = Cp__computeCap_0_0 - B__computeCap_0_0*newFlowRate__computeCap_0_0;
}

void computeImposedPressure(const int id__computeImposedPressure_0_0, const float p__computeImposedPressure_0_0, const float ap__computeImposedPressure_0_0) {
 const float theta__computeImposedPressure_0_0 = 1.0f;
 const float A__computeImposedPressure_0_0 = 1.0f;
 const float E__computeImposedPressure_0_0 = p__computeImposedPressure_0_0*1.0f;
 const float B__computeImposedPressure_0_0 = ap__computeImposedPressure_0_0/A__computeImposedPressure_0_0;
 const float A2__computeImposedPressure_0_0 = 1.0f;
 const float A3__computeImposedPressure_0_0 = 1.0f;
 float pressureRight__computeImposedPressure_0_0;
 float flowRateRight__computeImposedPressure_0_0;
 const int rightId__computeImposedPressure_0_0 = pipeNetwork__global_0_0[id__computeImposedPressure_0_0].rightId;
 if (rightId__computeImposedPressure_0_0 != -1) {
  pressureRight__computeImposedPressure_0_0 = pipeNetwork__global_0_0[rightId__computeImposedPressure_0_0].pressure;
  flowRateRight__computeImposedPressure_0_0 = pipeNetwork__global_0_0[rightId__computeImposedPressure_0_0].flowRate;
 } else {
  // ifElse3
  pressureRight__computeImposedPressure_0_0 = 0.0f;
  flowRateRight__computeImposedPressure_0_0 = 0.0f;
 }
 const float pressure__computeImposedPressure_0_0 = pipeNetwork__global_0_0[id__computeImposedPressure_0_0].pressure;
 const float flowRate__computeImposedPressure_0_0 = pipeNetwork__global_0_0[id__computeImposedPressure_0_0].flowRate;
 pressureRight__computeImposedPressure_0_0 = interpolate(pressure__computeImposedPressure_0_0, pressureRight__computeImposedPressure_0_0, (ap__computeImposedPressure_0_0*theta__computeImposedPressure_0_0));
 flowRateRight__computeImposedPressure_0_0 = interpolate(flowRate__computeImposedPressure_0_0, flowRateRight__computeImposedPressure_0_0, (ap__computeImposedPressure_0_0*theta__computeImposedPressure_0_0));
 const float Cm__computeImposedPressure_0_0 = pressureRight__computeImposedPressure_0_0 - flowRateRight__computeImposedPressure_0_0*(B__computeImposedPressure_0_0 - E__computeImposedPressure_0_0*absFloat(flowRateRight__computeImposedPressure_0_0));
 const float newPressure__computeImposedPressure_0_0 = mechanicalCalculations__global_0_0[pipeNetwork__global_0_0[id__computeImposedPressure_0_0].mechanicalId].pressure;
 pipeNetwork__global_0_0[id__computeImposedPressure_0_0].newPressure = newPressure__computeImposedPressure_0_0;
 pipeNetwork__global_0_0[id__computeImposedPressure_0_0].newFlowRate = (newPressure__computeImposedPressure_0_0 - Cm__computeImposedPressure_0_0)/B__computeImposedPressure_0_0;
}

void computeImposedFlowRate(const int id__computeImposedFlowRate_0_0, const float p__computeImposedFlowRate_0_0, const float ap__computeImposedFlowRate_0_0) {
 const float theta__computeImposedFlowRate_0_0 = 1.0f;
 const float A__computeImposedFlowRate_0_0 = 1.0f;
 const float E__computeImposedFlowRate_0_0 = p__computeImposedFlowRate_0_0*1.0f;
 const float B__computeImposedFlowRate_0_0 = ap__computeImposedFlowRate_0_0/A__computeImposedFlowRate_0_0;
 const float A2__computeImposedFlowRate_0_0 = 1.0f;
 const float A3__computeImposedFlowRate_0_0 = 1.0f;
 float pressureRight__computeImposedFlowRate_0_0;
 float flowRateRight__computeImposedFlowRate_0_0;
 const int rightId__computeImposedFlowRate_0_0 = pipeNetwork__global_0_0[id__computeImposedFlowRate_0_0].rightId;
 if (rightId__computeImposedFlowRate_0_0 != -1) {
  pressureRight__computeImposedFlowRate_0_0 = pipeNetwork__global_0_0[rightId__computeImposedFlowRate_0_0].pressure;
  flowRateRight__computeImposedFlowRate_0_0 = pipeNetwork__global_0_0[rightId__computeImposedFlowRate_0_0].flowRate;
 } else {
  // ifElse4
  pressureRight__computeImposedFlowRate_0_0 = 0.0f;
  flowRateRight__computeImposedFlowRate_0_0 = 0.0f;
 }
 const float pressure__computeImposedFlowRate_0_0 = pipeNetwork__global_0_0[id__computeImposedFlowRate_0_0].pressure;
 const float flowRate__computeImposedFlowRate_0_0 = pipeNetwork__global_0_0[id__computeImposedFlowRate_0_0].flowRate;
 pressureRight__computeImposedFlowRate_0_0 = interpolate(pressure__computeImposedFlowRate_0_0, pressureRight__computeImposedFlowRate_0_0, (ap__computeImposedFlowRate_0_0*theta__computeImposedFlowRate_0_0));
 flowRateRight__computeImposedFlowRate_0_0 = interpolate(flowRate__computeImposedFlowRate_0_0, flowRateRight__computeImposedFlowRate_0_0, (ap__computeImposedFlowRate_0_0*theta__computeImposedFlowRate_0_0));
 const float Cm__computeImposedFlowRate_0_0 = pressureRight__computeImposedFlowRate_0_0 - flowRateRight__computeImposedFlowRate_0_0*(B__computeImposedFlowRate_0_0 - E__computeImposedFlowRate_0_0*absFloat(flowRateRight__computeImposedFlowRate_0_0));
 const float newFlowRate__computeImposedFlowRate_0_0 = mechanicalCalculations__global_0_0[pipeNetwork__global_0_0[id__computeImposedFlowRate_0_0].mechanicalId].flowRate;
 pipeNetwork__global_0_0[id__computeImposedFlowRate_0_0].newPressure = Cm__computeImposedFlowRate_0_0 - (B__computeImposedFlowRate_0_0*newFlowRate__computeImposedFlowRate_0_0);
 pipeNetwork__global_0_0[id__computeImposedFlowRate_0_0].newFlowRate = newFlowRate__computeImposedFlowRate_0_0;
}

void computePipeT(const int id__computePipeT_0_0, const float p__computePipeT_0_0, const float ap__computePipeT_0_0) {
 const float theta__computePipeT_0_0 = 1.0f;
 const float A__computePipeT_0_0 = 1.0f;
 const float E__computePipeT_0_0 = p__computePipeT_0_0*1.0f;
 const float B__computePipeT_0_0 = ap__computePipeT_0_0/A__computePipeT_0_0;
 const float A2__computePipeT_0_0 = 1.0f;
 const float A3__computePipeT_0_0 = 1.0f;
 float pressureLeft__computePipeT_0_0;
 float flowRateLeft__computePipeT_0_0;
 const int leftId__computePipeT_0_0 = pipeNetwork__global_0_0[id__computePipeT_0_0].leftId;
 if (leftId__computePipeT_0_0 != -1) {
  pressureLeft__computePipeT_0_0 = pipeNetwork__global_0_0[leftId__computePipeT_0_0].pressure;
  flowRateLeft__computePipeT_0_0 = pipeNetwork__global_0_0[leftId__computePipeT_0_0].flowRate;
 } else {
  // ifElse5
  pressureLeft__computePipeT_0_0 = 0.0f;
  flowRateLeft__computePipeT_0_0 = 0.0f;
 }
 float pressureRight__computePipeT_0_0;
 float flowRateRight__computePipeT_0_0;
 const int rightId__computePipeT_0_0 = pipeNetwork__global_0_0[id__computePipeT_0_0].rightId;
 if (rightId__computePipeT_0_0 != -1) {
  pressureRight__computePipeT_0_0 = pipeNetwork__global_0_0[rightId__computePipeT_0_0].pressure;
  flowRateRight__computePipeT_0_0 = pipeNetwork__global_0_0[rightId__computePipeT_0_0].flowRate;
 } else {
  // ifElse6
  pressureRight__computePipeT_0_0 = 0.0f;
  flowRateRight__computePipeT_0_0 = 0.0f;
 }
 float pressureTop__computePipeT_0_0;
 float flowRateTop__computePipeT_0_0;
 const int topId__computePipeT_0_0 = pipeNetwork__global_0_0[id__computePipeT_0_0].topId;
 if (topId__computePipeT_0_0 != -1) {
  pressureTop__computePipeT_0_0 = pipeNetwork__global_0_0[topId__computePipeT_0_0].pressure;
  flowRateTop__computePipeT_0_0 = pipeNetwork__global_0_0[topId__computePipeT_0_0].pressure;
 } else {
  // ifElse7
  pressureTop__computePipeT_0_0 = 0.0f;
  flowRateTop__computePipeT_0_0 = 0.0f;
 }
 const float pressure__computePipeT_0_0 = pipeNetwork__global_0_0[id__computePipeT_0_0].pressure;
 const float flowRate__computePipeT_0_0 = pipeNetwork__global_0_0[id__computePipeT_0_0].flowRate;
 pressureLeft__computePipeT_0_0 = interpolate(pressure__computePipeT_0_0, pressureLeft__computePipeT_0_0, (ap__computePipeT_0_0*theta__computePipeT_0_0));
 flowRateLeft__computePipeT_0_0 = interpolate(flowRate__computePipeT_0_0, flowRateLeft__computePipeT_0_0, (ap__computePipeT_0_0*theta__computePipeT_0_0));
 pressureRight__computePipeT_0_0 = interpolate(pressure__computePipeT_0_0, pressureRight__computePipeT_0_0, (ap__computePipeT_0_0*theta__computePipeT_0_0));
 flowRateRight__computePipeT_0_0 = interpolate(flowRate__computePipeT_0_0, flowRateRight__computePipeT_0_0, (ap__computePipeT_0_0*theta__computePipeT_0_0));
 pressureTop__computePipeT_0_0 = interpolate(pressure__computePipeT_0_0, pressureTop__computePipeT_0_0, (ap__computePipeT_0_0*theta__computePipeT_0_0));
 flowRateTop__computePipeT_0_0 = interpolate(flowRate__computePipeT_0_0, flowRateTop__computePipeT_0_0, (ap__computePipeT_0_0*theta__computePipeT_0_0));
 const float B2__computePipeT_0_0 = ap__computePipeT_0_0/A2__computePipeT_0_0;
 const float B3__computePipeT_0_0 = ap__computePipeT_0_0/A3__computePipeT_0_0;
 const float Cp1__computePipeT_0_0 = pressureLeft__computePipeT_0_0 + flowRateLeft__computePipeT_0_0*(B__computePipeT_0_0 - E__computePipeT_0_0*absFloat(flowRateLeft__computePipeT_0_0));
 const float Cm2__computePipeT_0_0 = pressureRight__computePipeT_0_0 - flowRateRight__computePipeT_0_0*(B2__computePipeT_0_0 - E__computePipeT_0_0*absFloat(flowRateRight__computePipeT_0_0));
 const float Cm3__computePipeT_0_0 = pressureTop__computePipeT_0_0 - flowRateTop__computePipeT_0_0*(B3__computePipeT_0_0 - E__computePipeT_0_0*absFloat(flowRateTop__computePipeT_0_0));
 const float newPressure__computePipeT_0_0 = (Cp1__computePipeT_0_0/B__computePipeT_0_0 + Cm2__computePipeT_0_0/B2__computePipeT_0_0 + Cm3__computePipeT_0_0/B3__computePipeT_0_0)/(1/B__computePipeT_0_0 + 1/B2__computePipeT_0_0 + 1/B3__computePipeT_0_0);
 pipeNetwork__global_0_0[id__computePipeT_0_0].newPressure = newPressure__computePipeT_0_0;
 pipeNetwork__global_0_0[id__computePipeT_0_0].newFlowRateLeft = -newPressure__computePipeT_0_0/B__computePipeT_0_0 + Cp1__computePipeT_0_0/B__computePipeT_0_0;
 pipeNetwork__global_0_0[id__computePipeT_0_0].newFlowRateRight = -newPressure__computePipeT_0_0/B2__computePipeT_0_0 + Cm2__computePipeT_0_0/B2__computePipeT_0_0;
 pipeNetwork__global_0_0[id__computePipeT_0_0].newFlowRateTop = -newPressure__computePipeT_0_0/B3__computePipeT_0_0 + Cm3__computePipeT_0_0/B3__computePipeT_0_0;
}

void computeValve(const int id__computeValve_0_0, const float p__computeValve_0_0, const float ap__computeValve_0_0) {
 const float theta__computeValve_0_0 = 1.0f;
 const float A__computeValve_0_0 = 1.0f;
 const float E__computeValve_0_0 = p__computeValve_0_0*1.0f;
 const float B__computeValve_0_0 = ap__computeValve_0_0/A__computeValve_0_0;
 const float A2__computeValve_0_0 = 1.0f;
 const float A3__computeValve_0_0 = 1.0f;
 float pressureLeft__computeValve_0_0;
 float flowRateLeft__computeValve_0_0;
 const int leftId__computeValve_0_0 = pipeNetwork__global_0_0[id__computeValve_0_0].leftId;
 if (leftId__computeValve_0_0 != -1) {
  pressureLeft__computeValve_0_0 = pipeNetwork__global_0_0[leftId__computeValve_0_0].pressure;
  flowRateLeft__computeValve_0_0 = pipeNetwork__global_0_0[leftId__computeValve_0_0].flowRate;
 } else {
  // ifElse8
  pressureLeft__computeValve_0_0 = 0.0f;
  flowRateLeft__computeValve_0_0 = 0.0f;
 }
 const float pressure__computeValve_0_0 = pipeNetwork__global_0_0[id__computeValve_0_0].pressure;
 const float flowRate__computeValve_0_0 = pipeNetwork__global_0_0[id__computeValve_0_0].flowRate;
 pressureLeft__computeValve_0_0 = interpolate(pressure__computeValve_0_0, pressureLeft__computeValve_0_0, (ap__computeValve_0_0*theta__computeValve_0_0));
 flowRateLeft__computeValve_0_0 = interpolate(flowRate__computeValve_0_0, flowRateLeft__computeValve_0_0, (ap__computeValve_0_0*theta__computeValve_0_0));
 ;
 const float Cp__computeValve_0_0 = pressureLeft__computeValve_0_0 + flowRateLeft__computeValve_0_0*(B__computeValve_0_0 - E__computeValve_0_0*absFloat(flowRateLeft__computeValve_0_0));
 const float tau__computeValve_0_0 = mechanicalCalculations__global_0_0[pipeNetwork__global_0_0[id__computeValve_0_0].mechanicalId].valvePosition;
 const float Cvp__computeValve_0_0 = 1.0f;
 const float Cv__computeValve_0_0 = (tau__computeValve_0_0*tau__computeValve_0_0)*Cvp__computeValve_0_0;
 const float newFlowRate__computeValve_0_0 = -B__computeValve_0_0*Cv__computeValve_0_0 + sqrtf((B__computeValve_0_0*Cv__computeValve_0_0)*(B__computeValve_0_0*Cv__computeValve_0_0) + 2*Cv__computeValve_0_0*Cp__computeValve_0_0);
 pipeNetwork__global_0_0[id__computeValve_0_0].newFlowRate = newFlowRate__computeValve_0_0;
 pipeNetwork__global_0_0[id__computeValve_0_0].newPressure = Cp__computeValve_0_0 - B__computeValve_0_0*newFlowRate__computeValve_0_0;
}

const float interpolate(const float center__interpolate_0_0, const float edge__interpolate_0_0, const float slope__interpolate_0_0) {
 return center__interpolate_0_0 - slope__interpolate_0_0*(center__interpolate_0_0 - edge__interpolate_0_0);
}

const float absFloat(const float number__absFloat_0_0) {
 float result__absFloat_0_0;
 if (number__absFloat_0_0 > 0.0f) {
  result__absFloat_0_0 = number__absFloat_0_0;
 } else {
  // ifElse9
  result__absFloat_0_0 = -number__absFloat_0_0;
 }
 return result__absFloat_0_0;
}

void computeMechanicalPressureSensorCalculations(const int id__computeMechanicalPressureSensorCalculations_0_0) {
 mechanicalCalculations__global_0_0[id__computeMechanicalPressureSensorCalculations_0_0].newPressure = 1470900.0f;
}

void computeMechanicalPumpCalculations(const int id__computeMechanicalPumpCalculations_0_0) {
 mechanicalCalculations__global_0_0[id__computeMechanicalPumpCalculations_0_0].newFlowRate = 100.0f;
}

void computeMechanicalValveCalculations(const int id__computeMechanicalValveCalculations_0_0) {
 const int numberOfValvePositions__computeMechanicalValveCalculations_0_0 = 27;
 const float valvePositions__computeMechanicalValveCalculations_0_0[27] = {1.000000f, 0.929429f, 0.860600f, 0.793560f, 0.728357f, 0.665045f, 0.603682f, 0.544331f, 0.487064f, 0.431959f, 0.379106f, 0.328603f, 0.280566f, 0.235129f, 0.192450f, 0.152721f, 0.116179f, 0.083131f, 0.053995f, 0.029391f, 0.010391f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f};
 mechanicalCalculations__global_0_0[id__computeMechanicalValveCalculations_0_0].newValvePosition = valvePositions__computeMechanicalValveCalculations_0_0[valveIndex__global_0_0%numberOfValvePositions__computeMechanicalValveCalculations_0_0];
}

void computeGlobalCalculations(void) {
 fluidProperties__global_0_0.newP = 1000.0f;
 fluidProperties__global_0_0.newAp = 1.2E+6;
}

void applyComputationElementNonPipeT(const int id__applyComputationElementNonPipeT_0_0) {
 pipeNetwork__global_0_0[id__applyComputationElementNonPipeT_0_0].pressure = pipeNetwork__global_0_0[id__applyComputationElementNonPipeT_0_0].newPressure;
 pipeNetwork__global_0_0[id__applyComputationElementNonPipeT_0_0].flowRate = pipeNetwork__global_0_0[id__applyComputationElementNonPipeT_0_0].newFlowRate;
}

void applyComputationElementPipeT(const int id__applyComputationElementPipeT_0_0) {
 pipeNetwork__global_0_0[id__applyComputationElementPipeT_0_0].pressure = pipeNetwork__global_0_0[id__applyComputationElementPipeT_0_0].newPressure;
 pipeNetwork__global_0_0[id__applyComputationElementPipeT_0_0].flowRateLeft = pipeNetwork__global_0_0[id__applyComputationElementPipeT_0_0].newFlowRateLeft;
 pipeNetwork__global_0_0[id__applyComputationElementPipeT_0_0].flowRateRight = pipeNetwork__global_0_0[id__applyComputationElementPipeT_0_0].newFlowRateRight;
 pipeNetwork__global_0_0[id__applyComputationElementPipeT_0_0].flowRateTop = pipeNetwork__global_0_0[id__applyComputationElementPipeT_0_0].newFlowRateTop;
}

void applyMechanicalCalculations(const int id__applyMechanicalCalculations_0_0) {
 mechanicalCalculations__global_0_0[id__applyMechanicalCalculations_0_0].pressure = mechanicalCalculations__global_0_0[id__applyMechanicalCalculations_0_0].newPressure;
 mechanicalCalculations__global_0_0[id__applyMechanicalCalculations_0_0].flowRate = mechanicalCalculations__global_0_0[id__applyMechanicalCalculations_0_0].newFlowRate;
 mechanicalCalculations__global_0_0[id__applyMechanicalCalculations_0_0].valvePosition = mechanicalCalculations__global_0_0[id__applyMechanicalCalculations_0_0].newValvePosition;
}

void applyGlobalCalculations(void) {
 fluidProperties__global_0_0.p = fluidProperties__global_0_0.newP;
 fluidProperties__global_0_0.ap = fluidProperties__global_0_0.newAp;
}
