# 1 "Mandelbrot.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "Mandelbrot.c"
/*==============================================================

| Hardware architecture specific declarations:

| Cores, mutex and input/output information.

*=============================================================*/
# 5 "Mandelbrot.c"
// Xilinx Microblaze
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Driver parameters

*

*******************************************************************/
# 18 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver MPMC */


/* Definitions for peripheral DDR_SDRAM */
# 42 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/


/* Definitions for peripheral DDR_SDRAM */
# 82 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral DDR_SDRAM */
# 105 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver GPIO */


/* Definitions for peripheral AUDIO */







/* Definitions for peripheral DIP_SWITCHES_8BIT */







/* Definitions for peripheral LEDS_4BIT */







/* Definitions for peripheral LEDS_POSITIONS */







/* Definitions for peripheral PUSH_BUTTONS_POSITION */







/******************************************************************/


/* Definitions for peripheral SRAM */



/******************************************************************/

/* Definitions for peripheral SRAM */



/******************************************************************/

/* Canonical definitions for peripheral SRAM */






/******************************************************************/


/* Definitions for peripheral DLMB_CNTLR_0 */




/* Definitions for peripheral ILMB_CNTLR_0 */




/* Definitions for peripheral MB_PLB_BRAM_CNTLR */




/******************************************************************/

/* Definitions for driver UARTLITE */


/* Definitions for peripheral MDM_0 */
# 205 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral MDM_0 */
# 218 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for bus frequencies */


/******************************************************************/

/* Canonical definitions for bus frequencies */

/******************************************************************/




/******************************************************************/


/* Definitions for peripheral MICROBLAZE_0 */
# 433 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 635 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 7 "Mandelbrot.c" 2

// Xilinx Microblaze Processor Version Register
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2006 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE.
//
// $Id: pvr.h,v 1.1.2.1 2009/09/24 23:37:37 haibing Exp $
////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************/
/**
*
* @file pvr.h
*
* This header file contains defines for structures used by the microblaze 
* PVR routines
*
******************************************************************************/




# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 60 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/***************************** Include Files *********************************/


/************************** Constant Definitions *****************************/
# 77 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/** Xilinx NULL, TRUE and FALSE legacy support. Deprecated. */
# 86 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/* the following constants and declarations are for unit test purposes and are
 * designed to be used in test applications.
 */






extern unsigned int XAssertStatus;
extern void XAssert(char *, int);

/**************************** Type Definitions *******************************/

/** @name Legacy types
 * Deprecated legacy types.
 * @{
 */
typedef unsigned char Xuint8; /**< unsigned 8-bit */
typedef char Xint8; /**< signed 8-bit */
typedef unsigned short Xuint16; /**< unsigned 16-bit */
typedef short Xint16; /**< signed 16-bit */
typedef unsigned long Xuint32; /**< unsigned 32-bit */
typedef long Xint32; /**< signed 32-bit */
typedef float Xfloat32; /**< 32-bit floating point */
typedef double Xfloat64; /**< 64-bit double precision FP */
typedef unsigned long Xboolean; /**< boolean (XTRUE or XFALSE) */

typedef struct
{
 Xuint32 Upper;
 Xuint32 Lower;
} Xuint64;

/** @name New types
 * New simple types.
 * @{
 */


typedef Xuint32 u32;
typedef Xuint16 u16;
typedef Xuint8 u8;





/*@}*/

/**
 * This data type defines an interrupt handler for a device.
 * The argument points to the instance of the component
 */
typedef void (*XInterruptHandler) (void *InstancePtr);

/**
 * This data type defines an exception handler for a processor.
 * The argument points to the instance of the component
 */
typedef void (*XExceptionHandler) (void *InstancePtr);

/**
 * This data type defines a callback to be invoked when an
 * assert occurs. The callback is invoked only when asserts are enabled
 */
typedef void (*XAssertCallback) (char *FilenamePtr, int LineNumber);

/***************** Macros (Inline Functions) Definitions *********************/

/*****************************************************************************/
/**
* Return the most significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The upper 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/


/*****************************************************************************/
/**
* Return the least significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The lower 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/





/*****************************************************************************/
/**
* This assert macro is to be used for functions that do not return anything
* (void). This in conjunction with the XWaitInAssert boolean can be used to
* accomodate tests so that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to
*           false, the assert occurs.
*
* @return   Returns void unless the XWaitInAssert variable is true, in which
*           case no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 214 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/*****************************************************************************/
/**
* This assert macro is to be used for functions that do return a value. This in
* conjunction with the XWaitInAssert boolean can be used to accomodate tests so
* that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to false,
*           the assert occurs.
*
* @return   Returns 0 unless the XWaitInAssert variable is true, in which case
*           no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 243 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do not
* return anything (void). Use for instances where an assert should always
* occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/







/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do return
* a value. Use for instances where an assert should always occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/
# 289 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/************************** Function Prototypes ******************************/

void XAssertSetCallback(XAssertCallback Routine);
void XNullHandler(void *NullParameter);
# 34 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Driver parameters

*

*******************************************************************/
# 18 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver MPMC */


/* Definitions for peripheral DDR_SDRAM */
# 42 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/


/* Definitions for peripheral DDR_SDRAM */
# 82 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral DDR_SDRAM */
# 105 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver GPIO */


/* Definitions for peripheral AUDIO */







/* Definitions for peripheral DIP_SWITCHES_8BIT */







/* Definitions for peripheral LEDS_4BIT */







/* Definitions for peripheral LEDS_POSITIONS */







/* Definitions for peripheral PUSH_BUTTONS_POSITION */







/******************************************************************/


/* Definitions for peripheral SRAM */



/******************************************************************/

/* Definitions for peripheral SRAM */



/******************************************************************/

/* Canonical definitions for peripheral SRAM */






/******************************************************************/


/* Definitions for peripheral DLMB_CNTLR_0 */




/* Definitions for peripheral ILMB_CNTLR_0 */




/* Definitions for peripheral MB_PLB_BRAM_CNTLR */




/******************************************************************/

/* Definitions for driver UARTLITE */


/* Definitions for peripheral MDM_0 */
# 205 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral MDM_0 */
# 218 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for bus frequencies */


/******************************************************************/

/* Canonical definitions for bus frequencies */

/******************************************************************/




/******************************************************************/


/* Definitions for peripheral MICROBLAZE_0 */
# 433 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 635 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 35 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE. 
// 
// File   : mb_interface.h
// Date   : 2002, March 20.
// Company: Xilinx
// Group  : Emerging Software Technologies
//
// Summary:
// Header file for mb_interface
//
// $Id: mb_interface.h,v 1.1.2.1 2009/09/24 23:37:36 haibing Exp $
//
////////////////////////////////////////////////////////////////////////////////




# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 33 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 2





extern void microblaze_enable_interrupts(void); /* Enable Interrupts */
extern void microblaze_disable_interrupts(void); /* Disable Interrupts */
extern void microblaze_enable_icache(void); /* Enable Instruction Cache */
extern void microblaze_disable_icache(void); /* Disable Instruction Cache */
extern void microblaze_enable_dcache(void); /* Enable Instruction Cache */
extern void microblaze_disable_dcache(void); /* Disable Instruction Cache */
extern void microblaze_enable_exceptions(void); /* Enable hardware exceptions */
extern void microblaze_disable_exceptions(void); /* Disable hardware exceptions */
extern void microblaze_register_handler(XInterruptHandler Handler, void *DataPtr); /* Register top level interrupt handler */
extern void microblaze_register_exception_handler(Xuint8 ExceptionId, XExceptionHandler Handler, void *DataPtr); /* Register exception handler */

extern void microblaze_invalidate_icache(); /* Invalidate the entire icache */
extern void microblaze_invalidate_dcache(); /* Invalidate the entire dcache */
extern void microblaze_flush_dcache(); /* Flush the whole dcache */
extern void microblaze_invalidate_icache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the icache */
extern void microblaze_invalidate_dcache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the dcache */
extern void microblaze_flush_dcache_range(unsigned int cacheaddr, unsigned int len); /* Flush a part of the dcache */

/* Deprecated */
extern void microblaze_update_icache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_icache_range (int , int ) __attribute__((deprecated));
extern void microblaze_update_dcache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_dcache_range (int , int ) __attribute__((deprecated));

/* necessary for pre-processor */



/* FSL Access Macros */

/* Blocking Data Read and Write to FSL no. id */



/* Non-blocking Data Read and Write to FSL no. id */



/* Blocking Control Read and Write to FSL no. id */



/* Non-blocking Control Read and Write to FSL no. id */



/* Polling versions of FSL access macros. This makes the FSL access interruptible */
# 104 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h"
/* FSL valid and error check macros. */




/* Pseudo assembler instructions */
# 257 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h"
/* Deprecated MicroBlaze FSL macros */
# 36 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/bspconfig.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Configurations for Standalone BSP

*

*******************************************************************/
# 37 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2






/* Defs */
typedef struct pvr_s {



  unsigned int pvr[1];

} pvr_t;




/* Basic PVR mask */
# 67 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h"
/* User 2 PVR mask */


/* Configuration PVR masks */
# 96 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h"
/* Debug and exception PVR masks */






/* ICache config PVR masks */







/* DCache config PVR masks */







/* ICache base address PVR mask */


/* ICache high address PVR mask */


/* DCache base address PVR mask */


/* DCache high address PVR mask */


/* Target family PVR mask */


/* MSR Reset value PVR mask */


/* MMU value PVR mask */



/* PVR access macros */
# 206 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h"
/* Protos */
int microblaze_get_pvr (pvr_t *pvr);
# 10 "Mandelbrot.c" 2

// Hardware counter connected via a direct FSL bus.
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 1
/*****************************************************************************

* Filename:          C:\Xilinx\12.1\MyProcessorIPLib\drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h

* Version:           1.00.a

* Description:       counter_dfsl (Counter DFSL) Driver Header File

* Date:              Fri Jul 02 14:27:25 2010 (by Create and Import Peripheral Wizard)

*****************************************************************************/
# 11 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 1



# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 5 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE. 
// 
// File   : mb_interface.h
// Date   : 2002, March 20.
// Company: Xilinx
// Group  : Emerging Software Technologies
//
// Summary:
// Header file for mb_interface
//
// $Id: mb_interface.h,v 1.1.2.1 2009/09/24 23:37:36 haibing Exp $
//
////////////////////////////////////////////////////////////////////////////////
# 6 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 2





/* Extended FSL macros. These now replace all of the previous FSL macros */
# 12 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 2


typedef struct {
 int current; // Current counter value measured.
 int last; // Last value of the counter.
 int difference; // Difference between the current and last values.
 int min; // Minimum counter value.
 int avg; // Average counter value.
 int max; // Maximum counter value.
 long int total; // Cumulative value of all differences.
 int iterations; // Number of times values are added to the total.
} Counter;


// Initialise the current and last counter values.
# 40 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
// Start the counter with the specified value.




// Stop the counter and read the current value.



// Read the current counter value.
// Subtract 3 cycles for put and addk instruction.




// Calculate the difference between the current and last
// counter values.



// Accumulate the counter difference.




// Calculate the average differences.



// Update the maximum counter difference.





// Update the minimum counter difference.
# 13 "Mandelbrot.c" 2
Counter counter;

// ForeC hardware mutex
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/forec_mutex_v1_00_a/src/forec_mutex.h" 1
/*****************************************************************************

* Filename:          C:\Xilinx\12.1\MyProcessorIPLib\drivers/forec_mutex_v1_00_a/src/forec_mutex.h

* Version:           1.00.a

* Description:       forec_mutex (ForeC Mutex) Driver Header File

* Date:              Fri Jul 02 14:27:25 2010 (by Create and Import Peripheral Wizard)

*****************************************************************************/
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 1
# 13 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/forec_mutex_v1_00_a/src/forec_mutex.h" 2


// Set the bit at the given position in the bit array.



// Resets all bits to 1. Only works on core0.



// Clear the bit at the given position in the bit array.



// Read the entire bit array.
# 17 "Mandelbrot.c" 2






/*==============================================================

| ForeC type definitions:

| Defines the types of storage elements specific to ForeC.

*=============================================================*/
# 27 "Mandelbrot.c"
// Status values.
typedef enum {
 // PAR
 FOREC_PAR_OFF, // 0
 FOREC_PAR_ON, // 1

 // Core
 FOREC_CORE_REACTING, // 2
 FOREC_CORE_REACTED, // 3
 FOREC_CORE_TERMINATED, // 4

 // Shared variables
 FOREC_SHARED_UNMODIFIED, // 5
 FOREC_SHARED_MODIFIED, // 6
 FOREC_SHARED_WAS_MODIFIED // 7
} Status;

// Store child thread information.
typedef struct _Thread {
 void *programCounter;
 struct _Thread *nextThread;
 struct _Thread *prevThread;
} Thread;

// Store parent thread information
typedef struct {
 void *programCounter;
 unsigned short int parStatus;
 short int parId;
} Parent;

// Keep track of child threads executing on
// a processor core.
typedef struct {
 unsigned short int sync;
 unsigned short int activeThreads;
 unsigned short int status;
 int reactionCounter;
} Core;

// Global variable for counting the number of global reactions.
volatile long int globalReactions = 0;

// Shared control variables for par(...)s -------------------------
// Thread main with par(...)s
volatile Parent mainParParent;
volatile Core mainParCore0;
volatile Core mainParCore1;
volatile Core mainParCore2;
volatile Core mainParCore3;
volatile int mainParReactionCounter;


/*==============================================================

| Original global declarations:

| Global declarations in the original program code.

*=============================================================*/
# 84 "Mandelbrot.c"
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/float.h" 1 3 4
/* Copyright (C) 2002 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */

/*
 * ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>
 */




/* Radix of exponent representation, b. */



/* Number of base-FLT_RADIX digits in the significand, p.  */







/* Number of decimal digits, q, such that any floating-point number with q
   decimal digits can be rounded into a floating-point number with p radix b
   digits and back again without change to the q decimal digits,

	p * log10(b)			if b is a power of 10
	floor((p - 1) * log10(b))	otherwise
*/







/* Minimum int x such that FLT_RADIX**(x-1) is a normalized float, emin */







/* Minimum negative integer such that 10 raised to that power is in the
   range of normalized floating-point numbers,

	ceil(log10(b) * (emin - 1))
*/







/* Maximum int x such that FLT_RADIX**(x-1) is a representable float, emax.  */







/* Maximum integer such that 10 raised to that power is in the range of
   representable finite floating-point numbers,

	floor(log10((1 - b**-p) * b**emax))
*/







/* Maximum representable finite floating-point number,

	(1 - b**-p) * b**emax
*/







/* The difference between 1 and the least value greater than 1 that is
   representable in the given floating point type, b**1-p.  */







/* Minimum normalized positive floating-point number, b**(emin - 1).  */







/* Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown.  */
/* ??? This is supposed to change with calls to fesetround in <fenv.h>.  */
# 85 "Mandelbrot.c" 2

int FLT_MAX__global_0_0;



int FLT_MIN__global_0_0;



int FLT_EPSILON__global_0_0;



const int ColormapSize__global_0_0 = 128;
const int problemSize__global_0_0 = 10;
const float centerX__global_0_0 = -0.637011f;
const float centerY__global_0_0 = -0.0395159f;
const float pixmapScale__global_0_0 = 0.00403897f;
const int resultWidth__global_0_0 = 220;
const int resultHeight__global_0_0 = 160;

typedef struct {
 unsigned char r;
 unsigned char g;
 unsigned char b;
} Pixel__global_0_0;

unsigned colormap__global_0_0[128];
Pixel__global_0_0 image__global_0_0[160][220];

void compute(int threadId);
void init(int threadId);
void calculate(int x, int y);
unsigned rgbFromWaveLength(float wave);
Pixel__global_0_0 uintToRgb(unsigned rgb);
float fs_pow(float x, float y);
float fs_fmod(float x, float y);
float fs_exp(float x);
float fs_log(float x);
float fs_sqrt(float x);

// thread region0__thread(void);
// thread region1__thread(void);
// thread region2__thread(void);
// thread region3__thread(void);
// thread region4__thread(void);
// thread region5__thread(void);
// thread region6__thread(void);
// thread region7__thread(void);

// Locally declared shared variables -------------------------------

// Global versions of local copies of shared variables -------------
// main
// region0
// region1
// region2
// region3
// region4
// region5
// region6
// region7

// forec:scheduler:boot:start
int main(int argc__main_0_0, char ** argv__main_0_0) {

/*==============================================================

| Multicore startup:

| Platform dependent code.  Core identifies itself and

| executes its corresponding start up code.

*=============================================================*/
# 156 "Mandelbrot.c"
 // Initialise ForeC specific values ----------------------------
 // Thread main with par(...)s
 mainParParent.parStatus = FOREC_PAR_OFF;
 mainParCore0.sync = 1;
 mainParCore0.status = FOREC_CORE_REACTING;
 mainParCore1.sync = 1;
 mainParCore1.status = FOREC_CORE_REACTING;
 mainParCore2.sync = 1;
 mainParCore2.status = FOREC_CORE_REACTING;
 mainParCore3.sync = 1;
 mainParCore3.status = FOREC_CORE_REACTING;
 mainParReactionCounter = 0;


 // ForeC mutex -------------------------------------------------
 unsigned int forec_mutex_value;
 asm volatile ("put\t%0,rfsl" "1" :: "d" (0));

 // Variables for par()s ----------------------------------------
 // par0
 Thread region0__thread;
 Thread region1__thread;
 Thread region2__thread;
 Thread region3__thread;
 Thread region4__thread;
 Thread region5__thread;
 Thread region6__thread;
 Thread region7__thread;
 Thread mainReactionStartMaster0;
 Thread mainReactionStartSlave1;
 Thread mainReactionStartSlave2;
 Thread mainReactionStartSlave3;
 Thread mainReactionEndMaster0;
 Thread mainReactionEndSlave1;
 Thread mainReactionEndSlave2;
 Thread mainReactionEndSlave3;


 // Synchronise execution of cores ------------------------------
 // pvr = Processor Version Register
 unsigned int pvr0;
 asm volatile ("mfs\t%0,rpvr" "0" "\n\t" : "=d" (pvr0));
 pvr0 &= 0x000000FF;

 switch (pvr0) {
  case (0):
   while(mainParCore1.sync);
   while(mainParCore2.sync);
   while(mainParCore3.sync);
   goto mainParCore0;

  case (1):
   mainParCore1.sync = 0;
   goto mainParCore1;

  case (2):
   mainParCore2.sync = 0;
   goto mainParCore2;

  case (3):
   mainParCore3.sync = 0;
   goto mainParCore3;

  default:
   // "Lock-up" unused cores.
   while(1);
 }
// forec:scheduler:boot:end

/*==============================================================

| Core specific instructions:

| Contains par, abort and synchronisation handlers.

*=============================================================*/
# 230 "Mandelbrot.c"
 // forec:thread:main:start
 /*--------------------------------------------------------------

	| Master core: core0

	| ForeC program's main() function:

	| Original main() function code with ForeC constructs

	| translated into C code.

	*-------------------------------------------------------------*/
# 238 "Mandelbrot.c"
 // Thread local declarations -----------------------------------
 // No declarations.
mainParCore0: {
 // forec:scheduler:counter:start
 // Initialise and start counting the elapsed cycles for each reaction.
 counter.current = 0; counter.last = 0; counter.difference = 0; counter.min = 2147483647; counter.avg = 0; counter.max = 0; counter.total = 0; counter.iterations = 0;
 counter.last = counter.current; asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
 // forec:scheduler:counter:end

 // Initialise the local copies of shared variables.
 //--------------------------------------------------------------

 // par0(region0__thread, region1__thread, region2__thread, region3__thread, region4__thread, region5__thread, region6__thread, region7__thread);
 // Set the par(...) information.
 mainParParent.parId = 0;
 mainParParent.parStatus = FOREC_PAR_ON;

 // Link the threads and handlers together.
 mainReactionStartMaster0.programCounter = &&mainReactionStartMaster0;
 region0__thread.programCounter = &&region0__thread;
 mainReactionStartMaster0.nextThread = &region0__thread;
 region0__thread.prevThread = &mainReactionStartMaster0;
 region1__thread.programCounter = &&region1__thread;
 region0__thread.nextThread = &region1__thread;
 region1__thread.prevThread = &region0__thread;
 mainReactionEndMaster0.programCounter = &&mainReactionEndMaster0;
 region1__thread.nextThread = &mainReactionEndMaster0;
 mainReactionEndMaster0.prevThread = &region1__thread;

 // Link the last and first threads/handlers together.
 mainReactionEndMaster0.nextThread = &mainReactionStartMaster0;
 mainReactionStartMaster0.prevThread = &mainReactionEndMaster0;

 // Set the join address.
 mainParParent.programCounter = &&par0JoinAddress_mainParCore0;

 // Set the core information.
 mainParCore0.activeThreads = 2;
 mainParCore0.reactionCounter = mainParReactionCounter;

 // Go to the first thread.
 // forec:statement:par:par0:start
 goto region0__thread;
 par0JoinAddress_mainParCore0:;
 // forec:statement:par:par0:end

 //--------------------------------------------------------------
 // Write the defined shared variables back to their global copy.

 // forec:scheduler:threadRemove:main:start

 // forec:scheduler:counter:start
 // Stop counting the elapsed cycles for the current reaction.
 asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
 asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
 counter.difference = counter.current - counter.last;
 if (counter.max < counter.difference) { counter.max = counter.difference; };
 if (counter.min > counter.difference) { counter.min = counter.difference; };
 counter.total += counter.difference; counter.iterations++;
 counter.avg = counter.total/counter.iterations;
 xil_printf("%ld Reaction time: %d cycles, Min: %d, Avg: %d, Max: %d\r\n", globalReactions, counter.difference, counter.min, counter.avg, counter.max);
 xil_printf("Total time: %d cycles\r\n", counter.total);
 xil_printf("Program termination\r\n");
 // forec:scheduler:counter:end

 asm volatile (".long 0x80000001\r\n");
 return 0;
 // forec:scheduler:threadRemove:main:end
} // mainParCore0
 // forec:thread:main:end

// forec:scheduler:parHandler:main:master:0:start
mainParHandlerMaster0: {
 if (mainParParent.parId == -2) {
  // Iteration
  // Wait for other cores to complete their reaction.
  while(mainParCore1.status == FOREC_CORE_REACTING);
  while(mainParCore2.status == FOREC_CORE_REACTING);
  while(mainParCore3.status == FOREC_CORE_REACTING);

  mainParParent.parStatus = FOREC_PAR_OFF;
  mainParParent.parId = -1;

  // Set slave cores' status to reacting.
  mainParCore1.status = FOREC_CORE_REACTING;
  mainParCore2.status = FOREC_CORE_REACTING;
  mainParCore3.status = FOREC_CORE_REACTING;

  // Increment the reaction counter for synchronisation.
  mainParReactionCounter++;

  // Return to thread main.
  goto *mainParParent.programCounter;
 }

 // Control should not reach here.
 goto mainParHandlerMaster0;
}
// forec:scheduler:parHandler:main:master:0:end


 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:master:0:start
 //-- main:
mainReactionStartMaster0: {
 // Go to the next thread.
 goto *mainReactionStartMaster0.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:master:0:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:master:0:start
 //-- main:
mainReactionEndMaster0: {
 // Determine if the core can still react or not.
 if (mainParCore0.activeThreads) {
  mainParCore0.status = FOREC_CORE_REACTED;
 } else {
  mainParCore0.status = FOREC_CORE_TERMINATED;
 }

 // Wait for other cores to complete their reaction.
 while(mainParCore1.status == FOREC_CORE_REACTING);
 while(mainParCore2.status == FOREC_CORE_REACTING);
 while(mainParCore3.status == FOREC_CORE_REACTING);

 // Reset the mutex.
 asm volatile ("put\t%0,rfsl" "1" :: "d" (0));

 // Return back to the parent thread if all the cores have terminated.
 if (1 && mainParCore0.status == FOREC_CORE_TERMINATED && mainParCore1.status == FOREC_CORE_TERMINATED && mainParCore2.status == FOREC_CORE_TERMINATED && mainParCore3.status == FOREC_CORE_TERMINATED) {
  mainParParent.parStatus = FOREC_PAR_OFF;
  mainParParent.parId = -1;

  // Set slave cores' status to reacting
  mainParCore1.status = FOREC_CORE_REACTING;
  mainParCore2.status = FOREC_CORE_REACTING;
  mainParCore3.status = FOREC_CORE_REACTING;

  // Increment the reaction counter for synchronization.
  mainParReactionCounter++;

  goto *mainParParent.programCounter;
 }

 // Set slave cores' status to reacting
 mainParCore1.status = FOREC_CORE_REACTING;
 mainParCore2.status = FOREC_CORE_REACTING;
 mainParCore3.status = FOREC_CORE_REACTING;

 // forec:scheduler:counter:start
 // Stop counting the elapsed cycles for the current reaction.
 asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
 asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
 counter.difference = counter.current - counter.last;
 if (counter.max < counter.difference) { counter.max = counter.difference; };
 if (counter.min > counter.difference) { counter.min = counter.difference; };
 counter.total += counter.difference; counter.iterations++;
 counter.avg = counter.total/counter.iterations;
 xil_printf("%d Reaction time: %ld cycles, Min: %d, Avg: %d, Max: %d\r\n", globalReactions, counter.difference, counter.min, counter.avg, counter.max);
 // Restart counting of the elapsed cycles for the next reaction.
 counter.current = 0; counter.last = 0;
 counter.last = counter.current; asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
 // forec:scheduler:counter:end

 // Increment the reaction counter for synchronization.
 mainParReactionCounter++;

 // Go to the next thread.
 goto *mainReactionEndMaster0.nextThread -> programCounter;
}
 // forec:scheduler:reactionEnd:main:master:0:end



 // Abort check handlers ----------------------------------------


// forec:scheduler:parHandler:main:slave:1:start
/*--------------------------------------------------------------

| Slave core: core1

*-------------------------------------------------------------*/
# 425 "Mandelbrot.c"
mainParCore1: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 short int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave1.programCounter = &&mainReactionStartSlave1;
  region2__thread.programCounter = &&region2__thread;
  mainReactionStartSlave1.nextThread = &region2__thread;
  region2__thread.prevThread = &mainReactionStartSlave1;
  region3__thread.programCounter = &&region3__thread;
  region2__thread.nextThread = &region3__thread;
  region3__thread.prevThread = &region2__thread;
  mainReactionEndSlave1.programCounter = &&mainReactionEndSlave1;
  region3__thread.nextThread = &mainReactionEndSlave1;
  mainReactionEndSlave1.prevThread = &region3__thread;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave1.nextThread = &mainReactionStartSlave1;
  mainReactionStartSlave1.prevThread = &mainReactionEndSlave1;

  // Set the core information.
  mainParCore1.activeThreads = 2;
  mainParCore1.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto region2__thread;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore1.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore1.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore1.reactionCounter == mainParReactionCounter);
   mainParCore1.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...) 
  goto mainParCore1;
 }

 // Control shouldn't reach here.
 goto mainParCore1;
}
// forec:scheduler:parHandler:main:slave:1:end

 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:1:start
 //-- main:
mainReactionStartSlave1: {
 // Go to the next thread.
 goto *mainReactionStartSlave1.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:1:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:1:start
 //-- main:
mainReactionEndSlave1: {
 // Determine if the core can still react or not.
 if (mainParCore1.activeThreads) {
  mainParCore1.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore1.reactionCounter == mainParReactionCounter);
  mainParCore1.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave1.nextThread -> programCounter;
 } else {
  short int parId = mainParParent.parId;

  mainReactionEndSlave1.programCounter = &&terminated_mainReactionEndSlave1;
  terminated_mainReactionEndSlave1:;

  mainParCore1.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore1.reactionCounter == mainParReactionCounter);
  mainParCore1.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave1.nextThread -> programCounter;
  }

  goto mainParCore1;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave1;
}
 // forec:scheduler:reactionEnd:main:slave:1:end



 // Abort check handlers ----------------------------------------

// forec:scheduler:parHandler:main:slave:2:start
/*--------------------------------------------------------------

| Slave core: core2

*-------------------------------------------------------------*/
# 541 "Mandelbrot.c"
mainParCore2: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 short int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave2.programCounter = &&mainReactionStartSlave2;
  region4__thread.programCounter = &&region4__thread;
  mainReactionStartSlave2.nextThread = &region4__thread;
  region4__thread.prevThread = &mainReactionStartSlave2;
  region5__thread.programCounter = &&region5__thread;
  region4__thread.nextThread = &region5__thread;
  region5__thread.prevThread = &region4__thread;
  mainReactionEndSlave2.programCounter = &&mainReactionEndSlave2;
  region5__thread.nextThread = &mainReactionEndSlave2;
  mainReactionEndSlave2.prevThread = &region5__thread;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave2.nextThread = &mainReactionStartSlave2;
  mainReactionStartSlave2.prevThread = &mainReactionEndSlave2;

  // Set the core information.
  mainParCore2.activeThreads = 2;
  mainParCore2.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto region4__thread;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore2.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore2.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore2.reactionCounter == mainParReactionCounter);
   mainParCore2.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...) 
  goto mainParCore2;
 }

 // Control shouldn't reach here.
 goto mainParCore2;
}
// forec:scheduler:parHandler:main:slave:2:end

 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:2:start
 //-- main:
mainReactionStartSlave2: {
 // Go to the next thread.
 goto *mainReactionStartSlave2.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:2:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:2:start
 //-- main:
mainReactionEndSlave2: {
 // Determine if the core can still react or not.
 if (mainParCore2.activeThreads) {
  mainParCore2.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore2.reactionCounter == mainParReactionCounter);
  mainParCore2.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave2.nextThread -> programCounter;
 } else {
  short int parId = mainParParent.parId;

  mainReactionEndSlave2.programCounter = &&terminated_mainReactionEndSlave2;
  terminated_mainReactionEndSlave2:;

  mainParCore2.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore2.reactionCounter == mainParReactionCounter);
  mainParCore2.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave2.nextThread -> programCounter;
  }

  goto mainParCore2;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave2;
}
 // forec:scheduler:reactionEnd:main:slave:2:end



 // Abort check handlers ----------------------------------------

// forec:scheduler:parHandler:main:slave:3:start
/*--------------------------------------------------------------

| Slave core: core3

*-------------------------------------------------------------*/
# 657 "Mandelbrot.c"
mainParCore3: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 short int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave3.programCounter = &&mainReactionStartSlave3;
  region6__thread.programCounter = &&region6__thread;
  mainReactionStartSlave3.nextThread = &region6__thread;
  region6__thread.prevThread = &mainReactionStartSlave3;
  region7__thread.programCounter = &&region7__thread;
  region6__thread.nextThread = &region7__thread;
  region7__thread.prevThread = &region6__thread;
  mainReactionEndSlave3.programCounter = &&mainReactionEndSlave3;
  region7__thread.nextThread = &mainReactionEndSlave3;
  mainReactionEndSlave3.prevThread = &region7__thread;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave3.nextThread = &mainReactionStartSlave3;
  mainReactionStartSlave3.prevThread = &mainReactionEndSlave3;

  // Set the core information.
  mainParCore3.activeThreads = 2;
  mainParCore3.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto region6__thread;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore3.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore3.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore3.reactionCounter == mainParReactionCounter);
   mainParCore3.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...) 
  goto mainParCore3;
 }

 // Control shouldn't reach here.
 goto mainParCore3;
}
// forec:scheduler:parHandler:main:slave:3:end

 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:3:start
 //-- main:
mainReactionStartSlave3: {
 // Go to the next thread.
 goto *mainReactionStartSlave3.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:3:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:3:start
 //-- main:
mainReactionEndSlave3: {
 // Determine if the core can still react or not.
 if (mainParCore3.activeThreads) {
  mainParCore3.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore3.reactionCounter == mainParReactionCounter);
  mainParCore3.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave3.nextThread -> programCounter;
 } else {
  short int parId = mainParParent.parId;

  mainReactionEndSlave3.programCounter = &&terminated_mainReactionEndSlave3;
  terminated_mainReactionEndSlave3:;

  mainParCore3.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore3.reactionCounter == mainParReactionCounter);
  mainParCore3.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave3.nextThread -> programCounter;
  }

  goto mainParCore3;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave3;
}
 // forec:scheduler:reactionEnd:main:slave:3:end



 // Abort check handlers ----------------------------------------



/*==============================================================

| ForeC threads:

| Threads code translated into C code.

*=============================================================*/
# 775 "Mandelbrot.c"
 // forec:thread:region0:start
 /*--------------------------------------------------------------

	| Thread region0

	*-------------------------------------------------------------*/
# 780 "Mandelbrot.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 region0__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  init(0);

  // pause;
  // forec:statement:pause:pause0:start
  region0__thread.programCounter = &&pause0;
  goto *region0__thread.nextThread -> programCounter;
  pause0:;
  // forec:statement:pause:pause0:end


  compute(0);

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:region0:start

  // Delete thread from the linked list and core.
  mainParCore0.activeThreads--;
  region0__thread.nextThread -> prevThread = region0__thread.prevThread;
  region0__thread.prevThread -> nextThread = region0__thread.nextThread;
  goto *region0__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:region0:end
 } // region0__thread
 // forec:thread:region0:end

 // forec:thread:region1:start
 /*--------------------------------------------------------------

	| Thread region1

	*-------------------------------------------------------------*/
# 819 "Mandelbrot.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 region1__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  init(1);

  // pause;
  // forec:statement:pause:pause1:start
  region1__thread.programCounter = &&pause1;
  goto *region1__thread.nextThread -> programCounter;
  pause1:;
  // forec:statement:pause:pause1:end


  compute(1);

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:region1:start

  // Delete thread from the linked list and core.
  mainParCore0.activeThreads--;
  region1__thread.nextThread -> prevThread = region1__thread.prevThread;
  region1__thread.prevThread -> nextThread = region1__thread.nextThread;
  goto *region1__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:region1:end
 } // region1__thread
 // forec:thread:region1:end

 // forec:thread:region2:start
 /*--------------------------------------------------------------

	| Thread region2

	*-------------------------------------------------------------*/
# 858 "Mandelbrot.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 region2__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  init(2);

  // pause;
  // forec:statement:pause:pause2:start
  region2__thread.programCounter = &&pause2;
  goto *region2__thread.nextThread -> programCounter;
  pause2:;
  // forec:statement:pause:pause2:end


  compute(2);

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:region2:start

  // Delete thread from the linked list and core.
  mainParCore1.activeThreads--;
  region2__thread.nextThread -> prevThread = region2__thread.prevThread;
  region2__thread.prevThread -> nextThread = region2__thread.nextThread;
  goto *region2__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:region2:end
 } // region2__thread
 // forec:thread:region2:end

 // forec:thread:region3:start
 /*--------------------------------------------------------------

	| Thread region3

	*-------------------------------------------------------------*/
# 897 "Mandelbrot.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 region3__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  init(3);

  // pause;
  // forec:statement:pause:pause3:start
  region3__thread.programCounter = &&pause3;
  goto *region3__thread.nextThread -> programCounter;
  pause3:;
  // forec:statement:pause:pause3:end


  compute(3);

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:region3:start

  // Delete thread from the linked list and core.
  mainParCore1.activeThreads--;
  region3__thread.nextThread -> prevThread = region3__thread.prevThread;
  region3__thread.prevThread -> nextThread = region3__thread.nextThread;
  goto *region3__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:region3:end
 } // region3__thread
 // forec:thread:region3:end

 // forec:thread:region4:start
 /*--------------------------------------------------------------

	| Thread region4

	*-------------------------------------------------------------*/
# 936 "Mandelbrot.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 region4__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  init(4);

  // pause;
  // forec:statement:pause:pause4:start
  region4__thread.programCounter = &&pause4;
  goto *region4__thread.nextThread -> programCounter;
  pause4:;
  // forec:statement:pause:pause4:end


  compute(4);

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:region4:start

  // Delete thread from the linked list and core.
  mainParCore2.activeThreads--;
  region4__thread.nextThread -> prevThread = region4__thread.prevThread;
  region4__thread.prevThread -> nextThread = region4__thread.nextThread;
  goto *region4__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:region4:end
 } // region4__thread
 // forec:thread:region4:end

 // forec:thread:region5:start
 /*--------------------------------------------------------------

	| Thread region5

	*-------------------------------------------------------------*/
# 975 "Mandelbrot.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 region5__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  init(5);

  // pause;
  // forec:statement:pause:pause5:start
  region5__thread.programCounter = &&pause5;
  goto *region5__thread.nextThread -> programCounter;
  pause5:;
  // forec:statement:pause:pause5:end


  compute(5);

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:region5:start

  // Delete thread from the linked list and core.
  mainParCore2.activeThreads--;
  region5__thread.nextThread -> prevThread = region5__thread.prevThread;
  region5__thread.prevThread -> nextThread = region5__thread.nextThread;
  goto *region5__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:region5:end
 } // region5__thread
 // forec:thread:region5:end

 // forec:thread:region6:start
 /*--------------------------------------------------------------

	| Thread region6

	*-------------------------------------------------------------*/
# 1014 "Mandelbrot.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 region6__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  init(6);

  // pause;
  // forec:statement:pause:pause6:start
  region6__thread.programCounter = &&pause6;
  goto *region6__thread.nextThread -> programCounter;
  pause6:;
  // forec:statement:pause:pause6:end


  compute(6);

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:region6:start

  // Delete thread from the linked list and core.
  mainParCore3.activeThreads--;
  region6__thread.nextThread -> prevThread = region6__thread.prevThread;
  region6__thread.prevThread -> nextThread = region6__thread.nextThread;
  goto *region6__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:region6:end
 } // region6__thread
 // forec:thread:region6:end

 // forec:thread:region7:start
 /*--------------------------------------------------------------

	| Thread region7

	*-------------------------------------------------------------*/
# 1053 "Mandelbrot.c"
 // Thread local declarations -----------------------------------
 // No declarations.

 // Thread body -------------------------------------------------
 region7__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  init(7);

  // pause;
  // forec:statement:pause:pause7:start
  region7__thread.programCounter = &&pause7;
  goto *region7__thread.nextThread -> programCounter;
  pause7:;
  // forec:statement:pause:pause7:end


  compute(7);

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:region7:start

  // Delete thread from the linked list and core.
  mainParCore3.activeThreads--;
  region7__thread.nextThread -> prevThread = region7__thread.prevThread;
  region7__thread.prevThread -> nextThread = region7__thread.nextThread;
  goto *region7__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:region7:end
 } // region7__thread
 // forec:thread:region7:end


} // End of the main() function.

void compute(int threadId__compute_0_0) {
 const int NUMBER_OF_THREADS__compute_0_0 = 8;
 const int y_RANGE__compute_0_0 = resultHeight__global_0_0/NUMBER_OF_THREADS__compute_0_0;
 int y__compute_0_0;
 for (y__compute_0_0 = (threadId__compute_0_0*y_RANGE__compute_0_0); y__compute_0_0 < ((threadId__compute_0_0 + 1)*y_RANGE__compute_0_0); ++y__compute_0_0) {
  int x__compute_1_0;
  for (x__compute_1_0 = 0; x__compute_1_0 < resultWidth__global_0_0; ++x__compute_1_0) {
   calculate(x__compute_1_0, 0);
   asm volatile ("nop");
  }
  asm volatile ("nop");
 }
}

void init(int threadId__init_0_0) {
 const int NUMBER_OF_THREADS__init_0_0 = 8;
 const int i_RANGE__init_0_0 = ColormapSize__global_0_0/NUMBER_OF_THREADS__init_0_0;
 int i__init_0_0;
 for (i__init_0_0 = (threadId__init_0_0*i_RANGE__init_0_0); i__init_0_0 < ((threadId__init_0_0 + 1)*i_RANGE__init_0_0); ++i__init_0_0) {
  colormap__global_0_0[i__init_0_0] = rgbFromWaveLength(380.0 + (i__init_0_0*400.0/ColormapSize__global_0_0));
  asm volatile ("nop");
 }
}

void calculate(int x__calculate_0_0, int y__calculate_0_0) {
 const int halfWidth__calculate_0_0 = resultWidth__global_0_0/2;
 const int halfHeight__calculate_0_0 = resultHeight__global_0_0/2;
 const int pass__calculate_0_0 = problemSize__global_0_0 - 1;
 const int MaxIterations__calculate_0_0 = (1 << (2*pass__calculate_0_0 + 6)) + 32;
 const int Limit__calculate_0_0 = 4;
 const int mod_x__calculate_0_0 = x__calculate_0_0 - halfWidth__calculate_0_0;
 const int mod_y__calculate_0_0 = y__calculate_0_0 - halfHeight__calculate_0_0;
 const float ay__calculate_0_0 = centerY__global_0_0 + (mod_y__calculate_0_0*pixmapScale__global_0_0);
 const float ax__calculate_0_0 = centerX__global_0_0 + (mod_x__calculate_0_0*pixmapScale__global_0_0);
 float a1__calculate_0_0 = ax__calculate_0_0;
 float b1__calculate_0_0 = ay__calculate_0_0;
 int numIterations__calculate_0_0 = 0;
 do {
  ++numIterations__calculate_0_0;
  float a2__calculate_1_0 = (a1__calculate_0_0*a1__calculate_0_0) - (b1__calculate_0_0*b1__calculate_0_0) + ax__calculate_0_0;
  float b2__calculate_1_0 = (2*a1__calculate_0_0*b1__calculate_0_0) + ay__calculate_0_0;
  if ((a2__calculate_1_0*a2__calculate_1_0) + (b2__calculate_1_0*b2__calculate_1_0) > Limit__calculate_0_0) {
   break;
  } else {
   // if0
  }
  ++numIterations__calculate_0_0;
  a1__calculate_0_0 = (a2__calculate_1_0*a2__calculate_1_0) - (b2__calculate_1_0*b2__calculate_1_0) + ax__calculate_0_0;
  b1__calculate_0_0 = (2*a2__calculate_1_0*b2__calculate_1_0) + ay__calculate_0_0;
  if ((a1__calculate_0_0*a1__calculate_0_0) + (b1__calculate_0_0*b1__calculate_0_0) > Limit__calculate_0_0) {
   break;
  } else {
   // if1
  }
  asm volatile ("nop");
 } while (numIterations__calculate_0_0 < MaxIterations__calculate_0_0);
 if (numIterations__calculate_0_0 < MaxIterations__calculate_0_0) {
  image__global_0_0[y__calculate_0_0][x__calculate_0_0] = uintToRgb(colormap__global_0_0[numIterations__calculate_0_0%ColormapSize__global_0_0]);
 } else {
  // ifElse2
  image__global_0_0[y__calculate_0_0][x__calculate_0_0] = uintToRgb(0);
 }
}

unsigned rgbFromWaveLength(float wave__rgbFromWaveLength_0_0) {
 unsigned char rr__rgbFromWaveLength_0_0;
 unsigned char gg__rgbFromWaveLength_0_0;
 unsigned char bb__rgbFromWaveLength_0_0;
 float r__rgbFromWaveLength_0_0 = 0.0;
 float g__rgbFromWaveLength_0_0 = 0.0;
 float b__rgbFromWaveLength_0_0 = 0.0;
 if (wave__rgbFromWaveLength_0_0 >= 380.0 && wave__rgbFromWaveLength_0_0 <= 440.0) {
  r__rgbFromWaveLength_0_0 = -1.0*(wave__rgbFromWaveLength_0_0 - 440.0)/(440.0 - 380.0);
  b__rgbFromWaveLength_0_0 = 1.0;
 } else {
  // ifElse8
  if (wave__rgbFromWaveLength_0_0 >= 440.0 && wave__rgbFromWaveLength_0_0 <= 490.0) {
   g__rgbFromWaveLength_0_0 = (wave__rgbFromWaveLength_0_0 - 440.0)/(490.0 - 440.0);
   b__rgbFromWaveLength_0_0 = 1.0;
  } else {
   // ifElse7
   if (wave__rgbFromWaveLength_0_0 >= 490.0 && wave__rgbFromWaveLength_0_0 <= 510.0) {
    g__rgbFromWaveLength_0_0 = 1.0;
    b__rgbFromWaveLength_0_0 = -1.0*(wave__rgbFromWaveLength_0_0 - 510.0)/(510.0 - 490.0);
   } else {
    // ifElse6
    if (wave__rgbFromWaveLength_0_0 >= 510.0 && wave__rgbFromWaveLength_0_0 <= 580.0) {
     r__rgbFromWaveLength_0_0 = (wave__rgbFromWaveLength_0_0 - 510.0)/(580.0 - 510.0);
     g__rgbFromWaveLength_0_0 = 1.0;
    } else {
     // ifElse5
     if (wave__rgbFromWaveLength_0_0 >= 580.0 && wave__rgbFromWaveLength_0_0 <= 645.0) {
      r__rgbFromWaveLength_0_0 = 1.0;
      g__rgbFromWaveLength_0_0 = -1.0*(wave__rgbFromWaveLength_0_0 - 645.0)/(645.0 - 580.0);
     } else {
      // ifElse4
      if (wave__rgbFromWaveLength_0_0 >= 645.0 && wave__rgbFromWaveLength_0_0 <= 780.0) {
       r__rgbFromWaveLength_0_0 = 1.0;
      } else {
       // if3
      }
     }
    }
   }
  }
 }
 float s__rgbFromWaveLength_0_0 = 1.0;
 if (wave__rgbFromWaveLength_0_0 > 700.0) {
  s__rgbFromWaveLength_0_0 = 0.3 + 0.7*(780.0 - wave__rgbFromWaveLength_0_0)/(780.0 - 700.0);
 } else {
  // ifElse10
  if (wave__rgbFromWaveLength_0_0 < 420.0) {
   s__rgbFromWaveLength_0_0 = 0.3 + 0.7*(wave__rgbFromWaveLength_0_0 - 380.0)/(420.0 - 380.0);
  } else {
   // if9
  }
 }
 r__rgbFromWaveLength_0_0 = fs_pow(r__rgbFromWaveLength_0_0*s__rgbFromWaveLength_0_0, 0.8);
 g__rgbFromWaveLength_0_0 = fs_pow(g__rgbFromWaveLength_0_0*s__rgbFromWaveLength_0_0, 0.8);
 b__rgbFromWaveLength_0_0 = fs_pow(b__rgbFromWaveLength_0_0*s__rgbFromWaveLength_0_0, 0.8);
 rr__rgbFromWaveLength_0_0 = (r__rgbFromWaveLength_0_0*255);
 gg__rgbFromWaveLength_0_0 = (g__rgbFromWaveLength_0_0*255);
 bb__rgbFromWaveLength_0_0 = (b__rgbFromWaveLength_0_0*255);
 return 0xFF000000 + (rr__rgbFromWaveLength_0_0 << 16) + (gg__rgbFromWaveLength_0_0 << 8) + bb__rgbFromWaveLength_0_0;
}

Pixel__global_0_0 uintToRgb(unsigned rgb__uintToRgb_0_0) {
 Pixel__global_0_0 p__uintToRgb_0_0 = {0, 0, 0};
 if (rgb__uintToRgb_0_0 != 0) {
  p__uintToRgb_0_0.r = (rgb__uintToRgb_0_0 & 0x00FF0000) >> 16;
  p__uintToRgb_0_0.g = (rgb__uintToRgb_0_0 & 0x0000FF00) >> 8;
  p__uintToRgb_0_0.b = (rgb__uintToRgb_0_0 & 0x000000FF);
 } else {
  // if11
 }
 return p__uintToRgb_0_0;
}

float fs_pow(float x__fs_pow_0_0, float y__fs_pow_0_0) {
 float p__fs_pow_0_0 = 0;
 if (0 > x__fs_pow_0_0 && fs_fmod(y__fs_pow_0_0, 1) == 0) {
  if (fs_fmod(y__fs_pow_0_0, 2) == 0) {
   p__fs_pow_0_0 = fs_exp(fs_log(-x__fs_pow_0_0)*y__fs_pow_0_0);
  } else {
   // ifElse12
   p__fs_pow_0_0 = -fs_exp(fs_log(-x__fs_pow_0_0)*y__fs_pow_0_0);
  }
 } else {
  // ifElse14
  if (x__fs_pow_0_0 != 0 || 0 >= y__fs_pow_0_0) {
   p__fs_pow_0_0 = fs_exp(fs_log(x__fs_pow_0_0)*y__fs_pow_0_0);
  } else {
   // if13
  }
 }
 return p__fs_pow_0_0;
}

float fs_fmod(float x__fs_fmod_0_0, float y__fs_fmod_0_0) {
 float a__fs_fmod_0_0, b__fs_fmod_0_0;
 const float c__fs_fmod_0_0 = x__fs_fmod_0_0;
 if (0 > c__fs_fmod_0_0) {
  x__fs_fmod_0_0 = -x__fs_fmod_0_0;
 } else {
  // if15
 }
 if (0 > y__fs_fmod_0_0) {
  y__fs_fmod_0_0 = -y__fs_fmod_0_0;
 } else {
  // if16
 }
 if (y__fs_fmod_0_0 != 0 && 3.40282347e+38F >= y__fs_fmod_0_0 && 3.40282347e+38F >= x__fs_fmod_0_0) {
  while (x__fs_fmod_0_0 >= y__fs_fmod_0_0) {
   a__fs_fmod_0_0 = x__fs_fmod_0_0/2;
   b__fs_fmod_0_0 = y__fs_fmod_0_0;
   while (a__fs_fmod_0_0 >= b__fs_fmod_0_0) {
    b__fs_fmod_0_0 *= 2;
    asm volatile ("nop");
   }
   x__fs_fmod_0_0 -= b__fs_fmod_0_0;
   asm volatile ("nop");
  }
 } else {
  // ifElse17
  x__fs_fmod_0_0 = 0;
 }
 return 0 > c__fs_fmod_0_0 ? -x__fs_fmod_0_0 : x__fs_fmod_0_0;
}

float fs_exp(float x__fs_exp_0_0) {
 unsigned n__fs_exp_0_0, square__fs_exp_0_0;
 float b__fs_exp_0_0, e__fs_exp_0_0;
 static float x_max__fs_exp_0_0, x_min__fs_exp_0_0, epsilon__fs_exp_0_0;
 static int initialized__fs_exp_0_0;
 if (!initialized__fs_exp_0_0) {
  initialized__fs_exp_0_0 = 1;
  x_max__fs_exp_0_0 = fs_log(3.40282347e+38F);
  x_min__fs_exp_0_0 = fs_log(1.17549435e-38F);
  epsilon__fs_exp_0_0 = 1.19209290e-7F/4;
 } else {
  // if18
 }
 if (x_max__fs_exp_0_0 >= x__fs_exp_0_0 && x__fs_exp_0_0 >= x_min__fs_exp_0_0) {
  for (square__fs_exp_0_0 = 0; x__fs_exp_0_0 > 1; x__fs_exp_0_0 /= 2) {
   ++square__fs_exp_0_0;
   asm volatile ("nop");
  }
  while (-1 > x__fs_exp_0_0) {
   ++square__fs_exp_0_0;
   x__fs_exp_0_0 /= 2;
   asm volatile ("nop");
  }
  e__fs_exp_0_0 = b__fs_exp_0_0 = n__fs_exp_0_0 = 1;
  do {
   b__fs_exp_0_0 /= n__fs_exp_0_0++;
   b__fs_exp_0_0 *= x__fs_exp_0_0;
   e__fs_exp_0_0 += b__fs_exp_0_0;
   b__fs_exp_0_0 /= n__fs_exp_0_0++;
   b__fs_exp_0_0 *= x__fs_exp_0_0;
   e__fs_exp_0_0 += b__fs_exp_0_0;
   asm volatile ("nop");
  } while (b__fs_exp_0_0 > epsilon__fs_exp_0_0);
  while (square__fs_exp_0_0-- != 0) {
   e__fs_exp_0_0 *= e__fs_exp_0_0;
   asm volatile ("nop");
  }
 } else {
  // ifElse19
  e__fs_exp_0_0 = x__fs_exp_0_0 > 0 ? 3.40282347e+38F : 0;
 }
 return e__fs_exp_0_0;
}

float fs_log(float x__fs_log_0_0) {
 int n__fs_log_0_0;
 float a__fs_log_0_0, b__fs_log_0_0, c__fs_log_0_0, epsilon__fs_log_0_0;
 static float A__fs_log_0_0, B__fs_log_0_0, C__fs_log_0_0;
 static int initialized__fs_log_0_0;
 if (x__fs_log_0_0 > 0 && 3.40282347e+38F >= x__fs_log_0_0) {
  if (!initialized__fs_log_0_0) {
   initialized__fs_log_0_0 = 1;
   A__fs_log_0_0 = fs_sqrt(2);
   B__fs_log_0_0 = A__fs_log_0_0/2;
   C__fs_log_0_0 = fs_log(A__fs_log_0_0);
  } else {
   // if20
  }
  for (n__fs_log_0_0 = 0; x__fs_log_0_0 > A__fs_log_0_0; x__fs_log_0_0 /= 2) {
   ++n__fs_log_0_0;
   asm volatile ("nop");
  }
  while (B__fs_log_0_0 > x__fs_log_0_0) {
   --n__fs_log_0_0;
   x__fs_log_0_0 *= 2;
   asm volatile ("nop");
  }
  a__fs_log_0_0 = (x__fs_log_0_0 - 1)/(x__fs_log_0_0 + 1);
  x__fs_log_0_0 = C__fs_log_0_0*n__fs_log_0_0 + a__fs_log_0_0;
  c__fs_log_0_0 = a__fs_log_0_0*a__fs_log_0_0;
  n__fs_log_0_0 = 1;
  epsilon__fs_log_0_0 = 1.19209290e-7F*x__fs_log_0_0;
  if (0 > a__fs_log_0_0) {
   if (epsilon__fs_log_0_0 > 0) {
    epsilon__fs_log_0_0 = -epsilon__fs_log_0_0;
   } else {
    // if21
   }
   do {
    n__fs_log_0_0 += 2;
    a__fs_log_0_0 *= c__fs_log_0_0;
    b__fs_log_0_0 = a__fs_log_0_0/n__fs_log_0_0;
    x__fs_log_0_0 += b__fs_log_0_0;
    asm volatile ("nop");
   } while (epsilon__fs_log_0_0 > b__fs_log_0_0);
  } else {
   // ifElse23
   if (0 > epsilon__fs_log_0_0) {
    epsilon__fs_log_0_0 = -epsilon__fs_log_0_0;
   } else {
    // if22
   }
   do {
    n__fs_log_0_0 += 2;
    a__fs_log_0_0 *= c__fs_log_0_0;
    b__fs_log_0_0 = a__fs_log_0_0/n__fs_log_0_0;
    x__fs_log_0_0 += b__fs_log_0_0;
    asm volatile ("nop");
   } while (b__fs_log_0_0 > epsilon__fs_log_0_0);
  }
  x__fs_log_0_0 *= 2;
 } else {
  // ifElse24
  x__fs_log_0_0 = -3.40282347e+38F;
 }
 return x__fs_log_0_0;
}

float fs_sqrt(float x__fs_sqrt_0_0) {
 int n__fs_sqrt_0_0;
 float a__fs_sqrt_0_0, b__fs_sqrt_0_0;
 if (x__fs_sqrt_0_0 > 0 && 3.40282347e+38F >= x__fs_sqrt_0_0) {
  for (n__fs_sqrt_0_0 = 0; x__fs_sqrt_0_0 > 2; x__fs_sqrt_0_0 /= 4) {
   ++n__fs_sqrt_0_0;
   asm volatile ("nop");
  }
  while (0.5 > x__fs_sqrt_0_0) {
   --n__fs_sqrt_0_0;
   x__fs_sqrt_0_0 *= 4;
   asm volatile ("nop");
  }
  a__fs_sqrt_0_0 = x__fs_sqrt_0_0;
  b__fs_sqrt_0_0 = (1 + x__fs_sqrt_0_0)/2;
  do {
   x__fs_sqrt_0_0 = b__fs_sqrt_0_0;
   b__fs_sqrt_0_0 = (a__fs_sqrt_0_0/x__fs_sqrt_0_0 + x__fs_sqrt_0_0)/2;
   asm volatile ("nop");
  } while (x__fs_sqrt_0_0 > b__fs_sqrt_0_0);
  while (n__fs_sqrt_0_0 > 0) {
   x__fs_sqrt_0_0 *= 2;
   --n__fs_sqrt_0_0;
   asm volatile ("nop");
  }
  while (0 > n__fs_sqrt_0_0) {
   x__fs_sqrt_0_0 /= 2;
   ++n__fs_sqrt_0_0;
   asm volatile ("nop");
  }
 } else {
  // ifElse26
  if (x__fs_sqrt_0_0 != 0) {
   x__fs_sqrt_0_0 = 3.40282347e+38F;
  } else {
   // if25
  }
 }
 return x__fs_sqrt_0_0;
}
