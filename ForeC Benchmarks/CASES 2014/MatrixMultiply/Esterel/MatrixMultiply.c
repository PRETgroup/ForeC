#include "esterel_mutex.h"
#define FSL_ESTEREL_MUTEX0_ID   3
#define FSL_ESTEREL_MUTEX1_ID   4
#define FSL_ESTEREL_MUTEX2_ID   5

#include "thread_queue.h"
#define FSL_THREAD_QUEUE_ID     6

/* Generated by EEC */
#include "MatrixMultiply_data.h"
#include "MatrixMultiply.h"

/* External declarations (constants, functions, procedures) */
#ifndef _NO_EXTERN_DEFINITIONS
  #ifndef _NO_CONSTANT_DEFINITIONS
  #endif /* _NO_CONSTANT_DEFINITIONS */
  #ifndef _NO_FUNCTION_DEFINITIONS
  #endif /* _NO_FUNCTION_DEFINITIONS */
  #ifndef _NO_PROCEDURE_DEFINITIONS
    #ifndef _fillMatrix_DEFINED
      #ifndef fillMatrix
        extern void fillMatrix(Matrix*, integer, integer);
      #endif
    #endif
    #ifndef _multiply_DEFINED
      #ifndef multiply
        extern void multiply(Matrix*, Matrix*, Matrix*, integer, integer);
      #endif
    #endif
  #endif /* _NO_PROCEDURE_DEFINITIONS */
#endif /* _NO_EXTERN_DEFINITIONS */


static struct {
    unsigned char size;
} _s = {  0 };

#define tick 1
static integer size_v;

/* Variable declaration */
static integer v_size;
static Matrix v_matrix_A;
static Matrix v_matrix_B;
static Matrix v_matrix_C;

/* State variables */
static unsigned char _state_1 = 4;

/* Thread variables */
static void* _thread_0 = 0;
static int _thread_0_count = 0;

#define _FORK(id)
#define _JOIN(id)
#define _PAUSE


/* Definitions for input functions */
void MatrixMultiply_I_size(integer _v)
{
    _s.size = 1;
    size_v = _v;
}


int MatrixMultiply(int isSlave)
{
    void * fslData;

    if (isSlave) {
        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
        goto *fslData;
    }

    for(;;) {
        ;
        switch (_state_1) {
            case 0:
                goto N26;
            case 1:
                _FORK(0);
//            M51:
                    ;
                    /* Vacuous terminate */;
//            M53:
                /* Exit thread 8 */;
//            M48:
                    ;
                    /* Vacuous terminate */;
//            M50:
                /* Exit thread 7 */;
//            M45:
                    ;
                    /* Vacuous terminate */;
//            M47:
                /* Exit thread 6 */;
//            M42:
                    ;
                    /* Vacuous terminate */;
//            M44:
                /* Exit thread 5 */;
//            M39:
                    ;
                    /* Vacuous terminate */;
//            M41:
                /* Exit thread 4 */;
//            M36:
                    ;
                    /* Vacuous terminate */;
//            M38:
                /* Exit thread 3 */;
//            M33:
                    ;
                    /* Vacuous terminate */;
//            M35:
                /* Exit thread 2 */;
//            M31:
                    ;
                /* Vacuous terminate */;
//            M29:
                /* Exit thread 1 */;
                ;
                goto N27;
            case 2:
                        _FORK(1);
//            M154:
                        ;
                        /* Vacuous terminate */;
//            M152:
                /* Exit thread 16 */;
//            M151:
                        ;
                        /* Vacuous terminate */;
//            M149:
                /* Exit thread 15 */;
//            M148:
                        ;
                        /* Vacuous terminate */;
//            M146:
                /* Exit thread 14 */;
//            M145:
                        ;
                        /* Vacuous terminate */;
//            M143:
                /* Exit thread 13 */;
//            M142:
                        ;
                        /* Vacuous terminate */;
//            M140:
                /* Exit thread 12 */;
//            M139:
                        ;
                        /* Vacuous terminate */;
//            M137:
                /* Exit thread 11 */;
//            M136:
                        ;
                        /* Vacuous terminate */;
//            M134:
                /* Exit thread 10 */;
//            M56:
                        ;
                        /* Vacuous terminate */;
//            M58:
                /* Exit thread 9 */;
                        ;
                goto N60;
            case 3:
                        if (_s.size) {
                            v_size = size_v;
                            _state_1 = 2;
                            _FORK(1);
                            _thread_0 = &&M125;
                            thread_queue_push(&&M125, FSL_THREAD_QUEUE_ID);
                            thread_queue_push(&&M121, FSL_THREAD_QUEUE_ID);
                            thread_queue_push(&&M117, FSL_THREAD_QUEUE_ID);
                            thread_queue_push(&&M113, FSL_THREAD_QUEUE_ID);
                            thread_queue_push(&&M109, FSL_THREAD_QUEUE_ID);
                            thread_queue_push(&&M105, FSL_THREAD_QUEUE_ID);
                            thread_queue_push(&&M101, FSL_THREAD_QUEUE_ID);
                            thread_queue_push(&&M99, FSL_THREAD_QUEUE_ID);
                            _thread_0_count = 8;
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                M125:
                            ;
                            fillMatrix(&v_matrix_B, 3, v_size);
                            /* Vacuous terminate */;
//                M128:
                    /* Exit thread 16 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M96_join;
                    }
                M121:
                            ;
                            fillMatrix(&v_matrix_B, 2, v_size);
                            /* Vacuous terminate */;
//                M124:
                    /* Exit thread 15 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M96_join;
                    }
                M117:
                            ;
                            fillMatrix(&v_matrix_B, 1, v_size);
                            /* Vacuous terminate */;
//                M120:
                    /* Exit thread 14 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M96_join;
                    }
                M113:
                            ;
                            fillMatrix(&v_matrix_B, 0, v_size);
                            /* Vacuous terminate */;
//                M116:
                    /* Exit thread 13 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M96_join;
                    }
                M109:
                            ;
                            fillMatrix(&v_matrix_A, 3, v_size);
                            /* Vacuous terminate */;
//                M112:
                    /* Exit thread 12 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M96_join;
                    }
                M105:
                            ;
                            fillMatrix(&v_matrix_A, 2, v_size);
                            /* Vacuous terminate */;
//                M108:
                    /* Exit thread 11 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M96_join;
                    }
                M101:
                            ;
                            fillMatrix(&v_matrix_A, 1, v_size);
                            /* Vacuous terminate */;
//                M104:
                    /* Exit thread 10 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M96_join;
                    }
                M99:
                            ;
                            fillMatrix(&v_matrix_A, 0, v_size);
                            /* Vacuous terminate */;
//                M96:
                    /* Exit thread 9 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M96_join;
                    }
                M96_join:
                            ;
                N60:
                _state_1 = 1;
                _FORK(0);
                _thread_0 = &&M94;
                thread_queue_push(&&M94, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M90, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M86, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M82, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M78, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M74, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M70, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M62, FSL_THREAD_QUEUE_ID);
                _thread_0_count = 8;
                thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                goto *fslData;
                M94:
                ;
                multiply(&v_matrix_A, &v_matrix_B, &v_matrix_C, 7, v_size);
                /* Vacuous terminate */;
//                M91:
                    /* Exit thread 8 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M65_join;
                    }
                M90:
                ;
                multiply(&v_matrix_A, &v_matrix_B, &v_matrix_C, 6, v_size);
                /* Vacuous terminate */;
//                M87:
                    /* Exit thread 7 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M65_join;
                    }
                M86:
                ;
                multiply(&v_matrix_A, &v_matrix_B, &v_matrix_C, 5, v_size);
                /* Vacuous terminate */;
//                M83:
                    /* Exit thread 6 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M65_join;
                    }
                M82:
                ;
                multiply(&v_matrix_A, &v_matrix_B, &v_matrix_C, 4, v_size);
                /* Vacuous terminate */;
//                M79:
                    /* Exit thread 5 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M65_join;
                    }
                M78:
                ;
                multiply(&v_matrix_A, &v_matrix_B, &v_matrix_C, 3, v_size);
                /* Vacuous terminate */;
//                M75:
                    /* Exit thread 4 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M65_join;
                    }
                M74:
                ;
                multiply(&v_matrix_A, &v_matrix_B, &v_matrix_C, 2, v_size);
                /* Vacuous terminate */;
//                M71:
                    /* Exit thread 3 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M65_join;
                    }
                M70:
                ;
                multiply(&v_matrix_A, &v_matrix_B, &v_matrix_C, 1, v_size);
                /* Vacuous terminate */;
//                M67:
                    /* Exit thread 2 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M65_join;
                    }
                M62:
                ;
                multiply(&v_matrix_A, &v_matrix_B, &v_matrix_C, 0, v_size);
                /* Vacuous terminate */;
//                M65:
                /* Exit thread 1 */;
                    esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                    esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                    _thread_0_count--;
                    esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                    if (_thread_0_count) {
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    } else {
                        goto M65_join;
                    }
                M65_join:
                ;
                N27:
                    /* Vacuous terminate */;
                N26:
                    _state_1 = 0;
                } else {
                    goto N132;
                }
                break;
            case 4:
                _state_1 = 3;
            N132:
                _PAUSE;
                break;
        }

#ifdef TESTBENCH
#endif
        _s.size = 0;

    M999:
        if (isSlave) {
            thread_queue_push(&&M999, FSL_THREAD_QUEUE_ID);

            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
            goto *fslData;
        }

//		printOut(&v_matrix_A, v_size);
//		printOut(&v_matrix_B, v_size);
//		printOut(&v_matrix_C, v_size);

        return _state_1;
    }
}

int MatrixMultiply_reset(void)
{
    _state_1 = 4;
    _s.size = 0;
    return 0;
}
