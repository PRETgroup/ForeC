#include "esterel_mutex.h"
#define FSL_ESTEREL_MUTEX0_ID   3
#define FSL_ESTEREL_MUTEX1_ID   4
#define FSL_ESTEREL_MUTEX2_ID   5

#include "thread_queue.h"
#define FSL_THREAD_QUEUE_ID     6

/* Generated by EEC */
#include "life_data.h"
#include "life.h"

static struct {
	unsigned char nrows;
	unsigned char ncols;
	unsigned char max_count;
	unsigned char seed;
	unsigned char s_msg_0;
	unsigned char s_msg_1;
	unsigned char s_msg_2;
	unsigned char s_msg_3;
	unsigned char s_msg_0_1;
	unsigned char s_msg_1_1;
	unsigned char s_msg_2_1;
	unsigned char s_msg_3_1;
	unsigned char s_msg_0_2;
	unsigned char s_msg_1_2;
	unsigned char s_msg_2_2;
	unsigned char s_msg_3_2;
} _s = {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 };


#define tick 1
static integer nrows_v;
static integer ncols_v;
static integer max_count_v;
static integer seed_v;
static GridMsg s_msg_0_1_v;
static GridMsg s_msg_1_1_v;
static GridMsg s_msg_2_1_v;
static GridMsg s_msg_3_1_v;


static union {
    unsigned int val;
    struct {
        unsigned int t1 : 1;
        unsigned int t3 : 1;
    } lock;
} _s_msg_1_1_locks;
#define _MASK_s_msg_1_1_locks 0x3

static union {
    unsigned int val;
    struct {
        unsigned int t2 : 1;
        unsigned int t4 : 1;
    } lock;
} _s_msg_2_1_locks;
#define _MASK_s_msg_2_1_locks 0x3

static union {
    unsigned int val;
    struct {
        unsigned int t1 : 1;
        unsigned int t3 : 1;
    } lock;
} _s_msg_3_1_locks;
#define _MASK_s_msg_3_1_locks 0x3

static union {
    unsigned int val;
    struct {
        unsigned int t2 : 1;
        unsigned int t4 : 1;
    } lock;
} _s_msg_0_1_locks;
#define _MASK_s_msg_0_1_locks 0x3

#define _UNLOCK_300() { \
    _s_msg_0_1_locks.lock.t4 = 0; \
    _s_msg_2_1_locks.lock.t4 = 0; \
    _unlock.each.n300 = 1; }

#define _UNLOCK_297() { \
    _s_msg_3_1_locks.lock.t3 = 0; \
    _s_msg_1_1_locks.lock.t3 = 0; \
    _unlock.each.n297 = 1; }

#define _UNLOCK_308() { \
    _s_msg_2_1_locks.lock.t2 = 0; \
    _s_msg_0_1_locks.lock.t2 = 0; \
    _unlock.each.n308 = 1; }

#define _UNLOCK_82() { \
    _s_msg_1_1_locks.lock.t1 = 0; \
    _s_msg_3_1_locks.lock.t1 = 0; \
    _unlock.each.n82 = 1; }

static union {
    unsigned int all;
    struct {
        unsigned int n82 : 1;
        unsigned int n300 : 1;
        unsigned int n297 : 1;
        unsigned int n308 : 1;
    } each;
} _unlock;

/* Variable declaration */
static integer v_nrows;
static integer v_ncols;
static integer v_max_count;
static Grid grid;
static Grid next_grid;
static GridMsg msg;
static Grid grid_1;
static Grid next_grid_1;
static GridMsg msg_1;
static Grid grid_2;
static Grid next_grid_2;
static GridMsg msg_2;
static Grid grid_3;
static Grid next_grid_3;
static GridMsg msg_3;

/* State variables */
static unsigned char _state_1 = 4;
static unsigned char _state_4;
static unsigned char _state_13;
static unsigned char _state_22;
static unsigned char _state_31;
static unsigned char _state_42;
static unsigned char _state_46;
static unsigned char _state_50;

/* Termination variables */
static int _term_56;
static int _term_59;
static int _term_341;

/* Thread variables */
static void* _thread_0 = 0;
static void* _thread_1 = 0;
static void* _thread_2 = 0;
static void* _thread_3 = 0;
static void* _thread_4 = 0;
static void* _thread_5 = 0;
static void* _thread_6 = 0;
static void* _thread_7 = 0;
static int _thread_0_count = 0;

/* Counter variables */
static int _counter_0;
static int _counter_1;
static int _counter_2;
static int _counter_3;

#define _FORK(id)
#define _JOIN(id)
#define _PAUSE


/* Definitions for input functions */
void life_I_nrows(integer _v)
{
    _s.nrows = 1;
    nrows_v = _v;
}

void life_I_ncols(integer _v)
{
    _s.ncols = 1;
    ncols_v = _v;
}

void life_I_max_count(integer _v)
{
    _s.max_count = 1;
    max_count_v = _v;
}

void life_I_seed(integer _v)
{
    _s.seed = 1;
    seed_v = _v;
}


int life(int isSlave)
{
    void * fslData;

    if (isSlave) {
        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
        goto *fslData;
    }

    esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
    esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
    esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
    esterel_mutex_lock(2, FSL_ESTEREL_MUTEX1_ID);
    esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
    esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
    esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
    esterel_mutex_lock(2, FSL_ESTEREL_MUTEX1_ID);
    esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
    esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
    esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
    esterel_mutex_lock(2, FSL_ESTEREL_MUTEX1_ID);
    esterel_mutex_set_key(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX0_ID);
    esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
    esterel_mutex_set_key(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX0_ID);
    esterel_mutex_lock(2, FSL_ESTEREL_MUTEX1_ID);
    _term_56 = 0;

    for(;;) {
        _term_56 &= 0x7fffffff;
        _term_59 &= 0x7fffffff;
        _term_341 &= 0x7fffffff;

        if (_thread_0) goto *_thread_0;
        switch (_state_1) {
            case 0:
                goto N57;
            case 1:
                _s.s_msg_3_1 = 0;
                _s.s_msg_2_1 = 0;
                _s.s_msg_1_1 = 0;
                _s.s_msg_0_1 = 0;
                _FORK(0); _thread_0 = &&M82; _term_59 = 0;
                thread_queue_push(&&M82, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M308, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M297, FSL_THREAD_QUEUE_ID);
                thread_queue_push(&&M300, FSL_THREAD_QUEUE_ID);
                _thread_0_count = 4;
                thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                goto *fslData;
            M82:
                if (_thread_1) goto *_thread_1;
                switch (_state_4) {
                    case 0:
                        esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        goto N86;
                    case 1:
                        esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        if (0 == --_counter_0) {
                            esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                            _state_4 = 0;
                        N86:
                            _thread_1 = 0; /* Vacuous terminate */;
                        } else {
                            send(&msg, &grid, 1);
                            (s_msg_3_1_v = msg), (_s.s_msg_3_1 = 1);
                            esterel_mutex_set_key(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX0_ID);
                            esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                        M94:
                            esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
                            esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                            if (fslData) {
                                thread_queue_push(&&M94, FSL_THREAD_QUEUE_ID);
                                thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                                goto *fslData;
                            } else {
                                if (_s.s_msg_0_1) {
                                    _GridMsg(&msg, &s_msg_0_1_v);
                                    recv(&msg, &grid, (v_ncols + 1));
                                    _state_4 = 3;
                                } else {
                                    _state_4 = 4;
                                }
                                goto N88;
                            }
                        }
                        break;
                    case 2:
                        esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                    M130:
                        esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M130, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_0_1) {
                                goto N125;
                            }
                            goto N88;
                        }
                        break;
                    case 3:
                        esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        send(&msg, &grid, v_ncols);
                        (s_msg_1_1_v = msg), (_s.s_msg_1_1 = 1);
                        esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                    M122:
                        esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M122, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_0_1) {
                            N125:
                                _GridMsg(&msg, &s_msg_0_1_v);
                                recv(&msg, &grid, 0);
                                compute(&grid, &next_grid);
                                _state_4 = 1;
                            } else {
                                _state_4 = 2;
                            }
                            goto N88;
                        }
                        break;
                    case 4:
                        esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                    M157:
                        esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M157, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_0_1) {
                                _GridMsg(&msg, &s_msg_0_1_v);
                                recv(&msg, &grid, (v_ncols + 1));
                                _state_4 = 3;
                            }
                            goto N88;
                        }
                        break;
                    case 5:
                        esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        _counter_0 = v_max_count;
                        send(&msg, &grid, 1);
                        (s_msg_3_1_v = msg), (_s.s_msg_3_1 = 1);
                        esterel_mutex_set_key(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                    M96:
                        esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            _term_59 |= 0x80000000;
                            thread_queue_push(&&M96, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_0_1) {
                                _GridMsg(&msg, &s_msg_0_1_v);
                                recv(&msg, &grid, (v_ncols + 1));
                                _state_4 = 3;
                            } else {
                                _state_4 = 4;
                            }
                        N88:
                            _term_59 |= 0x1; _thread_1 = &&M87;
                        }
                        break;
                }
            M87:
                /* Exit thread 1 */;
                esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                _thread_0_count--;
                esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                if (_thread_0_count) {
                    thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                    goto *fslData;
                } else {
                    goto M165_join;
                }
            M308:
                if (_thread_2) goto *_thread_2;
                switch (_state_13) {
                    case 0:
                        esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        goto N107;
                    case 1:
                        esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        if (0 == --_counter_1) {
                            esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                            _state_13 = 0;
                        N107:
                            _thread_2 = 0; /* Vacuous terminate */;
                        } else {
                        M113:
                            esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
                            esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                            if (fslData) {
                                thread_queue_push(&&M113, FSL_THREAD_QUEUE_ID);
                                thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                                goto *fslData;
                            } else {
                                if (_s.s_msg_1_1) {
                                    _GridMsg(&msg_1, &s_msg_1_1_v);
                                    recv(&msg_1, &grid_1, (v_ncols + 1));
                                    send(&msg_1, &grid_1, 1);
                                    (s_msg_0_1_v = msg_1), (_s.s_msg_0_1 = 1);
                                    esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                    esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                    _state_13 = 3;
                                } else {
                                    esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                                    _state_13 = 4;
                                }
                                goto N105;
                            }
                        }
                        break;
                    case 2:
                        esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                    M210:
                        esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M210, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_1_1) {
                                goto N205;
                            }
                            goto N105;
                        }
                        break;
                    case 3:
                        esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        send(&msg_1, &grid_1, v_ncols);
                        (s_msg_2_1_v = msg_1), (_s.s_msg_2_1 = 1);
                        esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                    M202:
                        esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M202, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_1_1) {
                            N205:
                                _GridMsg(&msg_1, &s_msg_1_1_v);
                                recv(&msg_1, &grid_1, 0);
                                compute(&grid_1, &next_grid_1);
                                _state_13 = 1;
                            } else {
                                _state_13 = 2;
                            }
                            goto N105;
                        }
                        break;
                    case 4:
                        esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                    M141:
                        esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M141, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_1_1) {
                                _GridMsg(&msg_1, &s_msg_1_1_v);
                                recv(&msg_1, &grid_1, (v_ncols + 1));
                                send(&msg_1, &grid_1, 1);
                                (s_msg_0_1_v = msg_1), (_s.s_msg_0_1 = 1);
                                esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                _state_13 = 3;
                            } else {
                                esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                            }
                            goto N105;
                        }
                        break;
                    case 5:
                        esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        _counter_1 = v_max_count;
                    M143:
                        esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            _term_59 |= 0x80000000;
                            thread_queue_push(&&M143, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_1_1) {
                                _GridMsg(&msg_1, &s_msg_1_1_v);
                                recv(&msg_1, &grid_1, (v_ncols + 1));
                                send(&msg_1, &grid_1, 1);
                                (s_msg_0_1_v = msg_1), (_s.s_msg_0_1 = 1);
                                esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                _state_13 = 3;
                            } else {
                                esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                                _state_13 = 4;
                            }
                        N105:
                            _term_59 |= 0x1; _thread_2 = &&M106;
                        }
                        break;
                }
            M106:
                /* Exit thread 2 */;
                esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                _thread_0_count--;
                esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                if (_thread_0_count) {
                    thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                    goto *fslData;
                } else {
                    goto M165_join;
                }
            M297:
                if (_thread_3) goto *_thread_3;
                switch (_state_22) {
                    case 0:
                        esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        goto N190;
                    case 1:
                        esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        if (0 == --_counter_2) {
                            esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                            _state_22 = 0;
                        N190:
                            _thread_3 = 0; /* Vacuous terminate */;
                        } else {
                        M196:
                            esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
                            esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                            if (fslData) {
                                thread_queue_push(&&M196, FSL_THREAD_QUEUE_ID);
                                thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                                goto *fslData;
                            } else {
                                if (_s.s_msg_2_1) {
                                    _GridMsg(&msg_2, &s_msg_2_1_v);
                                    recv(&msg_2, &grid_2, (v_ncols + 1));
                                    send(&msg_2, &grid_2, 1);
                                    (s_msg_1_1_v = msg_2), (_s.s_msg_1_1 = 1);
                                    esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                    esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                    _state_22 = 3;
                                } else {
                                    esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                                    _state_22 = 4;
                                }
                                goto N188;
                            }
                        }
                        break;
                    case 2:
                        esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                    M258:
                        esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M258, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_2_1) {
                                goto N253;
                            }
                            goto N188;
                        }
                        break;
                    case 3:
                        esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        send(&msg_2, &grid_2, v_ncols);
                        (s_msg_3_1_v = msg_2), (_s.s_msg_3_1 = 1);
                        esterel_mutex_set_key(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                    M263:
                        esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M263, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_2_1) {
                            N253:
                                _GridMsg(&msg_2, &s_msg_2_1_v);
                                recv(&msg_2, &grid_2, 0);
                                compute(&grid_2, &next_grid_2);
                                _state_22 = 1;
                            } else {
                                _state_22 = 2;
                            }
                            goto N188;
                        }
                        break;
                    case 4:
                        esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                    M221:
                        esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M221, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_2_1) {
                                _GridMsg(&msg_2, &s_msg_2_1_v);
                                recv(&msg_2, &grid_2, (v_ncols + 1));
                                send(&msg_2, &grid_2, 1);
                                (s_msg_1_1_v = msg_2), (_s.s_msg_1_1 = 1);
                                esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                _state_22 = 3;
                            } else {
                                esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                            }
                            goto N188;
                        }
                        break;
                    case 5:
                        esterel_mutex_unlock(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        _counter_2 = v_max_count;
                    M223:
                        esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            _term_59 |= 0x80000000;
                            thread_queue_push(&&M223, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_2_1) {
                                _GridMsg(&msg_2, &s_msg_2_1_v);
                                recv(&msg_2, &grid_2, (v_ncols + 1));
                                send(&msg_2, &grid_2, 1);
                                (s_msg_1_1_v = msg_2), (_s.s_msg_1_1 = 1);
                                esterel_mutex_set_key(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                _state_22 = 3;
                            } else {
                                esterel_mutex_unlock(&_s_msg_1_1_locks, FSL_ESTEREL_MUTEX2_ID);
                                _state_22 = 4;
                            }
                        N188:
                            _term_59 |= 0x1; _thread_3 = &&M189;
                        }
                        break;
                }
            M189:
                /* Exit thread 3 */;
                esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                _thread_0_count--;
                esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                if (_thread_0_count) {
                    thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                    goto *fslData;
                } else {
                    goto M165_join;
                }
            M300:
                if (_thread_4) goto *_thread_4;
                switch (_state_31) {
                    case 0:
                        esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        goto N166;
                    case 1:
                        esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        if (0 == --_counter_3) {
                            esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                            _state_31 = 0;
                        N166:
                            _thread_4 = 0; /* Vacuous terminate */;
                        } else {
                        M172:
                            esterel_mutex_set_key(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX0_ID);
                            esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                            if (fslData) {
                                thread_queue_push(&&M172, FSL_THREAD_QUEUE_ID);
                                thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                                goto *fslData;
                            } else {
                                if (_s.s_msg_3_1) {
                                    _GridMsg(&msg_3, &s_msg_3_1_v);
                                    recv(&msg_3, &grid_3, (v_ncols + 1));
                                    send(&msg_3, &grid_3, 1);
                                    (s_msg_2_1_v = msg_3), (_s.s_msg_2_1 = 1);
                                    esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                    esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                    _state_31 = 2;
                                } else {
                                    esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                                    _state_31 = 3;
                                }
                                goto N164;
                            }
                        }
                        break;
                    case 2:
                        esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                    M273:
                        esterel_mutex_set_key(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M273, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_3_1) {
                                _GridMsg(&msg_3, &s_msg_3_1_v);
                                recv(&msg_3, &grid_3, 0);
                                send(&msg_3, &grid_3, v_ncols);
                                (s_msg_0_1_v = msg_3), (_s.s_msg_0_1 = 1);
                                esterel_mutex_set_key(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                compute(&grid_3, &next_grid_3);
                                _state_31 = 1;
                            } else {
                                esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                            }
                            goto N164;
                        }
                        break;
                    case 3:
                        esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                    M241:
                        esterel_mutex_set_key(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            thread_queue_push(&&M241, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_3_1) {
                                _GridMsg(&msg_3, &s_msg_3_1_v);
                                recv(&msg_3, &grid_3, (v_ncols + 1));
                                send(&msg_3, &grid_3, 1);
                                (s_msg_2_1_v = msg_3), (_s.s_msg_2_1 = 1);
                                esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                _state_31 = 2;
                            } else {
                                esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                            }
                            goto N164;
                        }
                        break;
                    case 4:
                        esterel_mutex_unlock(&_s_msg_0_1_locks, FSL_ESTEREL_MUTEX2_ID);
                        _counter_3 = v_max_count;
                    M243:
                        esterel_mutex_set_key(&_s_msg_3_1_locks, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_unlocked(fslData, FSL_ESTEREL_MUTEX2_ID);
                        if (fslData) {
                            _term_59 |= 0x80000000;
                            thread_queue_push(&&M243, FSL_THREAD_QUEUE_ID);
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            if (_s.s_msg_3_1) {
                                _GridMsg(&msg_3, &s_msg_3_1_v);
                                recv(&msg_3, &grid_3, (v_ncols + 1));
                                send(&msg_3, &grid_3, 1);
                                (s_msg_2_1_v = msg_3), (_s.s_msg_2_1 = 1);
                                esterel_mutex_set_key(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX0_ID);
                                esterel_mutex_lock(0, FSL_ESTEREL_MUTEX1_ID);
                                _state_31 = 2;
                            } else {
                                esterel_mutex_unlock(&_s_msg_2_1_locks, FSL_ESTEREL_MUTEX2_ID);
                                _state_31 = 3;
                            }
                        N164:
                            _term_59 |= 0x1; _thread_4 = &&M165;
                        }
                        break;
                }
            M165:
                /* Exit thread 4 */;
                esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                _thread_0_count--;
                esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                if (_thread_0_count) {
                    thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                    goto *fslData;
                } else {
                    goto M165_join;
                }
            M165_join:
                _JOIN(0);
                _term_59 &= 0x7fffffff;
                switch (_term_59) {
                    case 0:
                        _thread_1 = 0; _thread_2 = 0; _thread_3 = 0; _thread_4 = 0;
                        _thread_0 = 0; /* Vacuous terminate */;
                    N57:
                        _state_1 = 0;
                        break;
                    case 1:
                        _thread_1 = 0; _thread_2 = 0; _thread_3 = 0; _thread_4 = 0;
                        goto N60;
                    default:
                        _term_56 = 0x80000000;
                        break;
                }
                break;
            case 2:
                if (_s.seed) {
                    initialize(v_ncols, v_nrows, seed_v);
                    goto N311;
                }
                goto N60;
            case 3:
                _FORK(1); _term_341 = 0;
//            M359:
                ;
                if (_state_50) {
                    if (_s.max_count) {
                        v_max_count = max_count_v;
                        _state_50 = 0;
                        goto N361;
                    } else {
                        _term_341 |= 0x1;
                    }
                } else {
                N361:
                    /* Vacuous terminate */;
                }
//            M362:
                /* Exit thread 7 */;
//            M351:
                ;
                if (_state_46) {
                    if (_s.ncols) {
                        v_ncols = ncols_v;
                        _state_46 = 0;
                        goto N353;
                    } else {
                        _term_341 |= 0x1;
                    }
                } else {
                N353:
                    /* Vacuous terminate */;
                }
//            M354:
                /* Exit thread 6 */;
//            M349:
                ;
                if (_state_42) {
                    if (_s.nrows) {
                        v_nrows = nrows_v;
                        _state_42 = 0;
                        goto N343;
                    } else {
                        _term_341 |= 0x1;
                    }
                } else {
                N343:
                    /* Vacuous terminate */;
                }
//            M342:
                /* Exit thread 5 */;
                if (_term_341) {
                } else {
                    if (_s.seed) {
                        initialize(v_ncols, v_nrows, seed_v);
                    N311:
                        _state_1 = 1;
                        _FORK(0);
                        thread_queue_push(&&M337, FSL_THREAD_QUEUE_ID);
                        thread_queue_push(&&M331, FSL_THREAD_QUEUE_ID);
                        thread_queue_push(&&M325, FSL_THREAD_QUEUE_ID);
                        thread_queue_push(&&M313, FSL_THREAD_QUEUE_ID);
                        _thread_0_count = 4;
                        thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                        goto *fslData;
                    M337:
                        ;
                        initialize_grid(&grid_3);
                        _state_31 = 4;
                        ;
//                    M332:
                        /* Exit thread 4 */;
                        esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                        _thread_0_count--;
                        esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                        if (_thread_0_count) {
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            goto M318_join;
                        }
                    M331:
                        ;
                        initialize_grid(&grid_2);
                        _state_22 = 5;
                        ;
//                    M326:
                        /* Exit thread 3 */;
                        esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                        _thread_0_count--;
                        esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                        if (_thread_0_count) {
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            goto M318_join;
                        }
                    M325:
                        ;
                        initialize_grid(&grid_1);
                        _state_13 = 5;
                        ;
//                    M320:
                        /* Exit thread 2 */;
                        esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                        _thread_0_count--;
                        esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                        if (_thread_0_count) {
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            goto M318_join;
                        }
                    M313:
                        ;
                        initialize_grid(&grid);
                        _state_4 = 5;
                        ;
//                    M318:
                        /* Exit thread 1 */;
                        esterel_mutex_set_key(&_thread_0_count, FSL_ESTEREL_MUTEX0_ID);
                        esterel_mutex_lock(1, FSL_ESTEREL_MUTEX1_ID);
                        _thread_0_count--;
                        esterel_mutex_unlock(&_thread_0_count, FSL_ESTEREL_MUTEX2_ID);
                        if (_thread_0_count) {
                            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
                            goto *fslData;
                        } else {
                            goto M318_join;
                        }
                    M318_join:
                        ;
                    } else {
                        _state_1 = 2;
                    }
                }
                goto N60;
            case 4:
                _state_1 = 3;
                _FORK(1);
//            M71:
                ;
                _state_50 = 1;
                ;
//            M74:
                /* Exit thread 7 */;
//            M67:
                ;
                _state_46 = 1;
                ;
//            M70:
                /* Exit thread 6 */;
//            M65:
                ;
                _state_42 = 1;
                ;
//            M62:
                /* Exit thread 5 */;
                ;
            N60:
                _thread_0 = 0; _PAUSE;
                break;
        }
        if (_term_56 < 0) continue;

#ifdef TESTBENCH
#endif
        _s.nrows = 0;
        _s.ncols = 0;
        _s.max_count = 0;
        _s.seed = 0;

    M999:
        if (isSlave) {
            thread_queue_push(&&M999, FSL_THREAD_QUEUE_ID);

            thread_queue_pop(fslData, FSL_THREAD_QUEUE_ID);
            goto *fslData;
        }

        return _state_1;
    }
}

int life_reset(void)
{
    _state_1 = 4;
    _s.nrows = 0;
    _s.ncols = 0;
    _s.max_count = 0;
    _s.seed = 0;
    _thread_0 = 0;
    _thread_1 = 0;
    _thread_2 = 0;
    _thread_3 = 0;
    _thread_4 = 0;
    _thread_5 = 0;
    _thread_6 = 0;
    _thread_7 = 0;
    return 0;
}
