# 1 "Life.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "Life.c"
/*==============================================================

| Hardware architecture specific declarations:

| Cores, mutex and input/output information.

*=============================================================*/
# 5 "Life.c"
// Xilinx Microblaze
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Driver parameters

*

*******************************************************************/
# 18 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver MPMC */


/* Definitions for peripheral DDR_SDRAM */
# 42 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/


/* Definitions for peripheral DDR_SDRAM */
# 82 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral DDR_SDRAM */
# 105 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver GPIO */


/* Definitions for peripheral AUDIO */







/* Definitions for peripheral DIP_SWITCHES_8BIT */







/* Definitions for peripheral LEDS_4BIT */







/* Definitions for peripheral LEDS_POSITIONS */







/* Definitions for peripheral PUSH_BUTTONS_POSITION */







/******************************************************************/


/* Definitions for peripheral SRAM */



/******************************************************************/

/* Definitions for peripheral SRAM */



/******************************************************************/

/* Canonical definitions for peripheral SRAM */






/******************************************************************/


/* Definitions for peripheral DLMB_CNTLR_0 */




/* Definitions for peripheral ILMB_CNTLR_0 */




/* Definitions for peripheral MB_PLB_BRAM_CNTLR */




/******************************************************************/

/* Definitions for driver UARTLITE */


/* Definitions for peripheral MDM_0 */
# 205 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral MDM_0 */
# 218 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for bus frequencies */


/******************************************************************/

/* Canonical definitions for bus frequencies */

/******************************************************************/




/******************************************************************/


/* Definitions for peripheral MICROBLAZE_0 */
# 433 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 635 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 7 "Life.c" 2

// Xilinx Microblaze Processor Version Register
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2006 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE.
//
// $Id: pvr.h,v 1.1.2.1 2009/09/24 23:37:37 haibing Exp $
////////////////////////////////////////////////////////////////////////////////

/*****************************************************************************/
/**
*
* @file pvr.h
*
* This header file contains defines for structures used by the microblaze 
* PVR routines
*
******************************************************************************/




# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 60 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/***************************** Include Files *********************************/


/************************** Constant Definitions *****************************/
# 77 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/** Xilinx NULL, TRUE and FALSE legacy support. Deprecated. */
# 86 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/* the following constants and declarations are for unit test purposes and are
 * designed to be used in test applications.
 */






extern unsigned int XAssertStatus;
extern void XAssert(char *, int);

/**************************** Type Definitions *******************************/

/** @name Legacy types
 * Deprecated legacy types.
 * @{
 */
typedef unsigned char Xuint8; /**< unsigned 8-bit */
typedef char Xint8; /**< signed 8-bit */
typedef unsigned short Xuint16; /**< unsigned 16-bit */
typedef short Xint16; /**< signed 16-bit */
typedef unsigned long Xuint32; /**< unsigned 32-bit */
typedef long Xint32; /**< signed 32-bit */
typedef float Xfloat32; /**< 32-bit floating point */
typedef double Xfloat64; /**< 64-bit double precision FP */
typedef unsigned long Xboolean; /**< boolean (XTRUE or XFALSE) */

typedef struct
{
 Xuint32 Upper;
 Xuint32 Lower;
} Xuint64;

/** @name New types
 * New simple types.
 * @{
 */


typedef Xuint32 u32;
typedef Xuint16 u16;
typedef Xuint8 u8;





/*@}*/

/**
 * This data type defines an interrupt handler for a device.
 * The argument points to the instance of the component
 */
typedef void (*XInterruptHandler) (void *InstancePtr);

/**
 * This data type defines an exception handler for a processor.
 * The argument points to the instance of the component
 */
typedef void (*XExceptionHandler) (void *InstancePtr);

/**
 * This data type defines a callback to be invoked when an
 * assert occurs. The callback is invoked only when asserts are enabled
 */
typedef void (*XAssertCallback) (char *FilenamePtr, int LineNumber);

/***************** Macros (Inline Functions) Definitions *********************/

/*****************************************************************************/
/**
* Return the most significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The upper 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/


/*****************************************************************************/
/**
* Return the least significant half of the 64 bit data type.
*
* @param    x is the 64 bit word.
*
* @return   The lower 32 bits of the 64 bit word.
*
* @note     None.
*
******************************************************************************/





/*****************************************************************************/
/**
* This assert macro is to be used for functions that do not return anything
* (void). This in conjunction with the XWaitInAssert boolean can be used to
* accomodate tests so that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to
*           false, the assert occurs.
*
* @return   Returns void unless the XWaitInAssert variable is true, in which
*           case no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 214 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/*****************************************************************************/
/**
* This assert macro is to be used for functions that do return a value. This in
* conjunction with the XWaitInAssert boolean can be used to accomodate tests so
* that asserts which fail allow execution to continue.
*
* @param    expression is the expression to evaluate. If it evaluates to false,
*           the assert occurs.
*
* @return   Returns 0 unless the XWaitInAssert variable is true, in which case
*           no return is made and an infinite loop is entered.
*
* @note     None.
*
******************************************************************************/
# 243 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do not
* return anything (void). Use for instances where an assert should always
* occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/







/*****************************************************************************/
/**
* Always assert. This assert macro is to be used for functions that do return
* a value. Use for instances where an assert should always occur.
*
* @return Returns void unless the XWaitInAssert variable is true, in which case
*         no return is made and an infinite loop is entered.
*
* @note   None.
*
******************************************************************************/
# 289 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h"
/************************** Function Prototypes ******************************/

void XAssertSetCallback(XAssertCallback Routine);
void XNullHandler(void *NullParameter);
# 34 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Driver parameters

*

*******************************************************************/
# 18 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver MPMC */


/* Definitions for peripheral DDR_SDRAM */
# 42 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/


/* Definitions for peripheral DDR_SDRAM */
# 82 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral DDR_SDRAM */
# 105 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for driver GPIO */


/* Definitions for peripheral AUDIO */







/* Definitions for peripheral DIP_SWITCHES_8BIT */







/* Definitions for peripheral LEDS_4BIT */







/* Definitions for peripheral LEDS_POSITIONS */







/* Definitions for peripheral PUSH_BUTTONS_POSITION */







/******************************************************************/


/* Definitions for peripheral SRAM */



/******************************************************************/

/* Definitions for peripheral SRAM */



/******************************************************************/

/* Canonical definitions for peripheral SRAM */






/******************************************************************/


/* Definitions for peripheral DLMB_CNTLR_0 */




/* Definitions for peripheral ILMB_CNTLR_0 */




/* Definitions for peripheral MB_PLB_BRAM_CNTLR */




/******************************************************************/

/* Definitions for driver UARTLITE */


/* Definitions for peripheral MDM_0 */
# 205 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Canonical definitions for peripheral MDM_0 */
# 218 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/

/* Definitions for bus frequencies */


/******************************************************************/

/* Canonical definitions for bus frequencies */

/******************************************************************/




/******************************************************************/


/* Definitions for peripheral MICROBLAZE_0 */
# 433 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 635 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xparameters.h"
/******************************************************************/
# 35 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE. 
// 
// File   : mb_interface.h
// Date   : 2002, March 20.
// Company: Xilinx
// Group  : Emerging Software Technologies
//
// Summary:
// Header file for mb_interface
//
// $Id: mb_interface.h,v 1.1.2.1 2009/09/24 23:37:36 haibing Exp $
//
////////////////////////////////////////////////////////////////////////////////




# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 33 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 2





extern void microblaze_enable_interrupts(void); /* Enable Interrupts */
extern void microblaze_disable_interrupts(void); /* Disable Interrupts */
extern void microblaze_enable_icache(void); /* Enable Instruction Cache */
extern void microblaze_disable_icache(void); /* Disable Instruction Cache */
extern void microblaze_enable_dcache(void); /* Enable Instruction Cache */
extern void microblaze_disable_dcache(void); /* Disable Instruction Cache */
extern void microblaze_enable_exceptions(void); /* Enable hardware exceptions */
extern void microblaze_disable_exceptions(void); /* Disable hardware exceptions */
extern void microblaze_register_handler(XInterruptHandler Handler, void *DataPtr); /* Register top level interrupt handler */
extern void microblaze_register_exception_handler(Xuint8 ExceptionId, XExceptionHandler Handler, void *DataPtr); /* Register exception handler */

extern void microblaze_invalidate_icache(); /* Invalidate the entire icache */
extern void microblaze_invalidate_dcache(); /* Invalidate the entire dcache */
extern void microblaze_flush_dcache(); /* Flush the whole dcache */
extern void microblaze_invalidate_icache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the icache */
extern void microblaze_invalidate_dcache_range(unsigned int cacheaddr, unsigned int len); /* Invalidate a part of the dcache */
extern void microblaze_flush_dcache_range(unsigned int cacheaddr, unsigned int len); /* Flush a part of the dcache */

/* Deprecated */
extern void microblaze_update_icache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_icache_range (int , int ) __attribute__((deprecated));
extern void microblaze_update_dcache (int , int , int ) __attribute__((deprecated));
extern void microblaze_init_dcache_range (int , int ) __attribute__((deprecated));

/* necessary for pre-processor */



/* FSL Access Macros */

/* Blocking Data Read and Write to FSL no. id */



/* Non-blocking Data Read and Write to FSL no. id */



/* Blocking Control Read and Write to FSL no. id */



/* Non-blocking Control Read and Write to FSL no. id */



/* Polling versions of FSL access macros. This makes the FSL access interruptible */
# 104 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h"
/* FSL valid and error check macros. */




/* Pseudo assembler instructions */
# 257 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h"
/* Deprecated MicroBlaze FSL macros */
# 36 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/bspconfig.h" 1

/*******************************************************************

*

* CAUTION: This file is automatically generated by libgen.

* Version: Xilinx EDK 12.4 EDK_MS4.81d

* DO NOT EDIT.

*

* Copyright (c) 1995-2010 Xilinx, Inc.  All rights reserved.



* 

* Description: Configurations for Standalone BSP

*

*******************************************************************/
# 37 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h" 2






/* Defs */
typedef struct pvr_s {



  unsigned int pvr[1];

} pvr_t;




/* Basic PVR mask */
# 67 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h"
/* User 2 PVR mask */


/* Configuration PVR masks */
# 96 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h"
/* Debug and exception PVR masks */






/* ICache config PVR masks */







/* DCache config PVR masks */







/* ICache base address PVR mask */


/* ICache high address PVR mask */


/* DCache base address PVR mask */


/* DCache high address PVR mask */


/* Target family PVR mask */


/* MSR Reset value PVR mask */


/* MMU value PVR mask */



/* PVR access macros */
# 206 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/pvr.h"
/* Protos */
int microblaze_get_pvr (pvr_t *pvr);
# 10 "Life.c" 2

// Hardware counter connected via a direct FSL bus.
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 1
/*****************************************************************************

* Filename:          C:\Xilinx\12.1\MyProcessorIPLib\drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h

* Version:           1.00.a

* Description:       counter_dfsl (Counter DFSL) Driver Header File

* Date:              Fri Jul 02 14:27:25 2010 (by Create and Import Peripheral Wizard)

*****************************************************************************/
# 11 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 1



# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/xbasic_types.h" 1
/* $Id: xbasic_types.h,v 1.19.10.3 2009/10/19 16:36:59 haibing Exp $ */
/******************************************************************************
*
*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
*       FOR A PARTICULAR PURPOSE.
*
*       (c) Copyright 2002-2007 Xilinx Inc.
*       All rights reserved.
*
******************************************************************************/
/*****************************************************************************/
/**
*
* @file xbasic_types.h
*
* This file contains basic types for Xilinx software IP.  These types do not
* follow the standard naming convention with respect to using the component
* name in front of each name because they are considered to be primitives.
*
* @note
*
* This file contains items which are architecture dependent.
*
* <pre>
* MODIFICATION HISTORY:
*
* Ver   Who    Date   Changes
* ----- ---- -------- -------------------------------------------------------
* 1.00a rmm  12/14/01 First release
*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
*                     compiler warnings
* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
* 1.00a xd   11/03/04 Improved support for doxygen.
* 1.00a wre  01/25/07 Added Linux style data types u32, u16, u8, TRUE, FALSE
* 1.00a rpm  04/02/07 Added ifndef KERNEL around u32, u16, u8 data types
* </pre>
*
******************************************************************************/
# 5 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 2
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/mb_interface.h" 1
////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2004 Xilinx, Inc.  All rights reserved. 
// 
// Xilinx, Inc. 
// XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A 
// COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS 
// ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR 
// STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION 
// IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE 
// FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION. 
// XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO 
// THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO 
// ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE 
// FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY 
// AND FITNESS FOR A PARTICULAR PURPOSE. 
// 
// File   : mb_interface.h
// Date   : 2002, March 20.
// Company: Xilinx
// Group  : Emerging Software Technologies
//
// Summary:
// Header file for mb_interface
//
// $Id: mb_interface.h,v 1.1.2.1 2009/09/24 23:37:36 haibing Exp $
//
////////////////////////////////////////////////////////////////////////////////
# 6 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 2





/* Extended FSL macros. These now replace all of the previous FSL macros */
# 12 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h" 2


typedef struct {
 int current; // Current counter value measured.
 int last; // Last value of the counter.
 int difference; // Difference between the current and last values.
 int min; // Minimum counter value.
 int avg; // Average counter value.
 int max; // Maximum counter value.
 long int total; // Cumulative value of all differences.
 int iterations; // Number of times values are added to the total.
} Counter;


// Initialise the current and last counter values.
# 40 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/counter_dfsl_v1_00_a/src/counter_dfsl.h"
// Start the counter with the specified value.



// Stop the counter and read the current value.



// Read the current counter value.
// Subtract 3 cycles for put and addk instruction.




// Calculate the difference between the current and last
// counter values.



// Accumulate the counter difference.




// Calculate the average differences.



// Update the maximum counter difference.





// Update the minimum counter difference.
# 13 "Life.c" 2
Counter counter;

// ForeC hardware mutex
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/forec_mutex_v1_00_a/src/forec_mutex.h" 1
/*****************************************************************************

* Filename:          C:\Xilinx\12.1\MyProcessorIPLib\drivers/forec_mutex_v1_00_a/src/forec_mutex.h

* Version:           1.00.a

* Description:       forec_mutex (ForeC Mutex) Driver Header File

* Date:              Fri Jul 02 14:27:25 2010 (by Create and Import Peripheral Wizard)

*****************************************************************************/
# 1 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/include/fsl.h" 1
# 13 "/home/kinchee87/Dropbox/PRET/ForeC Analyser/microblaze/drivers/forec_mutex_v1_00_a/src/forec_mutex.h" 2


// Set the bit at the given position in the bit array.



// Resets all bits to 1. Only works on core0.



// Clear the bit at the given position in the bit array.



// Read the entire bit array.
# 17 "Life.c" 2






/*==============================================================

| ForeC type definitions:

| Defines the types of storage elements specific to ForeC.

*=============================================================*/
# 27 "Life.c"
// Status values.
typedef enum {
 // PAR
 FOREC_PAR_OFF, // 0
 FOREC_PAR_ON, // 1

 // Core
 FOREC_CORE_REACTING, // 2
 FOREC_CORE_REACTED, // 3
 FOREC_CORE_TERMINATED, // 4

 // Shared variables
 FOREC_SHARED_UNMODIFIED, // 5
 FOREC_SHARED_MODIFIED, // 6
 FOREC_SHARED_WAS_MODIFIED // 7
} Status;

// Store child thread information.
typedef struct _Thread {
 void *programCounter;
 struct _Thread *nextThread;
 struct _Thread *prevThread;
} Thread;

// Store parent thread information
typedef struct {
 void *programCounter;
 int parStatus;
 int parId;
} Parent;

// Keep track of child threads executing on
// a processor core.
typedef struct {
 int sync;
 int activeThreads;
 int status;
 int reactionCounter;
} Core;

// Global variable for counting the number of global reactions.
volatile long int globalReactions = 0;

// Shared control variables for par(...)s -------------------------
// Thread main with par(...)s
volatile Parent mainParParent;
volatile Core mainParCore0;
volatile Core mainParCore1;
volatile Core mainParCore2;
volatile Core mainParCore3;
volatile int mainParReactionCounter;


/*==============================================================

| Original global declarations:

| Global declarations in the original program code.

*=============================================================*/
# 84 "Life.c"
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdlib.h" 1 3
/*
 * stdlib.h
 *
 * Definitions for common types, variables, and functions.
 */




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* Some ANSI environments are "broken" in the sense that __STDC__ cannot be
   relied upon to have it's intended meaning.  Therefore we must use our own
   concoction: _HAVE_STDC.  Always use _HAVE_STDC instead of __STDC__ in newlib
   sources!

   To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/newlib.h" 1 3
/* newlib.h.  Generated automatically by configure.  */




/* EL/IX level */
/* #undef _ELIX_LEVEL */

/* Newlib version */


/* long long type support in IO functions like printf/scanf enabled */


/* long double type support in IO functions like printf/scanf enabled */
/* #undef _WANT_IO_LONG_DOUBLE */

/* Positional argument support in printf functions enabled.  */
/* #undef _WANT_IO_POS_ARGS */

/* Multibyte supported */
/* #undef _MB_CAPABLE */

/* MB_LEN_MAX */


/* ICONV enabled */
/* #undef _ICONV_ENABLED */

/* Enable ICONV external CCS files loading capabilities */
/* #undef _ICONV_ENABLE_EXTERNAL_CCS */

/*
 * Iconv encodings enabled ("to" direction)
 */
/* #undef _ICONV_TO_ENCODING_BIG5 */
/* #undef _ICONV_TO_ENCODING_CP775 */
/* #undef _ICONV_TO_ENCODING_CP850 */
/* #undef _ICONV_TO_ENCODING_CP852 */
/* #undef _ICONV_TO_ENCODING_CP855 */
/* #undef _ICONV_TO_ENCODING_CP866 */
/* #undef _ICONV_TO_ENCODING_EUC_JP */
/* #undef _ICONV_TO_ENCODING_EUC_TW */
/* #undef _ICONV_TO_ENCODING_EUC_KR */
/* #undef _ICONV_TO_ENCODING_ISO_8859_1 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_10 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_11 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_13 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_14 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_15 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_2 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_3 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_4 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_5 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_6 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_7 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_8 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_9 */
/* #undef _ICONV_TO_ENCODING_ISO_IR_111 */
/* #undef _ICONV_TO_ENCODING_KOI8_R */
/* #undef _ICONV_TO_ENCODING_KOI8_RU */
/* #undef _ICONV_TO_ENCODING_KOI8_U */
/* #undef _ICONV_TO_ENCODING_KOI8_UNI */
/* #undef _ICONV_TO_ENCODING_UCS_2 */
/* #undef _ICONV_TO_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_2BE */
/* #undef _ICONV_TO_ENCODING_UCS_2LE */
/* #undef _ICONV_TO_ENCODING_UCS_4 */
/* #undef _ICONV_TO_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_4BE */
/* #undef _ICONV_TO_ENCODING_UCS_4LE */
/* #undef _ICONV_TO_ENCODING_US_ASCII */
/* #undef _ICONV_TO_ENCODING_UTF_16 */
/* #undef _ICONV_TO_ENCODING_UTF_16BE */
/* #undef _ICONV_TO_ENCODING_UTF_16LE */
/* #undef _ICONV_TO_ENCODING_UTF_8 */
/* #undef _ICONV_TO_ENCODING_WIN_1250 */
/* #undef _ICONV_TO_ENCODING_WIN_1251 */
/* #undef _ICONV_TO_ENCODING_WIN_1252 */
/* #undef _ICONV_TO_ENCODING_WIN_1253 */
/* #undef _ICONV_TO_ENCODING_WIN_1254 */
/* #undef _ICONV_TO_ENCODING_WIN_1255 */
/* #undef _ICONV_TO_ENCODING_WIN_1256 */
/* #undef _ICONV_TO_ENCODING_WIN_1257 */
/* #undef _ICONV_TO_ENCODING_WIN_1258 */

/*
 * Iconv encodings enabled ("from" direction)
 */
/* #undef _ICONV_FROM_ENCODING_BIG5 */
/* #undef _ICONV_FROM_ENCODING_CP775 */
/* #undef _ICONV_FROM_ENCODING_CP850 */
/* #undef _ICONV_FROM_ENCODING_CP852 */
/* #undef _ICONV_FROM_ENCODING_CP855 */
/* #undef _ICONV_FROM_ENCODING_CP866 */
/* #undef _ICONV_FROM_ENCODING_EUC_JP */
/* #undef _ICONV_FROM_ENCODING_EUC_TW */
/* #undef _ICONV_FROM_ENCODING_EUC_KR */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_1 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_10 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_11 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_13 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_14 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_15 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_2 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_3 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_4 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_5 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_6 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_7 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_8 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_9 */
/* #undef _ICONV_FROM_ENCODING_ISO_IR_111 */
/* #undef _ICONV_FROM_ENCODING_KOI8_R */
/* #undef _ICONV_FROM_ENCODING_KOI8_RU */
/* #undef _ICONV_FROM_ENCODING_KOI8_U */
/* #undef _ICONV_FROM_ENCODING_KOI8_UNI */
/* #undef _ICONV_FROM_ENCODING_UCS_2 */
/* #undef _ICONV_FROM_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_2BE */
/* #undef _ICONV_FROM_ENCODING_UCS_2LE */
/* #undef _ICONV_FROM_ENCODING_UCS_4 */
/* #undef _ICONV_FROM_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_4BE */
/* #undef _ICONV_FROM_ENCODING_UCS_4LE */
/* #undef _ICONV_FROM_ENCODING_US_ASCII */
/* #undef _ICONV_FROM_ENCODING_UTF_16 */
/* #undef _ICONV_FROM_ENCODING_UTF_16BE */
/* #undef _ICONV_FROM_ENCODING_UTF_16LE */
/* #undef _ICONV_FROM_ENCODING_UTF_8 */
/* #undef _ICONV_FROM_ENCODING_WIN_1250 */
/* #undef _ICONV_FROM_ENCODING_WIN_1251 */
/* #undef _ICONV_FROM_ENCODING_WIN_1252 */
/* #undef _ICONV_FROM_ENCODING_WIN_1253 */
/* #undef _ICONV_FROM_ENCODING_WIN_1254 */
/* #undef _ICONV_FROM_ENCODING_WIN_1255 */
/* #undef _ICONV_FROM_ENCODING_WIN_1256 */
/* #undef _ICONV_FROM_ENCODING_WIN_1257 */
/* #undef _ICONV_FROM_ENCODING_WIN_1258 */

/* Define if the linker supports .preinit_array/.init_array/.fini_array
 * sections.  */


/* True if atexit() may dynamically allocate space for cleanup
   functions.  */
/* #undef  _ATEXIT_DYNAMIC_ALLOC */

/* Define if the compiler supports aliasing an array to an address.  */
/* #undef  _HAVE_ARRAY_ALIASING */
# 16 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 2 3
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 1 3



# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/ieeefp.h" 1 3



/* This file can define macros to choose variations of the IEEE float
   format:

   _FLT_LARGEST_EXPONENT_IS_NORMAL

	Defined if the float format uses the largest exponent for finite
	numbers rather than NaN and infinity representations.  Such a
	format cannot represent NaNs or infinities at all, but it's FLT_MAX
	is twice the IEEE value.

   _FLT_NO_DENORMALS

	Defined if the float format does not support IEEE denormals.  Every
	float with a zero exponent is taken to be a zero representation.
 
   ??? At the moment, there are no equivalent macros above for doubles and
   the macros are not fully supported by --enable-newlib-hw-fp.

   __IEEE_BIG_ENDIAN

        Defined if the float format is big endian.  This is mutually exclusive
        with __IEEE_LITTLE_ENDIAN.

   __IEEE_LITTLE_ENDIAN
 
        Defined if the float format is little endian.  This is mutually exclusive
        with __IEEE_BIG_ENDIAN.

   Note that one of __IEEE_BIG_ENDIAN or __IEEE_LITTLE_ENDIAN must be specified for a
   platform or error will occur.

   __IEEE_BYTES_LITTLE_ENDIAN

        This flag is used in conjunction with __IEEE_BIG_ENDIAN to describe a situation 
	whereby multiple words of an IEEE floating point are in big endian order, but the
	words themselves are little endian with respect to the bytes.

   _DOUBLE_IS_32_BITS 

        This is used on platforms that support double by using the 32-bit IEEE
        float type.

   _FLOAT_ARG

        This represents what type a float arg is passed as.  It is used when the type is
        not promoted to double.
	
*/
# 156 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/ieeefp.h" 3
/* necv70 was __IEEE_LITTLE_ENDIAN. */
# 5 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 2 3

/* exceptions first */







/* 16 bit integer machines */
# 87 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 3
/* For the PowerPC eabi, force the _impure_ptr to be in .sdata */
# 125 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 3
/* Configure small REENT structure for Xilinx PPC and MB platforms */







/* This block should be kept in sync with GCC's limits.h.  The point
   of having these definitions here is to not include limits.h, which
   would pollute the user namespace, while still using types of the
   the correct widths when deciding how to define __int32_t and
   __int64_t.  */
# 158 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 3
/* End of block that should be kept in sync with GCC's limits.h.  */
# 187 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/config.h" 3
/* Define return type of read/write routines.  In POSIX, the return type
   for read()/write() is "ssize_t" but legacy newlib code has been using
   "int" for some time.  If not specified, "int" is defaulted.  */
# 17 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 2 3

/* First try to figure out whether we really are in an ANSI C environment.  */
/* FIXME: This probably needs some work.  Perhaps sys/config.h can be
   prevailed upon to give us a clue.  */
# 70 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 3
/* Support gcc's __attribute__ facility.  */







/*  ISO C++.  */
# 11 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdlib.h" 2 3



# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 52 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
# 97 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 122 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 167 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 214 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 240 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 281 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */
# 308 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
# 326 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
typedef int wchar_t;
# 360 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
# 395 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* A null pointer constant.  */
# 15 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdlib.h" 2 3

# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 1 3
/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */







# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* Some ANSI environments are "broken" in the sense that __STDC__ cannot be
   relied upon to have it's intended meaning.  Therefore we must use our own
   concoction: _HAVE_STDC.  Always use _HAVE_STDC instead of __STDC__ in newlib
   sources!

   To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
# 14 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 2 3
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/_types.h" 1 3
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  This file lives in the `sys' directory so targets can provide
   their own if desired (or they can put target dependant conditionals here).
*/




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/lock.h" 1 3



/* dummy lock routines for single-threaded aps */

typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 13 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/_types.h" 2 3

typedef long _off_t;
__extension__ typedef long long _off64_t;


typedef int _ssize_t;





# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 1 3 4
/* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004
   Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to
the Free Software Foundation, 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */

/* As a special exception, if you include this header file into source
   files compiled by GCC, this header file does not by itself cause
   the resulting executable to be covered by the GNU General Public
   License.  This exception does not however invalidate any other
   reasons why the executable file might be covered by the GNU General
   Public License.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 52 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_ */
# 97 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 122 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 167 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 240 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 355 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
typedef unsigned int wint_t;




/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
# 395 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/include/stddef.h" 3 4
/* A null pointer constant.  */
# 25 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/_types.h" 2 3

/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value; /* Value so far.  */
} _mbstate_t;

typedef _LOCK_RECURSIVE_T _flock_t;

/* Iconv descriptor type */
typedef void *_iconv_t;
# 15 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/*
 * If _REENT_SMALL is defined, we make struct _reent as small as possible,
 * by having nearly everything possible allocated at first use.
 */

struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};

/* needed by reentrant structure */
struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};

/*
 * atexit() support.
 */



struct _on_exit_args {
 void * _fnargs[32 /* must be at least 32 to guarantee ANSI conformance */]; /* user fn args */
 void * _dso_handle[32 /* must be at least 32 to guarantee ANSI conformance */];
 /* Bitmask is set if user function takes arguments.  */
 __ULong _fntypes; /* type of exit routine -
				   Must have at least _ATEXIT_SIZE bits */
 /* Bitmask is set if function was registered via __cxa_atexit.  */
 __ULong _is_cxa;
};


struct _atexit {
 struct _atexit *_next; /* next in list */
 int _ind; /* next index in this table */
 void (*_fns[32 /* must be at least 32 to guarantee ANSI conformance */])(void); /* the table itself */
        struct _on_exit_args * _on_exit_args_ptr;
};
# 96 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/*
 * Stdio buffers.
 *
 * This and __FILE are defined here because we need them for struct _reent,
 * but we don't want stdio.h included when stdlib.h is.
 */

struct __sbuf {
 unsigned char *_base;
 int _size;
};

/*
 * We need fpos_t for the following, but it doesn't have a leading "_",
 * so we use _fpos_t instead.
 */

typedef long _fpos_t; /* XXX must match off_t in <sys/types.h> */
    /* (and must be `long' for now) */





/*
 * Stdio state variables.
 *
 * The following always hold:
 *
 *	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
 *		_lbfsize is -_bf._size, else _lbfsize is 0
 *	if _flags&__SRD, _w is 0
 *	if _flags&__SWR, _r is 0
 *
 * This ensures that the getc and putc macros (or inline functions) never
 * try to write or read from a file that is in `read' or `write' mode.
 * (Moreover, they can, and do, automatically switch from read mode to
 * write mode, and back, on "r+" and "w+" files.)
 *
 * _lbfsize is used only to make the inline line-buffered output stream
 * code as compact as possible.
 *
 * _ub, _up, and _ur are used when ungetc() pushes back more characters
 * than fit in the current _bf, or when ungetc() pushes back a character
 * that does not match the previous one in _bf.  When this happens,
 * _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
 * _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
 */


/*
 * struct __sFILE_fake is the start of a struct __sFILE, with only the
 * minimal fields allocated.  In __sinit() we really allocate the 3
 * standard streams, etc., and point away from this fake.
 */
struct __sFILE_fake {
  unsigned char *_p; /* current position in (some) buffer */
  int _r; /* read space left for getc() */
  int _w; /* write space left for putc() */
  short _flags; /* flags, below; this FILE is free if 0 */
  short _file; /* fileno, if Unix descriptor, else -1 */
  struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */
  int _lbfsize; /* 0 or -_bf._size, for inline putc */

  struct _reent *_data;
};
/* CHECK_STD_INIT() comes from stdio/local.h; be sure to include that.  */





struct __sFILE {
  unsigned char *_p; /* current position in (some) buffer */
  int _r; /* read space left for getc() */
  int _w; /* write space left for putc() */
  short _flags; /* flags, below; this FILE is free if 0 */
  short _file; /* fileno, if Unix descriptor, else -1 */
  struct __sbuf _bf; /* the buffer (at least 1 byte, if !NULL) */
  int _lbfsize; /* 0 or -_bf._size, for inline putc */


  struct _reent *_data;


  /* operations */
  void * _cookie; /* cookie passed to io functions */

  int (*_read) (void * _cookie, char *_buf, int _n);
  int (*_write) (void * _cookie, const char *_buf, int _n);

  _fpos_t (*_seek) (void * _cookie, _fpos_t _offset, int _whence);
  int (*_close) (void * _cookie);

  /* separate buffer for long sequences of ungetc() */
  struct __sbuf _ub; /* ungetc buffer */
  unsigned char *_up; /* saved _p when _p is doing ungetc data */
  int _ur; /* saved _r when _r is counting ungetc data */

  /* tricks to meet minimum requirements even when malloc() fails */
  unsigned char _ubuf[3]; /* guarantee an ungetc() buffer */
  unsigned char _nbuf[1]; /* guarantee a getc() buffer */

  /* separate buffer for fgetline() when line crosses buffer boundary */
  struct __sbuf _lb; /* buffer for fgetline() */

  /* Unix stdio files get aligned to block boundaries on fseek() */
  int _blksize; /* stat.st_blksize (may be != _bf._size) */
  int _offset; /* current lseek offset */






  _flock_t _lock; /* for thread-safety locking */

};
# 261 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
typedef struct __sFILE __FILE;


struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};

/*
 * rand48 family support
 *
 * Copyright (c) 1993 Martin Birgmeier
 * All rights reserved.
 *
 * You may redistribute unmodified or modified versions of this source
 * code provided that the above copyright notice and this and the
 * following conditions are retained.
 *
 * This software is provided ``as is'', and comes with no warranties
 * of any kind. I shall in no event be liable for anything that happens
 * to anyone/anything when using this software.
 */







struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;

  /* Put this in here as well, for good luck.  */
  __extension__ unsigned long long _rand_next;

};

/* How big the some arrays are.  */




/*
 * struct _reent
 *
 * This structure contains *all* globals needed by the library.
 * It's raison d'etre is to facilitate threads by making all library routines
 * reentrant.  IE: All state information is contained here.
 */



struct _mprec
{
  /* used by mprec routines */
  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;
};


struct _misc_reent
{
  /* miscellaneous reentrant data */
  char *_strtok_last;
  _mbstate_t _mblen_state;
  _mbstate_t _wctomb_state;
  _mbstate_t _mbtowc_state;
  char _l64a_buf[8];
  int _getdate_err;
  _mbstate_t _mbrlen_state;
  _mbstate_t _mbrtowc_state;
  _mbstate_t _mbsrtowcs_state;
  _mbstate_t _wcrtomb_state;
  _mbstate_t _wcsrtombs_state;
};

/* This version of _reent is layed our with "int"s in pairs, to help
 * ports with 16-bit int's but 32-bit pointers, align nicely.  */
struct _reent
{

  /* FILE is a big struct and may change over time.  To try to achieve binary
     compatibility with future versions, put stdin,stdout,stderr here.
     These are pointers into member __sf defined below.  */
  __FILE *_stdin, *_stdout, *_stderr; /* XXX */

  int _errno; /* local copy of errno */

  int _inc; /* used by tmpnam */

  char *_emergency;

  int __sdidinit; /* 1 means stdio has been init'd */

  int _current_category; /* used by setlocale */
  const char *_current_locale;

  struct _mprec *_mp;

  void (*__cleanup) (struct _reent *);

  int _gamma_signgam;

  /* used by some fp conversion routines */
  int _cvtlen; /* should be size_t */
  char *_cvtbuf;

  struct _rand48 *_r48;
  struct __tm *_localtime_buf;
  char *_asctime_buf;

  /* signal info */
  void (**(_sig_func))(int);

  /* atexit stuff */
  struct _atexit *_atexit;
  struct _atexit _atexit0;

  struct _glue __sglue; /* root of glue chain */
  __FILE *__sf; /* file descriptors */
  struct _misc_reent *_misc; /* strtok, multibyte states */
  char *_signal_buf; /* strsignal */
};

extern const struct __sFILE_fake __sf_fake_stdin;
extern const struct __sFILE_fake __sf_fake_stdout;
extern const struct __sFILE_fake __sf_fake_stderr;
# 454 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/* Only built the assert() calls if we are built with debugging.  */






/* Generic _REENT check macro.  */
# 479 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/* Handle the dynamically allocated rand48 structure. */
# 784 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 3
/*
 * All references to struct _reent are via this pointer.
 * Internally, newlib routines that need to reference it should use _REENT.
 */





extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);

/* #define _REENT_ONLY define this to get only reentrant routines */
# 17 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdlib.h" 2 3
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/machine/stdlib.h" 1 3



/* place holder so platforms may add stdlib.h extensions */
# 18 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdlib.h" 2 3

# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/alloca.h" 1 3
/* libc/include/alloca.h - Allocate memory on stack */

/* Written 2000 by Werner Almesberger */
/* Rearranged for general inclusion by stdlib.h.
   2001, Corinna Vinschen <vinschen@redhat.com> */




# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* Some ANSI environments are "broken" in the sense that __STDC__ cannot be
   relied upon to have it's intended meaning.  Therefore we must use our own
   concoction: _HAVE_STDC.  Always use _HAVE_STDC instead of __STDC__ in newlib
   sources!

   To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
# 11 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/alloca.h" 2 3
# 1 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/sys/reent.h" 1 3
/* This header file provides the reentrancy.  */

/* WARNING: All identifiers here must begin with an underscore.  This file is
   included by stdio.h and others and we therefore must only use identifiers
   in the namespace allotted to us.  */
# 12 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/alloca.h" 2 3
# 20 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdlib.h" 2 3








typedef struct
{
  int quot; /* quotient */
  int rem; /* remainder */
} div_t;

typedef struct
{
  long quot; /* quotient */
  long rem; /* remainder */
} ldiv_t;


typedef struct
{
  long long int quot; /* quotient */
  long long int rem; /* remainder */
} lldiv_t;
# 57 "/opt/Xilinx/12.4/ISE_DS/EDK/gnu/microblaze/lin/bin/../lib/gcc/microblaze-xilinx-elf/4.1.2/../../../../microblaze-xilinx-elf/include/stdlib.h" 3
extern int __mb_cur_max;



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);

float atoff (const char *__nptr);

int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *));




void * calloc (size_t __nmemb, size_t __size);
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *);
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);
long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size);
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);


int mkstemp (char *);
char * mktemp (char *);


void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));
int rand (void);
void * realloc (void * __r, size_t __size);
void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
double _strtod_r (struct _reent *,const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);

/* the following strtodf interface is deprecated...use strtof instead */




long strtol (const char *__n, char **__end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__n, char **__end_PTR, int __base);

int system (const char *__string);


long a64l (const char *__input);
char * l64a (long __input);
char * _l64a_r (struct _reent *,long __input);
int on_exit (void (*__func)(int, void *),void * __arg);
void _Exit (int __status) __attribute__ ((noreturn));
int putenv (char *__string);
int _putenv_r (struct _reent *, char *__string);
int setenv (const char *__string, const char *__value, int __overwrite);
int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);

char * gcvt (double,int,char *);
char * gcvtf (float,int,char *);
char * fcvt (double,int,int *,int *);
char * fcvtf (float,int,int *,int *);
char * ecvt (double,int,int *,int *);
char * ecvtbuf (double, int, int*, int*, char *);
char * fcvtbuf (double, int, int*, int*, char *);
char * ecvtf (float,int,int *,int *);
char * dtoa (double, int, int, int *, int*, char**);
int rand_r (unsigned *__seed);

double drand48 (void);
double _drand48_r (struct _reent *);
double erand48 (unsigned short [3]);
double _erand48_r (struct _reent *, unsigned short [3]);
long jrand48 (unsigned short [3]);
long _jrand48_r (struct _reent *, unsigned short [3]);
void lcong48 (unsigned short [7]);
void _lcong48_r (struct _reent *, unsigned short [7]);
long lrand48 (void);
long _lrand48_r (struct _reent *);
long mrand48 (void);
long _mrand48_r (struct _reent *);
long nrand48 (unsigned short [3]);
long _nrand48_r (struct _reent *, unsigned short [3]);
unsigned short *
       seed48 (unsigned short [3]);
unsigned short *
       _seed48_r (struct _reent *, unsigned short [3]);
void srand48 (long);
void _srand48_r (struct _reent *, long);
long long atoll (const char *__nptr);
long long _atoll_r (struct _reent *, const char *__nptr);
long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *__n, char **__end_PTR, int __base);
long long _strtoll_r (struct _reent *, const char *__n, char **__end_PTR, int __base);
unsigned long long strtoull (const char *__n, char **__end_PTR, int __base);
unsigned long long _strtoull_r (struct _reent *, const char *__n, char **__end_PTR, int __base);


void cfree (void *);
void unsetenv (const char *__string);
void _unsetenv_r (struct _reent *, const char *__string);




char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t);
void * _calloc_r (struct _reent *, size_t, size_t);
void _free_r (struct _reent *, void *);
void * _realloc_r (struct _reent *, void *, size_t);
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);


# 85 "Life.c" 2

int RAND_MAX__global_0_0;



typedef struct {
 /* shared */ int value;
 int status;
} Shared_blackColor__global_0_0;
Shared_blackColor__global_0_0 blackColor__global_0_0;

struct life_datum__global_0_0 {
 int color;
 int x1;
 int y1;
};

struct life_datum__global_0_0 life_data__global_0_0[96 + 2][24 + 2];

typedef struct {
 /* shared */ struct life_datum__global_0_0 (*value)[96 + 2][24 + 2];
 int status;
} Shared_life_data_ptr__global_0_0;
Shared_life_data_ptr__global_0_0 life_data_ptr__global_0_0 = {.value = &life_data__global_0_0, .status = FOREC_SHARED_UNMODIFIED};

int grid__global_0_0[96 + 2][24 + 2];

typedef struct {
 /* shared */ int (*value)[96 + 2][24 + 2];
 int status;
} Shared_grid_ptr__global_0_0;
Shared_grid_ptr__global_0_0 grid_ptr__global_0_0 = {.value = &grid__global_0_0, .status = FOREC_SHARED_UNMODIFIED};

int next_grid__global_0_0[96 + 2][24 + 2];

typedef struct {
 /* shared */ int (*value)[96 + 2][24 + 2];
 int status;
} Shared_next_grid_ptr__global_0_0;
Shared_next_grid_ptr__global_0_0 next_grid_ptr__global_0_0 = {.value = &next_grid__global_0_0, .status = FOREC_SHARED_UNMODIFIED};

void do_step(const int threadNumber, int (*grid_ptr)[96 + 2][24 + 2], int (*next_grid_ptr)[96 + 2][24 + 2]);
void initialise(const int ncols, const int startIndex, const int endIndex, int (*grid_ptr)[96 + 2][24 + 2]);
void randomize_grid(const int ncols, const int startIndex, const int endIndex, int (*grid_ptr)[96 + 2][24 + 2], const float prob);
float rand_float(void);
void random_initByTime(void);

// thread do_step_0__thread(void);
// thread do_step_1__thread(void);
// thread do_step_2__thread(void);
// thread do_step_3__thread(void);

// Locally declared shared variables -------------------------------

// Global versions of local copies of shared variables -------------
// do_step_0
// do_step_1
// do_step_2
// do_step_3
// main

// forec:scheduler:boot:start
int main(int argc__main_0_0, char ** argv__main_0_0) {

/*==============================================================

| Multicore startup:

| Platform dependent code.  Core identifies itself and

| executes its corresponding start up code.

*=============================================================*/
# 154 "Life.c"
 // Initialise ForeC specific values ----------------------------
 // Thread main with par(...)s
 mainParParent.parStatus = FOREC_PAR_OFF;
 mainParCore0.sync = 1;
 mainParCore0.status = FOREC_CORE_REACTING;
 mainParCore1.sync = 1;
 mainParCore1.status = FOREC_CORE_REACTING;
 mainParCore2.sync = 1;
 mainParCore2.status = FOREC_CORE_REACTING;
 mainParCore3.sync = 1;
 mainParCore3.status = FOREC_CORE_REACTING;
 mainParReactionCounter = 0;


 // ForeC mutex -------------------------------------------------
 unsigned int forec_mutex_value;
 asm volatile ("put\t%0,rfsl" "1" :: "d" (0));

 // Variables for par()s ----------------------------------------
 // par0
 Thread do_step_0__thread;
 Thread do_step_1__thread;
 Thread do_step_2__thread;
 Thread do_step_3__thread;
 Thread mainReactionStartMaster0;
 Thread mainReactionStartSlave1;
 Thread mainReactionStartSlave2;
 Thread mainReactionStartSlave3;
 Thread mainReactionEndMaster0;
 Thread mainReactionEndSlave1;
 Thread mainReactionEndSlave2;
 Thread mainReactionEndSlave3;


 // Synchronise execution of cores ------------------------------
 // pvr = Processor Version Register
 unsigned int pvr0;
 asm volatile ("mfs\t%0,rpvr" "0" "\n\t" : "=d" (pvr0));
 pvr0 &= 0x000000FF;

 switch (pvr0) {
  case (0):
   while(mainParCore1.sync);
   while(mainParCore2.sync);
   while(mainParCore3.sync);
   goto mainParCore0;

  case (1):
   mainParCore1.sync = 0;
   goto mainParCore1;

  case (2):
   mainParCore2.sync = 0;
   goto mainParCore2;

  case (3):
   mainParCore3.sync = 0;
   goto mainParCore3;

  default:
   // "Lock-up" unused cores.
   while(1);
 }
// forec:scheduler:boot:end

/*==============================================================

| Core specific instructions:

| Contains par, abort and synchronisation handlers.

*=============================================================*/
# 224 "Life.c"
 // forec:thread:main:start
 /*--------------------------------------------------------------

	| Master core: core0

	| ForeC program's main() function:

	| Original main() function code with ForeC constructs

	| translated into C code.

	*-------------------------------------------------------------*/
# 232 "Life.c"
 // Thread local declarations -----------------------------------
 // No declarations.
mainParCore0: {
 // forec:scheduler:counter:start
 // Initialise and start counting the elapsed cycles for each reaction.
 counter.current = 0; counter.last = 0; counter.difference = 0; counter.min = 2147483647; counter.avg = 0; counter.max = 0; counter.total = 0; counter.iterations = 0;
 asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
 // forec:scheduler:counter:end

 //--------------------------------------------------------------

 // par0(do_step_0__thread, do_step_1__thread, do_step_2__thread, do_step_3__thread);
 // forec:statement:par:par0:start
 // Set the par(...) information.
 mainParParent.parId = 0;
 mainParParent.parStatus = FOREC_PAR_ON;

 // Link the threads and handlers together.
 mainReactionStartMaster0.programCounter = &&mainReactionStartMaster0;
 do_step_0__thread.programCounter = &&do_step_0__thread;
 mainReactionStartMaster0.nextThread = &do_step_0__thread;
 do_step_0__thread.prevThread = &mainReactionStartMaster0;
 mainReactionEndMaster0.programCounter = &&mainReactionEndMaster0;
 do_step_0__thread.nextThread = &mainReactionEndMaster0;
 mainReactionEndMaster0.prevThread = &do_step_0__thread;

 // Link the last and first threads/handlers together.
 mainReactionEndMaster0.nextThread = &mainReactionStartMaster0;
 mainReactionStartMaster0.prevThread = &mainReactionEndMaster0;

 // Set the join address.
 mainParParent.programCounter = &&par0JoinAddress_mainParCore0;

 // Set the core information.
 mainParCore0.activeThreads = 1;
 mainParCore0.reactionCounter = mainParReactionCounter;

 // Go to the first thread.
 goto do_step_0__thread;
 par0JoinAddress_mainParCore0:;
 // forec:statement:par:par0:end

 //--------------------------------------------------------------

 // forec:scheduler:threadRemove:main:start

 // forec:scheduler:counter:start
 // Stop counting the elapsed cycles for the current reaction.
 asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
 asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
 counter.difference = counter.current - counter.last;
 if (counter.max < counter.difference) { counter.max = counter.difference; };
 if (counter.min > counter.difference) { counter.min = counter.difference; };
 counter.total += counter.difference; counter.iterations++;
 counter.avg = counter.total/counter.iterations;
 xil_printf("%ld Reaction time: %d cycles, Min: %d, Avg: %d, Max: %d\r\n", globalReactions, counter.difference, counter.min, counter.avg, counter.max);
 xil_printf("Total time: %d cycles\r\n", counter.total);
 xil_printf("Program termination\r\n");
 // forec:scheduler:counter:end

 asm volatile (".long 0x80000001\r\n");
 return 0;
 // forec:scheduler:threadRemove:main:end
} // mainParCore0
 // forec:thread:main:end

// forec:scheduler:parHandler:main:master:0:start
mainParHandlerMaster0: {
 if (mainParParent.parId == -2) {
  // Iteration
  // Wait for other cores to complete their reaction.
  while(mainParCore1.status == FOREC_CORE_REACTING);
  while(mainParCore2.status == FOREC_CORE_REACTING);
  while(mainParCore3.status == FOREC_CORE_REACTING);

  mainParParent.parStatus = FOREC_PAR_OFF;
  mainParParent.parId = -1;

  // Set slave cores' status to reacting.
  mainParCore1.status = FOREC_CORE_REACTING;
  mainParCore2.status = FOREC_CORE_REACTING;
  mainParCore3.status = FOREC_CORE_REACTING;

  // Increment the reaction counter for synchronisation.
  mainParReactionCounter++;

  // Return to thread main.
  goto *mainParParent.programCounter;
 }

 // Control should not reach here.
 goto mainParHandlerMaster0;
}
// forec:scheduler:parHandler:main:master:0:end


 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:master:0:start
 //-- main:
mainReactionStartMaster0: {
 // Go to the next thread.
 goto *mainReactionStartMaster0.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:master:0:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:master:0:start
 //-- main:
mainReactionEndMaster0: {
 // Determine if the core can still react or not.
 if (mainParCore0.activeThreads) {
  mainParCore0.status = FOREC_CORE_REACTED;
 } else {
  mainParCore0.status = FOREC_CORE_TERMINATED;
 }

 // Wait for other cores to complete their reaction.
 while(mainParCore1.status == FOREC_CORE_REACTING);
 while(mainParCore2.status == FOREC_CORE_REACTING);
 while(mainParCore3.status == FOREC_CORE_REACTING);

 // Reset the mutex.
 asm volatile ("put\t%0,rfsl" "1" :: "d" (0));

 // Return back to the parent thread if all the cores have terminated.
 if (1 && mainParCore0.status == FOREC_CORE_TERMINATED && mainParCore1.status == FOREC_CORE_TERMINATED && mainParCore2.status == FOREC_CORE_TERMINATED && mainParCore3.status == FOREC_CORE_TERMINATED) {
  mainParParent.parStatus = FOREC_PAR_OFF;
  mainParParent.parId = -1;

  // Set slave cores' status to reacting
  mainParCore1.status = FOREC_CORE_REACTING;
  mainParCore2.status = FOREC_CORE_REACTING;
  mainParCore3.status = FOREC_CORE_REACTING;

  // Increment the reaction counter for synchronization.
  mainParReactionCounter++;

  goto *mainParParent.programCounter;
 }

 // Set slave cores' status to reacting
 mainParCore1.status = FOREC_CORE_REACTING;
 mainParCore2.status = FOREC_CORE_REACTING;
 mainParCore3.status = FOREC_CORE_REACTING;

 // forec:scheduler:counter:start
 // Stop counting the elapsed cycles for the current reaction.
 asm volatile ("put\t%0,rfsl" "2" :: "d" (0));
 asm volatile ("get\t%0,rfsl" "2" : "=d" (counter.current)); counter.current -= 3;
 counter.difference = counter.current - counter.last;
 if (counter.max < counter.difference) { counter.max = counter.difference; };
 if (counter.min > counter.difference) { counter.min = counter.difference; };
 counter.total += counter.difference; counter.iterations++;
 counter.avg = counter.total/counter.iterations;
 xil_printf("%d Reaction time: %ld cycles, Min: %d, Avg: %d, Max: %d\r\n", globalReactions, counter.difference, counter.min, counter.avg, counter.max);
 globalReactions++;
 // Restart counting of the elapsed cycles for the next reaction.
 counter.current = 0; counter.last = 0;
 asm volatile ("put\t%0,rfsl" "2" :: "d" (counter.current));
 // forec:scheduler:counter:end

 // Increment the reaction counter for synchronization.
 mainParReactionCounter++;

 // Go to the next thread.
 goto *mainReactionEndMaster0.nextThread -> programCounter;
}
 // forec:scheduler:reactionEnd:main:master:0:end



 // Abort check handlers ----------------------------------------


// forec:scheduler:parHandler:main:slave:1:start
/*--------------------------------------------------------------

| Slave core: core1

*-------------------------------------------------------------*/
# 415 "Life.c"
mainParCore1: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave1.programCounter = &&mainReactionStartSlave1;
  do_step_1__thread.programCounter = &&do_step_1__thread;
  mainReactionStartSlave1.nextThread = &do_step_1__thread;
  do_step_1__thread.prevThread = &mainReactionStartSlave1;
  mainReactionEndSlave1.programCounter = &&mainReactionEndSlave1;
  do_step_1__thread.nextThread = &mainReactionEndSlave1;
  mainReactionEndSlave1.prevThread = &do_step_1__thread;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave1.nextThread = &mainReactionStartSlave1;
  mainReactionStartSlave1.prevThread = &mainReactionEndSlave1;

  // Set the core information.
  mainParCore1.activeThreads = 1;
  mainParCore1.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto do_step_1__thread;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore1.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore1.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore1.reactionCounter == mainParReactionCounter);
   mainParCore1.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...) 
  goto mainParCore1;
 }

 // Control shouldn't reach here.
 goto mainParCore1;
}
// forec:scheduler:parHandler:main:slave:1:end

 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:1:start
 //-- main:
mainReactionStartSlave1: {
 // Go to the next thread.
 goto *mainReactionStartSlave1.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:1:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:1:start
 //-- main:
mainReactionEndSlave1: {
 // Determine if the core can still react or not.
 if (mainParCore1.activeThreads) {
  mainParCore1.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore1.reactionCounter == mainParReactionCounter);
  mainParCore1.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave1.nextThread -> programCounter;
 } else {
  int parId = mainParParent.parId;

  mainReactionEndSlave1.programCounter = &&terminated_mainReactionEndSlave1;
  terminated_mainReactionEndSlave1:;

  mainParCore1.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore1.reactionCounter == mainParReactionCounter);
  mainParCore1.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave1.nextThread -> programCounter;
  }

  goto mainParCore1;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave1;
}
 // forec:scheduler:reactionEnd:main:slave:1:end



 // Abort check handlers ----------------------------------------

// forec:scheduler:parHandler:main:slave:2:start
/*--------------------------------------------------------------

| Slave core: core2

*-------------------------------------------------------------*/
# 528 "Life.c"
mainParCore2: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave2.programCounter = &&mainReactionStartSlave2;
  do_step_2__thread.programCounter = &&do_step_2__thread;
  mainReactionStartSlave2.nextThread = &do_step_2__thread;
  do_step_2__thread.prevThread = &mainReactionStartSlave2;
  mainReactionEndSlave2.programCounter = &&mainReactionEndSlave2;
  do_step_2__thread.nextThread = &mainReactionEndSlave2;
  mainReactionEndSlave2.prevThread = &do_step_2__thread;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave2.nextThread = &mainReactionStartSlave2;
  mainReactionStartSlave2.prevThread = &mainReactionEndSlave2;

  // Set the core information.
  mainParCore2.activeThreads = 1;
  mainParCore2.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto do_step_2__thread;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore2.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore2.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore2.reactionCounter == mainParReactionCounter);
   mainParCore2.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...) 
  goto mainParCore2;
 }

 // Control shouldn't reach here.
 goto mainParCore2;
}
// forec:scheduler:parHandler:main:slave:2:end

 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:2:start
 //-- main:
mainReactionStartSlave2: {
 // Go to the next thread.
 goto *mainReactionStartSlave2.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:2:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:2:start
 //-- main:
mainReactionEndSlave2: {
 // Determine if the core can still react or not.
 if (mainParCore2.activeThreads) {
  mainParCore2.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore2.reactionCounter == mainParReactionCounter);
  mainParCore2.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave2.nextThread -> programCounter;
 } else {
  int parId = mainParParent.parId;

  mainReactionEndSlave2.programCounter = &&terminated_mainReactionEndSlave2;
  terminated_mainReactionEndSlave2:;

  mainParCore2.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore2.reactionCounter == mainParReactionCounter);
  mainParCore2.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave2.nextThread -> programCounter;
  }

  goto mainParCore2;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave2;
}
 // forec:scheduler:reactionEnd:main:slave:2:end



 // Abort check handlers ----------------------------------------

// forec:scheduler:parHandler:main:slave:3:start
/*--------------------------------------------------------------

| Slave core: core3

*-------------------------------------------------------------*/
# 641 "Life.c"
mainParCore3: {
 // Check the execution status of the root par(...)s.
 while (mainParParent.parStatus == FOREC_PAR_OFF);

 int parId = mainParParent.parId;

 // Check the par(...) ID.
 if (parId == 0) {
  asm("# par0 start");
  // Link the threads and handlers together.
  mainReactionStartSlave3.programCounter = &&mainReactionStartSlave3;
  do_step_3__thread.programCounter = &&do_step_3__thread;
  mainReactionStartSlave3.nextThread = &do_step_3__thread;
  do_step_3__thread.prevThread = &mainReactionStartSlave3;
  mainReactionEndSlave3.programCounter = &&mainReactionEndSlave3;
  do_step_3__thread.nextThread = &mainReactionEndSlave3;
  mainReactionEndSlave3.prevThread = &do_step_3__thread;

  // Link the last and first threads/handlers together.
  mainReactionEndSlave3.nextThread = &mainReactionStartSlave3;
  mainReactionStartSlave3.prevThread = &mainReactionEndSlave3;

  // Set the core information.
  mainParCore3.activeThreads = 1;
  mainParCore3.reactionCounter = mainParReactionCounter;

  // Go to the first thread.
  goto do_step_3__thread;
  asm("# par0 end");
 } else {
  // Unscheduled par(...)
  mainParCore3.reactionCounter = mainParReactionCounter;

  // Wait for the par(...) to terminate.
  do {
   mainParCore3.status = FOREC_CORE_TERMINATED;

   // Wait for the next reaction.
   while (mainParCore3.reactionCounter == mainParReactionCounter);
   mainParCore3.reactionCounter++;

  } while (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId);

  // Go back to the top and wait for the next nested par(...) 
  goto mainParCore3;
 }

 // Control shouldn't reach here.
 goto mainParCore3;
}
// forec:scheduler:parHandler:main:slave:3:end

 // Nested par(...) handlers ------------------------------------


 // Reaction start handlers ---------------------------------------
 // forec:scheduler:reactionStart:main:slave:3:start
 //-- main:
mainReactionStartSlave3: {
 // Go to the next thread.
 goto *mainReactionStartSlave3.nextThread -> programCounter;
}
 // forec:scheduler:reactionStart:main:slave:3:end



 // Reaction end handlers ---------------------------------------
 // forec:scheduler:reactionEnd:main:slave:3:start
 //-- main:
mainReactionEndSlave3: {
 // Determine if the core can still react or not.
 if (mainParCore3.activeThreads) {
  mainParCore3.status = FOREC_CORE_REACTED;

  // Wait for the next tick.
  while (mainParCore3.reactionCounter == mainParReactionCounter);
  mainParCore3.reactionCounter++;

  // Continue reacting.
  goto *mainReactionEndSlave3.nextThread -> programCounter;
 } else {
  int parId = mainParParent.parId;

  mainReactionEndSlave3.programCounter = &&terminated_mainReactionEndSlave3;
  terminated_mainReactionEndSlave3:;

  mainParCore3.status = FOREC_CORE_TERMINATED;

  // Wait for the next reaction.
  while (mainParCore3.reactionCounter == mainParReactionCounter);
  mainParCore3.reactionCounter++;

  // Wait for the par(...) to terminate.
  if (mainParParent.parStatus == FOREC_PAR_ON && mainParParent.parId == parId) {
   goto *mainReactionEndSlave3.nextThread -> programCounter;
  }

  goto mainParCore3;
 }

 // Control shouldn't reach here.
 goto mainReactionEndSlave3;
}
 // forec:scheduler:reactionEnd:main:slave:3:end



 // Abort check handlers ----------------------------------------



/*==============================================================

| ForeC threads:

| Threads code translated into C code.

*=============================================================*/
# 756 "Life.c"
 // forec:thread:do_step_0:start
 /*--------------------------------------------------------------

	| Thread do_step_0

	*-------------------------------------------------------------*/
# 761 "Life.c"
 // Thread local declarations -----------------------------------
 int RANGE__do_step_0_0_0;
 int ncols__do_step_0_0_0;
 int nrows__do_step_0_0_0;
 int threadNumber__do_step_0_0_0;
 int startIndex__do_step_0_0_0;
 int endIndex__do_step_0_0_0;
 int MAX_GENERATIONS__do_step_0_0_0;
 int generation__do_step_0_0_0;
 int i__do_step_0_1_0;

 // Thread body -------------------------------------------------
 do_step_0__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  RANGE__do_step_0_0_0 = 6;
  ncols__do_step_0_0_0 = 96;
  nrows__do_step_0_0_0 = 6*4;
  threadNumber__do_step_0_0_0 = 0;
  startIndex__do_step_0_0_0 = 1 + RANGE__do_step_0_0_0*threadNumber__do_step_0_0_0;
  endIndex__do_step_0_0_0 = RANGE__do_step_0_0_0*(threadNumber__do_step_0_0_0 + 1);
  MAX_GENERATIONS__do_step_0_0_0 = 2;
  generation__do_step_0_0_0 = 0;
  initialise(ncols__do_step_0_0_0, startIndex__do_step_0_0_0, endIndex__do_step_0_0_0, grid_ptr__global_0_0.value);

  while (generation__do_step_0_0_0++ < MAX_GENERATIONS__do_step_0_0_0) {
   for (i__do_step_0_1_0 = 0; i__do_step_0_1_0 <= nrows__do_step_0_0_0 + 1; i__do_step_0_1_0++) {
    (* grid_ptr__global_0_0.value)[0][i__do_step_0_1_0] = (* grid_ptr__global_0_0.value)[1][i__do_step_0_1_0];
    (* grid_ptr__global_0_0.value)[ncols__do_step_0_0_0 + 1][i__do_step_0_1_0] = (* grid_ptr__global_0_0.value)[ncols__do_step_0_0_0][i__do_step_0_1_0];
    asm volatile ("nop");
   }

   // pause;
   // forec:statement:pause:pause0:start
   do_step_0__thread.programCounter = &&pause0;
   goto *do_step_0__thread.nextThread -> programCounter;
   pause0:;
   // forec:statement:pause:pause0:end


   do_step(0, grid_ptr__global_0_0.value, next_grid_ptr__global_0_0.value);
   asm volatile ("nop");
  }

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:do_step_0:start

  // Delete thread from the linked list and core.
  mainParCore0.activeThreads--;
  do_step_0__thread.nextThread -> prevThread = do_step_0__thread.prevThread;
  do_step_0__thread.prevThread -> nextThread = do_step_0__thread.nextThread;
  goto *do_step_0__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:do_step_0:end
 } // do_step_0__thread
 // forec:thread:do_step_0:end

 // forec:thread:do_step_1:start
 /*--------------------------------------------------------------

	| Thread do_step_1

	*-------------------------------------------------------------*/
# 825 "Life.c"
 // Thread local declarations -----------------------------------
 int RANGE__do_step_1_0_0;
 int ncols__do_step_1_0_0;
 int nrows__do_step_1_0_0;
 int threadNumber__do_step_1_0_0;
 int startIndex__do_step_1_0_0;
 int endIndex__do_step_1_0_0;
 int MAX_GENERATIONS__do_step_1_0_0;
 int generation__do_step_1_0_0;
 int i__do_step_1_1_0;

 // Thread body -------------------------------------------------
 do_step_1__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  RANGE__do_step_1_0_0 = 6;
  ncols__do_step_1_0_0 = 96;
  nrows__do_step_1_0_0 = 6*4;
  threadNumber__do_step_1_0_0 = 1;
  startIndex__do_step_1_0_0 = 1 + RANGE__do_step_1_0_0*threadNumber__do_step_1_0_0;
  endIndex__do_step_1_0_0 = RANGE__do_step_1_0_0*(threadNumber__do_step_1_0_0 + 1);
  MAX_GENERATIONS__do_step_1_0_0 = 2;
  generation__do_step_1_0_0 = 0;
  initialise(ncols__do_step_1_0_0, startIndex__do_step_1_0_0, endIndex__do_step_1_0_0, grid_ptr__global_0_0.value);

  while (generation__do_step_1_0_0++ < MAX_GENERATIONS__do_step_1_0_0) {
   for (i__do_step_1_1_0 = 1; i__do_step_1_1_0 <= ncols__do_step_1_0_0; i__do_step_1_1_0++) {
    (* grid_ptr__global_0_0.value)[i__do_step_1_1_0][0] = (* grid_ptr__global_0_0.value)[i__do_step_1_1_0][nrows__do_step_1_0_0];
    (* grid_ptr__global_0_0.value)[i__do_step_1_1_0][nrows__do_step_1_0_0 + 1] = (* grid_ptr__global_0_0.value)[i__do_step_1_1_0][1];
    asm volatile ("nop");
   }

   // pause;
   // forec:statement:pause:pause1:start
   do_step_1__thread.programCounter = &&pause1;
   goto *do_step_1__thread.nextThread -> programCounter;
   pause1:;
   // forec:statement:pause:pause1:end


   do_step(1, grid_ptr__global_0_0.value, next_grid_ptr__global_0_0.value);
   asm volatile ("nop");
  }

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:do_step_1:start

  // Delete thread from the linked list and core.
  mainParCore1.activeThreads--;
  do_step_1__thread.nextThread -> prevThread = do_step_1__thread.prevThread;
  do_step_1__thread.prevThread -> nextThread = do_step_1__thread.nextThread;
  goto *do_step_1__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:do_step_1:end
 } // do_step_1__thread
 // forec:thread:do_step_1:end

 // forec:thread:do_step_2:start
 /*--------------------------------------------------------------

	| Thread do_step_2

	*-------------------------------------------------------------*/
# 889 "Life.c"
 // Thread local declarations -----------------------------------
 int RANGE__do_step_2_0_0;
 int ncols__do_step_2_0_0;
 int nrows__do_step_2_0_0;
 int threadNumber__do_step_2_0_0;
 int startIndex__do_step_2_0_0;
 int endIndex__do_step_2_0_0;
 int MAX_GENERATIONS__do_step_2_0_0;
 int generation__do_step_2_0_0;

 // Thread body -------------------------------------------------
 do_step_2__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  RANGE__do_step_2_0_0 = 6;
  ncols__do_step_2_0_0 = 96;
  nrows__do_step_2_0_0 = 6*4;
  threadNumber__do_step_2_0_0 = 2;
  startIndex__do_step_2_0_0 = 1 + RANGE__do_step_2_0_0*threadNumber__do_step_2_0_0;
  endIndex__do_step_2_0_0 = RANGE__do_step_2_0_0*(threadNumber__do_step_2_0_0 + 1);
  MAX_GENERATIONS__do_step_2_0_0 = 2;
  generation__do_step_2_0_0 = 0;
  initialise(ncols__do_step_2_0_0, startIndex__do_step_2_0_0, endIndex__do_step_2_0_0, grid_ptr__global_0_0.value);

  while (generation__do_step_2_0_0++ < MAX_GENERATIONS__do_step_2_0_0) {
   (* grid_ptr__global_0_0.value)[0][0] = (* grid_ptr__global_0_0.value)[0][nrows__do_step_2_0_0];
   (* grid_ptr__global_0_0.value)[0][nrows__do_step_2_0_0 + 1] = (* grid_ptr__global_0_0.value)[0][1];
   (* grid_ptr__global_0_0.value)[ncols__do_step_2_0_0 + 1][0] = (* grid_ptr__global_0_0.value)[ncols__do_step_2_0_0 + 1][nrows__do_step_2_0_0];
   (* grid_ptr__global_0_0.value)[ncols__do_step_2_0_0 + 1][nrows__do_step_2_0_0 + 1] = (* grid_ptr__global_0_0.value)[ncols__do_step_2_0_0 + 1][1];

   // pause;
   // forec:statement:pause:pause2:start
   do_step_2__thread.programCounter = &&pause2;
   goto *do_step_2__thread.nextThread -> programCounter;
   pause2:;
   // forec:statement:pause:pause2:end


   do_step(2, grid_ptr__global_0_0.value, next_grid_ptr__global_0_0.value);
   asm volatile ("nop");
  }

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:do_step_2:start

  // Delete thread from the linked list and core.
  mainParCore2.activeThreads--;
  do_step_2__thread.nextThread -> prevThread = do_step_2__thread.prevThread;
  do_step_2__thread.prevThread -> nextThread = do_step_2__thread.nextThread;
  goto *do_step_2__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:do_step_2:end
 } // do_step_2__thread
 // forec:thread:do_step_2:end

 // forec:thread:do_step_3:start
 /*--------------------------------------------------------------

	| Thread do_step_3

	*-------------------------------------------------------------*/
# 951 "Life.c"
 // Thread local declarations -----------------------------------
 int RANGE__do_step_3_0_0;
 int ncols__do_step_3_0_0;
 int threadNumber__do_step_3_0_0;
 int startIndex__do_step_3_0_0;
 int endIndex__do_step_3_0_0;
 int MAX_GENERATIONS__do_step_3_0_0;
 int generation__do_step_3_0_0;

 // Thread body -------------------------------------------------
 do_step_3__thread: {
  // Initialise the local copies of shared variables.
  //--------------------------------------------------------------

  RANGE__do_step_3_0_0 = 6;
  ncols__do_step_3_0_0 = 96;
  threadNumber__do_step_3_0_0 = 3;
  startIndex__do_step_3_0_0 = 1 + RANGE__do_step_3_0_0*threadNumber__do_step_3_0_0;
  endIndex__do_step_3_0_0 = RANGE__do_step_3_0_0*(threadNumber__do_step_3_0_0 + 1);
  MAX_GENERATIONS__do_step_3_0_0 = 2;
  generation__do_step_3_0_0 = 0;
  initialise(ncols__do_step_3_0_0, startIndex__do_step_3_0_0, endIndex__do_step_3_0_0, grid_ptr__global_0_0.value);

  while (generation__do_step_3_0_0++ < MAX_GENERATIONS__do_step_3_0_0) {
   // pause;
   // forec:statement:pause:pause3:start
   do_step_3__thread.programCounter = &&pause3;
   goto *do_step_3__thread.nextThread -> programCounter;
   pause3:;
   // forec:statement:pause:pause3:end


   do_step(3, grid_ptr__global_0_0.value, next_grid_ptr__global_0_0.value);
   asm volatile ("nop");
  }

  //--------------------------------------------------------------
  // Write the defined shared variables back to their global copy.

  // forec:scheduler:threadRemove:do_step_3:start

  // Delete thread from the linked list and core.
  mainParCore3.activeThreads--;
  do_step_3__thread.nextThread -> prevThread = do_step_3__thread.prevThread;
  do_step_3__thread.prevThread -> nextThread = do_step_3__thread.nextThread;
  goto *do_step_3__thread.nextThread -> programCounter;
  // forec:scheduler:threadRemove:do_step_3:end
 } // do_step_3__thread
 // forec:thread:do_step_3:end


} // End of the main() function.

void do_step(const int threadNumber__do_step_0_0, int (*grid_ptr__do_step_0_0)[96 + 2][24 + 2], int (*next_grid_ptr__do_step_0_0)[96 + 2][24 + 2]) {
 int RANGE__do_step_0_0 = 6;
 int ncols__do_step_0_0 = 96;
 int startIndex__do_step_0_0 = 1 + RANGE__do_step_0_0*threadNumber__do_step_0_0;
 int endIndex__do_step_0_0 = RANGE__do_step_0_0*(threadNumber__do_step_0_0 + 1);
 int i__do_step_0_0;
 for (i__do_step_0_0 = 1; i__do_step_0_0 <= ncols__do_step_0_0; i__do_step_0_0++) {
  int j__do_step_1_0;
  for (j__do_step_1_0 = startIndex__do_step_0_0; j__do_step_1_0 <= endIndex__do_step_0_0; j__do_step_1_0++) {
   int neighbors__do_step_2_0 = 0;
   int k__do_step_2_0;
   for (k__do_step_2_0 = i__do_step_0_0 - 1; k__do_step_2_0 <= i__do_step_0_0 + 1; k__do_step_2_0++) {
    int l__do_step_3_0;
    for (l__do_step_3_0 = j__do_step_1_0 - 1; l__do_step_3_0 <= j__do_step_1_0 + 1; l__do_step_3_0++) {
     if (!(k__do_step_2_0 == i__do_step_0_0 && l__do_step_3_0 == j__do_step_1_0) && (* grid_ptr__do_step_0_0)[k__do_step_2_0][l__do_step_3_0] > 0) {
      neighbors__do_step_2_0++;
     } else {
      // if0
     }
     asm volatile ("nop");
    }
    if (neighbors__do_step_2_0 > 3) {
     continue;
    } else {
     // if1
    }
    asm volatile ("nop");
   }
   if (neighbors__do_step_2_0 < 2 || neighbors__do_step_2_0 > 3) {
    (* next_grid_ptr__do_step_0_0)[i__do_step_0_0][j__do_step_1_0] = 0;
   } else {
    // ifElse3
    if ((* grid_ptr__do_step_0_0)[i__do_step_0_0][j__do_step_1_0] > 0 || neighbors__do_step_2_0 == 3) {
     (* next_grid_ptr__do_step_0_0)[i__do_step_0_0][j__do_step_1_0] = (* grid_ptr__do_step_0_0)[i__do_step_0_0][j__do_step_1_0] + 1;
    } else {
     // if2
    }
   }
   asm volatile ("nop");
  }
  asm volatile ("nop");
 }
 for (i__do_step_0_0 = 0; i__do_step_0_0 < ncols__do_step_0_0 + 2; i__do_step_0_0++) {
  int j__do_step_1_1;
  for (j__do_step_1_1 = startIndex__do_step_0_0; j__do_step_1_1 <= endIndex__do_step_0_0; j__do_step_1_1++) {
   (* grid_ptr__do_step_0_0)[i__do_step_0_0][j__do_step_1_1] = (* next_grid_ptr__do_step_0_0)[i__do_step_0_0][j__do_step_1_1];
   asm volatile ("nop");
  }
  asm volatile ("nop");
 }
}

void initialise(const int ncols__initialise_0_0, const int startIndex__initialise_0_0, const int endIndex__initialise_0_0, int (*grid_ptr__initialise_0_0)[96 + 2][24 + 2]) {
 srand(0x0);
 randomize_grid(ncols__initialise_0_0, startIndex__initialise_0_0, endIndex__initialise_0_0, grid_ptr__initialise_0_0, 0.25);
}

void randomize_grid(const int ncols__randomize_grid_0_0, const int startIndex__randomize_grid_0_0, const int endIndex__randomize_grid_0_0, int (*grid_ptr__randomize_grid_0_0)[96 + 2][24 + 2], const float prob__randomize_grid_0_0) {
 int i__randomize_grid_0_0;
 for (i__randomize_grid_0_0 = 1; i__randomize_grid_0_0 <= ncols__randomize_grid_0_0; i__randomize_grid_0_0++) {
  int j__randomize_grid_1_0;
  for (j__randomize_grid_1_0 = startIndex__randomize_grid_0_0; j__randomize_grid_1_0 <= endIndex__randomize_grid_0_0; j__randomize_grid_1_0++) {
   (* grid_ptr__randomize_grid_0_0)[i__randomize_grid_0_0][j__randomize_grid_1_0] = rand_float() < prob__randomize_grid_0_0;
   asm volatile ("nop");
  }
  asm volatile ("nop");
 }
}

float rand_float(void) {
 return (float)rand()/(float)0x7fffffff;
}
